#!/usr/bin/perl -w

# $Id$
#
# Copyright (c) 2006 Oak Ridge National Laboratory.
#                  All rights reserved.
#
# This file is a very simple selector that will select
# or unselect packages to be installed in OSCAR.  You can also
# print out the packages or a subset of packages to see which
# are currently selected.

use strict;
use lib "$ENV{OSCAR_HOME}/lib","$ENV{OSCAR_HOME}/lib/Qt";
use OSCAR::Logger;
use OSCAR::Database;
use Qt::SelectorUtils;
use Qt::SelectorTable;
use Getopt::Long;

# Command line arguement variables
my $file = '';
my $inun = 0;
my $help = '';

# Parses the command line args
GetOptions('help' => \$help, 'm' => \$inun, 'filename=s' => \$file, 'f=s' => \$file);

# The help text
if ($help)
{
	print "Usage: selector_cli [FLAGS]

    -m                        maintain current package state
    --filename -f filename    File to be read in to automate this step\n";			exit 0;
}

my %options = ();
my @errors = ();
$| = 1;

my ($printStatus, $printPackage, $printClass, $printVersion);

#Format to print out the package information
format STDOUT=
@|||||||||||@|||||||||||||||||@|||||||||||@||||||||||||||
$printStatus,  $printPackage,  $printClass, $printVersion
.

#If the debug option is set, we should use it
$options{debug} = 1 if $ENV{OSCAR_DB_DEBUG};

OSCAR::Logger::oscar_log_section("Beginning the OSCAR Package Selector");

#Populate the list of packages
OSCAR::Logger::oscar_log_subsection("Populating list of packages");

my @groups_list;
my @package_sets;
my $selected_group;

my $success = OSCAR::Database::get_groups_for_packages(\@groups_list);

foreach my $groups_ref (@groups_list) {
    push @package_sets, $$groups_ref{group_name};
}

if($success) {
    if ((scalar @package_sets) > 0) {
        $selected_group = OSCAR::Database::get_selected_group(\%options, \@errors);
        if(!$selected_group) {$selected_group = "Default";}
    } else {
        SelectorUtils::createDefaultPackageSet();
    }
}

#Get all the selected packages
my $selected_packages = SelectorTable::getPackagesInPackageSet($selected_group);

#Get installed packages
my $installed_packages = SelectorTable::getPackagesInstalled();

#Get a list of all the packages
my $allPackages = SelectorUtils::getAllPackages();

#Set the package status
foreach my $package_ref (keys %{$allPackages}) {
    $$allPackages{$package_ref}{status} = "Unselected";
    $$allPackages{$package_ref}{status} = "Selected" if $$selected_packages{$package_ref};
    $$allPackages{$package_ref}{status} = "Installed" if $$installed_packages{$package_ref};
}

#If there is a filename as an arguement, don't get user input 
if($file ne '') { 
    #If the user doesn't want to maintain the package state, 
    #reset all core and included packages to selected and others to unselected 
    if($inun == 1) { 
        foreach my $pack (keys %{$allPackages}) { 
            if($$allPackages{$pack}{__class} eq "core" || $$allPackages{$pack}{__class} eq "included") { 
                processInput("select -q $pack"); 
            } else { 
                processInput("unselect -q $pack"); 
            } 
        } 
    } 
    processInput("file " . $file); 
    processInput("quit"); 
} 

#List the packages and start getting input
#Print the packages before giving a prompt
printPackages("all");

#Start the prompt section
#This will exit by the user typing 'quit'
my $ppid = getppid();
open(LOG, ">$ENV{OSCAR_HOME}/tmp/selector.$ppid.clilog") || die "Can't open the log to write to.\n";
my $continue = 1;
while($continue)
{
	print "selector>  ";
	my $response = <STDIN>;
	print LOG $response;
	chomp $response;
	$continue = processInput($response);
}
close LOG;

# Print the packages that match the specified class (core, included, third party, all)
# with their <status> <short package name> <class> <version>
sub printPackages
{
	my $class = shift; #The class name should be the only arguement
	OSCAR::Logger::oscar_log_subsection("List of packages");
	if(defined $class && $class eq "core")
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			if($$allPackages{$package}{__class} eq "core")
			{
				#Need to set up these variables to be printed out
				$printStatus = $$allPackages{$package}{status};
				$printPackage = $package;
				$printClass = $$allPackages{$package}{__class};
				$printVersion = $$allPackages{$package}{version};
				
				#Print out the information
				write;
			}
		}
		return;
	}
	elsif(defined $class && $class eq "included")
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			if($$allPackages{$package}{__class} eq "included")
			{
				#Need to set up these variables to be printed out
				$printStatus = $$allPackages{$package}{status};
				$printPackage = $package;
				$printClass = $$allPackages{$package}{__class};
				$printVersion = $$allPackages{$package}{version};
				
				#Print out the information
				write;
			}
		}
		return;
	}
	elsif(defined $class && $class eq "third-party")
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			#Need to set up these variables to be printed out
			if($$allPackages{$package}{__class} eq "third-party")
			{
				$printStatus = $$allPackages{$package}{status};
				$printPackage = $package;
				$printClass = $$allPackages{$package}{__class};
				$printVersion = $$allPackages{$package}{version};
				
				#Print out the information
				write;
			}
		}
		return;
	}
	else
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			#Need to set up these variables to be printed out
			$printStatus = $$allPackages{$package}{status};
			$printPackage = $package;
			$printClass = $$allPackages{$package}{__class};
			$printVersion = $$allPackages{$package}{version};
			
			#Print out the information
			write;
		}
		return;
	}
}

#Process the user's response from the prompt
sub processInput 
{
	#Change the response from a scalar to an array
	my @response = split(' ', shift);

    my $command = shift(@response);
	
	#By default, ask for help
	if(!defined $command)
	{
		$command = "help";
	}
	
	#If the user is trying to select a package
	if($command eq "select")
	{
        my $packagename = shift(@response);

        if(!$packagename) {
            print "Format: select [-q] package_name\n";
            return 1;
        }

		#If the user adds a -q flag, don't print out the verbose dialog
		my $quiet = 0;
		if($packagename eq "-q")
		{
			$quiet = 1;
			#Move the next arguement over to make parsing the command line easy
			$packagename = shift(@response);
            
            if(!$packagename) {
                print "Format: select [-q] package_name\n";
                return 1;
            }
		}

		#Make sure the package exists and is not already installed
		if(defined $$allPackages{$packagename} && $$allPackages{$packagename}{status} ne "Installed")
		{
			$$allPackages{$packagename}{status} = "Selected";
			$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$packagename,2,\@errors);
			
			#Check for dependencies
			print "Checking dependencies\n" unless $quiet;
			my $dependencies;
			$dependencies = SelectorUtils::getRequiresList($dependencies,$packagename);
			delete $$dependencies{""}; #Delete the empty key
			#If there is a dependency, select it
			foreach my $name (keys %{$dependencies})
			{
				if ($name eq $packagename) {next;}
				print "Package dependant on " . $name . "\n" unless $quiet;
				$$allPackages{$name}{status} = "Selected";
				$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$name,2,\@errors);
			}
			
			#Check for conflicts
			print "Checking conflicts\n" unless $quiet;
			my $conflict;
			$conflict = SelectorUtils::getConflictsList($dependencies);
			#If there is a conflict, unselect the conflicting package
			delete $$conflict{""}; #Delete the empty key
			foreach my $name (keys %{$conflict})
			{
				if ($name eq $packagename) {next;}
				print "Conflicting package " . $name . "\n" unless $quiet;
				$$allPackages{$name}{status} = "Unselected";
				$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$name,1,\@errors);
			}
		}
		elsif(!defined $$allPackages{$packagename})
		{
			print "Package name " . $packagename . " not recognized\n" unless $quiet;
		}
		elsif($$allPackages{$packagename}{status} eq "Installed")
		{
			print "Package " . $packagename . " already installed\n" unless $quiet;
		}
	}
	#If the user is trying unselect a package
	elsif($command eq "unselect")
	{
        my $packagename = shift(@response);

        if(!$packagename) {
            print "Format: select [-q] package_name\n";
            return 1;
        }

		#If the user adds a -q flag, don't print out the verbose dialog
		my $quiet = 0;
		if($packagename eq "-q")
		{
			$quiet = 1;
			#Move the next arguement over to make parsing the command line easy
			$packagename = shift(@response);

            if(!$packagename) {
                print "Format: select [-q] package_name\n";
                return 1;
            }
		}

		#Make sure the package exists
		if(defined $$allPackages{$packagename} && $$allPackages{$packagename}{__class} ne "core")
		{
			$$allPackages{$packagename}{status} = "Unselected";
			$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$packagename,1,\@errors);
			
			#Check to see if anything depends on this
			print "Checking dependencies\n" unless $quiet;
			my $reqby;
			$reqby = SelectorUtils::getIsRequiredByList($reqby,$packagename);
			delete $$reqby{""}; #Delete the empty key
			#If something depended on this package, unselect it
			foreach my $package (keys %{$reqby})
			{
				if ($package eq $packagename) {next;}
				print "Package " . $package . " depends on " . $packagename . "\n" unless $quiet;
				$$allPackages{$package}{status} = "Unselected";
				$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$package,1,\@errors);
			}
		}
		elsif(!defined $$allPackages{$packagename})
		{
			print "Package name " . $packagename . " not recognized\n" unless $quiet;
		}
		elsif($$allPackages{$packagename}{__class} eq "core")
		{
			print "Cannot unselect core packages\n" unless $quiet;
		}
	}
	#If the user is trying to list the packages again
	elsif($command eq "list")
	{
        my $class = shift(@response);
        
		#The default action if the selected class does not exist is to print all of the packages
		if(!defined $class)
		{
			printPackages("all");
		}
		else
		{
			printPackages($class);
		}
	}
	#If the user is trying to quit the program
	elsif($command eq "quit" || $command eq "exit")
	{
		#Everything should already have been taken care of so go ahead and move on
		return 0;
	}
	#If the user wants to read in responses from a file
	elsif($command eq "file")
	{
        my $filename = shift(@response);

        if(!$filename) {
            print "Format: file file_name\n";
            return 1;
        }

		open(FILE, $filename);
		#Read the file just like it is normal input from the keyboard
		#The file is not required to have a quit command in it
		while(<FILE>)
		{
			chomp $_;
			processInput($_);
		}
        exit 0;
	}
	#Default response is to print out the list of commands and their use
	else
	{
		print "select <packageName> - Select a package to be installed
	-q - Quiet mode:  Don't print out verbose dialog
unselect <packageName> - Unselect a package to prevent it from being installed
	-q - Quiet mode:  Don't print out verbose dialog
list <class> - Lists the packages and their installation status, class, and version number
file <filename> - Reads in commands from a file
help - Prints this message
quit/exit - Quits the selector\n";
	}

    return 1;
}
