#!/usr/bin/perl -w

# $Id$
#
# Copyright (c) 2006 Oak Ridge National Laboratory.
#                  All rights reserved.
#
# This file is a very simple selector that will select
# or unselect packages to be installed in OSCAR.  You can also
# print out the packages or a subset of packages to see which
# are currently selected.  By running this script with a filename
# as an arguement, the script will not require user input, but
# follow your instructions as you specify.

use strict;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::Logger;
use OSCAR::Database;
use Qt::SelectorUtils;
use Getopt::Long;

my $file = '';
my $inun = 0;
my $help = '';

GetOptions('help' => \$help, 'm' => \$inun, 'filename=s' => \$file, 'f=s' => \$file);

if ($help)
{
	print "Usage: selector_cli [FLAGS]

  -m			  Maintain current package state
  --filename -f filename  File to be read in to automate this step\n";			exit 0;
}

my %options = ();
my @errors = ();
$| = 1;

my ($printStatus, $printPackage, $printClass, $printVersion);

#Format to print out the package information
format STDOUT=
@|||||||||||@|||||||||||||||||@|||||||||||@||||||||||||||
$printStatus,  $printPackage,  $printClass, $printVersion
.

#If the debug option is set, we should use it
$options{debug} = 1 if $ENV{OSCAR_DB_DEBUG};

OSCAR::Logger::oscar_log_section("Beginning the OSCAR Package Selector");

#Populate the list of packages
OSCAR::Logger::oscar_log_subsection("Populating list of packages");

#Get a list of all the packages
my $allPackages = SelectorUtils::getAllPackages();
#Get the status of each package (Installed (8), Selected(2), Unselected(1))
my @packagesUnselected;
my @packagesSelected;
my @packagesInstalled;

#Get the unselected packages
my $success = OSCAR::Database::get_node_package_status_with_node("oscar_server",\@packagesUnselected,\%options,\@errors, 1 );

#Get the seleceted packages
$success = OSCAR::Database::get_node_package_status_with_node("oscar_server",\@packagesSelected,\%options,\@errors, 2 );

#Get the installed packages
$success = OSCAR::Database::get_node_package_status_with_node("oscar_server",\@packagesInstalled,\%options,\@errors, 8 );

#Put a new key in the all packages hash with the current status of the package
foreach my $pack_ref (@packagesUnselected)
{
	my $pack = $$pack_ref{package};
	$$allPackages{$pack}{status} = "Unselected";
}
foreach my $pack_ref (@packagesSelected)
{
	my $pack = $$pack_ref{package};
	$$allPackages{$pack}{status} = "Selected";
}
foreach my $pack_ref (@packagesInstalled)
{
	my $pack = $$pack_ref{package};
	$$allPackages{$pack}{status} = "Installed";
}

#If there is a filename as an arguement, don't get user input
if($file ne '')
{
	#If the user doesn't want to maintain the package state,
	#reset all core and included packages to selected and others to unselected
	if($inun == 1)
	{
		foreach my $pack (keys %{$allPackages})
		{
			if($$allPackages{$pack}{__class} eq "core" || $$allPackages{$pack}{__class} eq "included")
			{
				processInput("select -q $pack");
			}
			else
			{
				processInput("unselect -q $pack");
			}
		}
	}
	processInput("file " . $file);
	processInput("quit");
}

#If the user doesn't want to maintain the package state,
#reset all core and included packages to selected and others to unselected
if($inun == 1)
{
	foreach my $pack (keys %{$allPackages})
	{
		if($$allPackages{$pack}{__class} eq "core" || $$allPackages{$pack}{__class} eq "included")
		{
			processInput("select -q $pack");
		}
		else
		{
			processInput("unselect -q $pack");
		}
	}
}

#Otherwise, list the packages and start getting input
#Print the packages before giving a prompt
printPackages("all");

#Start the prompt section
#This will exit by the user typing 'quit'
open(LOG, ">$ENV{OSCAR_HOME}/tmp/selector.log") || die "Can't open the log to write to.\n";
while(1)
{
	print "selector>  ";
	my $response = <STDIN>;
	print LOG $response;
	chomp $response;
	processInput($response);
}
close LOG;

# Print the packages that match the specified class (core, included, third party, all)
# with their <status> <short package name> <class> <version>
sub printPackages
{
	my $class = shift; #The class name should be the only arguement
	OSCAR::Logger::oscar_log_subsection("List of packages");
	if(defined $class && $class eq "core")
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			if($$allPackages{$package}{__class} eq "core")
			{
				#Need to set up these variables to be printed out
				$printStatus = $$allPackages{$package}{status};
				$printPackage = $package;
				$printClass = $$allPackages{$package}{__class};
				$printVersion = $$allPackages{$package}{version};
				
				#Print out the information
				write;
			}
		}
		return;
	}
	elsif(defined $class && $class eq "included")
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			if($$allPackages{$package}{__class} eq "included")
			{
				#Need to set up these variables to be printed out
				$printStatus = $$allPackages{$package}{status};
				$printPackage = $package;
				$printClass = $$allPackages{$package}{__class};
				$printVersion = $$allPackages{$package}{version};
				
				#Print out the information
				write;
			}
		}
		return;
	}
	elsif(defined $class && $class eq "third-party")
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			#Need to set up these variables to be printed out
			if($$allPackages{$package}{__class} eq "third-party")
			{
				$printStatus = $$allPackages{$package}{status};
				$printPackage = $package;
				$printClass = $$allPackages{$package}{__class};
				$printVersion = $$allPackages{$package}{version};
				
				#Print out the information
				write;
			}
		}
		return;
	}
	else
	{
		print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
		foreach my $package (keys %{$allPackages})
		{
			#Need to set up these variables to be printed out
			$printStatus = $$allPackages{$package}{status};
			$printPackage = $package;
			$printClass = $$allPackages{$package}{__class};
			$printVersion = $$allPackages{$package}{version};
			
			#Print out the information
			write;
		}
		return;
	}
}

#Process the user's response from the prompt
sub processInput 
{
	#Change the response from a scalar to an array
	my @response = split(' ', shift);
	
	#By default, ask for help
	if(!defined $response[0])
	{
		$response[0] = "help";
	}
	
	#If the user is trying to select a package
	if($response[0] eq "select")
	{
		#If the user adds a -q flag, don't print out the verbose dialog
		my $quiet = 0;
		if($response[1] eq "-q")
		{
			$quiet = 1;
			#Move the next arguement over to make parsing the command line easy
			$response[1] = $response[2];
		}

		#Make sure the package exists and is not already installed
		if(defined $$allPackages{$response[1]} && $$allPackages{$response[1]}{status} ne "Installed")
		{
			$$allPackages{$response[1]}{status} = "Selected";
			$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$response[1],2,\@errors);
			
			#Check for dependencies
			print "Checking dependencies\n" unless $quiet;
			my $dependencies;
			$dependencies = SelectorUtils::getRequiresList($dependencies,$response[1]);
			delete $$dependencies{""}; #Delete the empty key
			#If there is a dependency, select it
			foreach my $packageName (keys %{$dependencies})
			{
				if ($packageName eq $response[1]) {next;}
				print "Package dependant on " . $packageName . "\n" unless $quiet;
				$$allPackages{$packageName}{status} = "Selected";
				$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$packageName,2,\@errors);
			}
			
			#Check for conflicts
			print "Checking conflicts\n" unless $quiet;
			my $conflict;
			$conflict = SelectorUtils::getConflictsList($dependencies);
			#If there is a conflict, unselect the conflicting package
			delete $$conflict{""}; #Delete the empty key
			foreach my $packageName (keys %{$conflict})
			{
				if ($packageName eq $response[1]) {next;}
				print "Conflicting package " . $packageName . "\n" unless $quiet;
				$$allPackages{$packageName}{status} = "Unselected";
				$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$packageName,1,\@errors);
			}
		}
		elsif(!defined $$allPackages{$response[1]})
		{
			print "Package name " . $response[1] . " not recognized\n" unless $quiet;
		}
		elsif($$allPackages{$response[1]}{status} eq "Installed")
		{
			print "Package " . $response[1] . " already installed\n" unless $quiet;
		}
	}
	#If the user is trying unselect a package
	elsif($response[0] eq "unselect")
	{
		#If the user adds a -q flag, don't print out the verbose dialog
		my $quiet = 0;
		if($response[1] eq "-q")
		{
			$quiet = 1;
			#Move the next arguement over to make parsing the command line easy
			$response[1] = $response[2];
		}

		#Make sure the package exists
		if(defined $$allPackages{$response[1]} && $$allPackages{$response[1]}{__class} ne "core")
		{
			$$allPackages{$response[1]}{status} = "Unselected";
			$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$response[1],1,\@errors);
			
			#Check to see if anything depends on this
			print "Checking dependencies\n" unless $quiet;
			my $reqby;
			$reqby = SelectorUtils::getIsRequiredByList($reqby,$response[1]);
			delete $$reqby{""}; #Delete the empty key
			#If something depended on this package, unselect it
			foreach my $package (keys %{$reqby})
			{
				if ($package eq $response[1]) {next;}
				print "Package " . $package . " depends on " . $response[1] . "\n" unless $quiet;
				$$allPackages{$package}{status} = "Unselected";
				$success = OSCAR::Database::update_node_package_status(\%options,"oscar_server",$package,1,\@errors);
			}
		}
		elsif(!defined $$allPackages{$response[1]})
		{
			print "Package name " . $response[1] . " not recognized\n" unless $quiet;
		}
		elsif($$allPackages{$response[1]}{__class} eq "core")
		{
			print "Cannot unselect core packages\n" unless $quiet;
		}
	}
	#If the user is trying to list the packages again
	elsif($response[0] eq "list")
	{
		#The default action if the selected class does not exist is to print all of the packages
		if(!defined $response[1])
		{
			printPackages("all");
		}
		else
		{
			printPackages($response[1]);
		}
	}
	#If the user is trying to quit the program
	elsif($response[0] eq "quit" || $response[0] eq "exit")
	{
		#Everything should already have been taken care of so go ahead and move on
		exit;
	}
	#If the user wants to read in responses from a file
	elsif($response[0] eq "file")
	{
		#This will probably only work for files with one word names
		my $FILE = $response[1];
		open(FILE, $FILE);
		#Read the file just like it is normal input from the keyboard
		#The file is not required to have a quit command in it
		while(<FILE>)
		{
			chomp $_;
			processInput($_);
		}
	}
	#Default response is to print out the list of commands and their use
	else
	{
		print "select <packageName> - Select a package to be installed
	-q - Quiet mode:  Don't print out verbose dialog
unselect <packageName> - Unselect a package to prevent it from being installed
	-q - Quiet mode:  Don't print out verbose dialog
list <class> - Lists the packages and their installation status, class, and version number
file <filename> - Reads in commands from a file
help - Prints this message
quit/exit - Quits the selector\n";
	}
}
