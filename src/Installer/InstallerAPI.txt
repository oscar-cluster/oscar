                Structure and API of new OSCAR Installer
                ----------------------------------------

First Created : February 25, 2004
Last Updated  : April 27, 2004
Author        : Jason Brechin <brechin@ncsa.uiuc.edu>
Author        : Terry Fleury  <tfleury@ncsa.uiuc.edu>
Copyright (c) 2004 The Board of Trustees of the University of Illinois.
                   All rights reserved.

Directory Structure
-------------------

Summary: 

The main OSCAR Installer Perl code will reside in a directory named
"Installer" directly underneath the $OSCAR_HOME directory.  Within this
directory will be all of the Perl modules necessary to run the OSCAR
Installer.  The main Perl executable will be named Installer.pl.

Under the Installer directory will be directories for each Task and Tool
which can appear within the Installer workspace.  These directories must
be listed in the Installer.xml file (located in the main Installer
directory) to classify it as a Task (with a step number) or a Tool (without
a step number).  Only one Task can be displayed at a time, while any number
of Tools can be displayed at a time.

Details:

$OSCAR_HOME/Installer/
    Installer.xml - List of all Tasks and Tools (see below)
    Installer.pl - Main OSCAR Installer Perl application
    InstallerMainWindow.pm - QMainWindow containing pulldown menus, status
        bar, workspace, etc.
    InstallerWorkspace.pm - QWorkspace which is parent of all Tasks/Tools
    ... - Other files required for main Installer window

$OSCAR_HOME/Installer/<Tasks&Tools>/
$OSCAR_HOME/Installer/Opder/ - example of a Task directory
    GUI.xml - Configuration file for this Task/Tool
    OpderMain.pm - Main QObject / child of InstallerWorkspace (see below)
    ... - Other files required for Task/Tool window

    Note that with this directory scheme, Task/Tool files would normally have
    package names of "Directory::Filename" (e.g. "package Opder::OpderMain").
    However, the Installer does some clever manipulation of the @INC path, so
    you can simpy name your packages "Filename" (e.g. "package OpderMain").
    This simpifies development of Tasks/Tools to be run outside of the
    Installer window.

Format of Installer.xml File
----------------------------

Summary:

The Installer.xml file is located in the $OSCAR_HOME/Installer/ directory.
It contains a list of all Tasks/Tools available in the Installer.  These
Tasks/Tools reside in subdirectories under the $OSCAR_HOME/Installer/
directory.  The Task/Tool is listed in the XML file by its directory name.

Details:

<?xml version="1.0" encoding="ISO-8859-1"?>
<oscar>

<!--
  Notes:

  dirname = The name of Task/Tool subdirectory (under $OSCAR_HOME/Installer/).

  stepnum = The step number for the task - MUST be unique or the Installer
            will exit with an error condition.  Tasks must have a number.
            Tools must not.
-->
  <tasks>

    <task>
      <dirname>Opder</dirname>
      <stepnum>1</stepnum>
    </task>

    <task>
      <dirname>NodeMgmt</dirname>
      <stepnum>2</stepnum>
    </task>

  </tasks>

  <tools>

    <tool>
      <name>NodeGroups</name>
    </tool>

    <tool>
      <name>FileList</name>
    </tool>

  </tools>

</oscar>


Format of GUI.xml Files
-----------------------

Summary:

Each Task/Tool directory SHOULD contain a GUI.xml file.  (If the file is not
present, then a bunch of defaults will be assumed, as described below.)
This XML file describes the Task/Tool in terms of its main object class (which
is called by the InstallerWorkspace), a 'full name' which will appear in the
pulldown lists of Tasks/Tools, and oda commands/tests which must run and
succeed in order for the Task to be allowed to execute (used only for Tasks
since Tools can run at any time).  If a Task can't find all of the information
it needs in the oda database, it should deal with it gracefully.  However,
if any of the oda commands/tests fails, then that Task is not allowed to run.

Details:

<?xml version="1.0" encoding="ISO-8859-1"?>
<oscar>

<!--
  Notes:

  classname = The name of the Perl module file containing the PerlQt NEW
              function.  This will be used in creating a new instance of this
              object.  Note that this name can be different from the directory
              containing the Task/Tool.  For example, the Opder may reside in
              the directory $OSCAR_HOME/Installer/Opder, but the file
              containing the PerlQt NEW subroutine may be named OpderMain.pm.
              To create a new instance of the Opder, the InstallerWorkspace
              would call something like this:

              # Opder is directory name, so use it for lib path:
              use lib "$ENV{OSCAR_HOME}/Installer/Opder";
              # OpderMain is object name, so use it for instance creation:
              my $obj = Opder::OpderMain;
              # As with all PerlQt objects, NEW is called implicitly.

              If the 'classname' field is absent, the directory name of the
              Task/Tool is assumed.  So if no 'classname' field for the Opder
              directory, then the main object file defaults to Opder.pm.

  fullname =  The "pretty" name for the Task/Tool which will appear in 
              the pulldown menus.  This shouldn't be TOO long since it will
              appear in a pulldown menu.  If the 'fullname' field is absent,
              then it defaults to the 'classname' field.
-->

  <classname>OpderMain</classname>
  <fullname>OSCAR Package Downloader</fullname>

  <oda>

  <!--
    Notes:
    
    command = Valid only for Tasks.  This is an arbitrary 'oda' command
              which is executed prior to the opening of a particular
              Task's window.  The results of the oda command can be passed to
              the 'test' (listed below) for further processing.  Let this
              field be stored in the perl variable $command.  Then, the actual
              code executed by the Installer is as follows:

              my $odasuccess = undef;
              my @odaresult = undef;
              my @odaerror = undef;
              $odasuccess = OSCAR::Database::database_execute_command(
                            $command,\@odaresult,\@odaerror);

              In effect, the $odasuccess varilable holds 0 or 1 for the return
              value of oda's execute_command.  This value isn't necessarily
              too useful since it is set to 0 only upon a major database
              problem.  The @odaresult array is the actual data returned by
              the given oda command (if anything).  The @odaerror array is an
              array of error strings generated by oda, and may or may not be
              useful in figuring out what went wrong.

              The $odasuccess, @odaresult, and @odaerror values are used by
              the 'test' and 'error' fields below.  If the 'command' field is
              blank, then $odasuccess, @odaresult, and @odaerror are all
              undefined, but the 'test' code is still executed.  It is an
              error to have both the 'command' field and the 'test' field be
              empty.

    test    = Arbitrary Perl code which should return 0 or 1.  The values
              $command, $odasuccess, @odaresult, and @odaerror generated by
              the oda 'command' above are available to your Perl test code.
              Your code is executed by the Installer as follows:

              my $testsuccess = (eval ( $test ) );
              
              Your test code should simply return 0 or 1 for failure or
              success.  If the 'test' field is blank, then the test code
              defaults to 'return $odasuccess'.  This may not be what you
              really want since $odasuccess is 0 only upon a major database
              problem.  You may want to use 'return $odaresult[0]' instead.

    error   = Arbitrary Perl code which should return a string describing the
              error condition if the 'test' above returns 0.  The variables
              $command, $odasuccess, @odaresult, @odaerror, $test, and 
              $testsuccess generated by the 'command' and 'test' above are all
              available to your Perl code.  Upon failure of the 'test', your
              error code is executed by the Installer as follows:

              return (eval ( $error ) );
              
              Your error code should simply return a string.  This string is
              displayed in the "Details" section of the error message dialog,
              so you can make it as simple or as complex as you like.  If the
              'error' field is blank, then the default is to print out all
              available information including the oda 'command' and its
              associated variables ($odasuccess, @odaresult, @odaerror), and
              the 'test' and its return value $testsuccess.  

              If you want to include the default error string in your custom
              error string, call the subroutine 'getDefaultErrorString()'
              which returns a string.  You can concatenate this string with
              your own error string and return the resulting string.

    In summary, the following variables are generated by and available to
    the <oda>, <command>, and <test> fields above:

        $command    = The <command> field, which is passed as the first
                      argument to database_execute_command(...).
        $odasuccess = The return value from database_execute_command(...).
        @odaresult  = The result array which is set as the second 
                      argument to database_execute_command(...).  This array
                      usually contains the 'useful' information output by
                      the oda command.
        @odaerror   = The error string array which is set as the third
                      argument to database_execute_command(...) upon failure.
        $test       = The <test> field, which is passed to an 'eval' statement
                      and should return 0 or 1.
        $testsuccess= The result of the (eval ( $test )) command.

    One important note: Since these fields are stored in an XML file, you MUST
    use XML/HTML-style notations for special symbols.  For example, use '&lt;'
    for '<' and '&gt;' for '>'.  Otherwise, your XML file will not parse
    correctly.
  -->

    <command>oscar_version</command>
    <test>($odaresult[0] &gt;= 2.3) and ($odaresult[0] &lt;= 3.1)
    </test>
    <error>"OSCAR version is $odaresult[0]. " . 
           "We need OSCAR version between 2.3 and 3.1 inclusive."
    </error>

  </oda>

  <oda>
    <command>read_records packages_provides package=lam type name</command>
    <!-- No test means that the above oda command must return success, which
         is probaby not what you want, since all that means is that the oda
         database is working and the read_records command didn't die. -->
    <error>return ("Major problem with oda!!! " . getDefaultErrorString());
  </oda>

</oscar>


Program Specifics for Tasks and Tools
-------------------------------------

(1) To exit your application, do not use Qt::Application::exit().  Instead, do
    this->close(1) in the MainWindow widget.  When you do a close() in the
    top-level widget, the application will exit.  Passing '1' as an argument
    to close(1) attempts to destroy the widget as well.

(2) In your MainWindow widget, define the closeEvent subroutine so as to
    override the default closeEvent handler.  The code should look like this:

    sub closeEvent
    {
    #########################################################################
    #  Subroutine: closeEvent                                               #
    #  Parameter : A pointer to the QCloseEvent generated.                  #
    #  Returns   : Nothing                                                  #
    #########################################################################
      # Send a signal to the parent workspace letting it know we are closing.
      emit taskToolClosing("Opder");
      SUPER->closeEvent(@_);   # Call the parent's closeEvent
    }

    The parameter you pass to 'emit taskToolClosing(...)' is the name of the
    directory containing your Task/Tool.  You will also need to define
    a Qt::signal for taskToolClosing which should look like this:

    use Qt::signals taskToolClosing => ['char*'];

(3) When you want to use images (e.g. '.png' files) in your Task/Tool, you
    should put them in the $ENV{OSCAR_HOME}/Installer/images/ subdirectory and
    make sure they have the '.png' extension.  In your Makefile.am, you should
    add a rule to the 'all-local:' target to create a symbolic link to this
    images directory.  For example:

    all-local:	$(COMPILEDTARGET)
    		ln -sf ../Installer/images; \
		cd ../Installer; ln -sf ../NodeMgmt

    The first 'ln -sf' creates a symbolic link from an 'images' directory in
    your Task/Tool subdirectory.  You will probably need this symbolic link if
    you design your Task/Tool in Qt-Designer since Qt-Designer expects all
    images to reside in a subdirectory named 'images'.  The second 'ln -sf'
    creates a symbolic link within the Installer directory to your Task/Tool
    directory.  This way, you can put your Task/Tool at the same directory
    level as the Installer for development, but still run the Installer as if
    you had installed the compiled source code.

    Then in the .ui.h file of the Qt-Designer widget that includes images (on
    any buttons, for example), you must add the following line in the
    "Includes (in Declaration)" section:

    "use lib "../Installer"; use InstallerImages;"

    If you do any loading of images yourself, you MUST ALSO add 
    "use InstallerUtils;" to the above line.  This is because Perl-Qt-3.006
    and Perl-Qt-3.008 (and above) have different methods for loading in
    pixmaps (images).  A utility subroutine named 'getPixmap($imageName)' is
    available in InstallerUtils.pm to handle this issue.  Anytime you need to
    load a pixmap, use 'InstallerUtils::getPixmap(...)'.


Qt SLOTS and SIGNALS Implemented by InstallerWorkspace and Its Children
-----------------------------------------------------------------------

Summary:

In order to allow for communication between the InstallerWorkspace and its
children, there are several SIGNALS and SLOTS that need to be implemented in
both the workspace and its children.  

SIGNALS emitted by InstallerWorkspace
-------------------------------------

signalButtonShown(char* childname, char* buttonname, bool shown)

    Tasks must have three buttons at the bottom for navigation among the
    various steps: Back, Close, and Next.  The first step doesn't need a Back
    button and the last step doesn't need a Next button.  However, since each
    Task should have to care where it appears in the execution path, we need a
    way to have the InstallerWorkspace tell a Task to hide/show its buttons.
    When the InstallerWorkspace wants one of its child Tasks to hide/show
    either the Back or Next button, it emits this signal with the following
    three arguments:
      (1) the name of the child (actually the name of the Task directory),
      (2) the name of the button, either "Back" or "Next", and
      (3) 0 for hidden, 1 for shown.
    This signal is emitted by the InstallerWorkspace to hide the Back
    button for the first Task and the Next button for the final Task.

    In your Task, you might connect the signal to a slot as follows:

    # If there is a parent of this Task, then we are probably running
    # it in the InstallerWorkspace.  Need to catch some signals.
    if (parent())
      {
        Qt::Object::connect(parent(),
                            SIGNAL 'signalButtonShown(char*,char*,bool)',
                            SLOT   'setButtonShown(char*,char*,bool)');
      }

    sub setButtonShown
    {
    #########################################################################
    #  Subroutine: setButtonShown                                           #
    #  Parameters: (1) The directory name of the target Task for the signal #
    #              (2) The name of the button to show/hide ("Back"/"Next")  #
    #              (3) 1 = Show / 0 = Hide                                  #
    #  Returns   : Nothing                                                  #
    #  This subroutine (SLOT) is called to show/hide the Back/Next button,  #
    #  usually when the parent InstallerWorkspace says to.                  #
    #########################################################################
      my ($childname,$buttonname,$shown) = @_;
      
      # Ignore Hide/Show requests to other Tasks
      return if ($childname ne "Opder");

      if ($buttonname =~ /Back/i)
        {
          ($shown) ? backButton->show() : backButton->hide();
        }
      elsif ($buttonname =~ /Next/i)
        {
          ($shown) ? nextButton->show() : nextButton->hide();
        }
    }


odaWasUpdated(char* childname);

    When a Task/Tool writes information to the oda database, it should tell
    the other Tasks/Tools that the oda database has been updated so that they
    can reread the database and update their GUIs as appropriate.  To do so,
    the InstallerWorkspace emits the "odaWasUpdated(childname)" SIGNAL, where
    the 'childname' is the name of the directory of the Task/Tool that wrote
    to the database.  Each Task/Tool needs to catch this SIGNAL so they can
    have the option of rereading the database and updating their interfaces as
    appropriate.

    The argument to the 'odaWasUpdated' SIGNAL is the directory name of the
    Task/Tool that updated the oda database.  This is so that Task/Tool that
    updated the database can ignore the SIGNAL and not update itself again.

    To catch the SIGNAL in your Task/Tool, you might connect the signal to a
    slot as follows:

    # If there is a parent of this Task/Tool, then we are probably running
    # it in the InstallerWorkspace.  Need to catch some signals.
    if (parent())
      {
        Qt::Object::connect(parent(),
                            SIGNAL 'odaWasUpdated(char*)',
                            SLOT   'reReadOda(char*)');
      }

    sub reReadOda
    {
    #########################################################################
    #  Subroutine: reReadOda                                                #
    #  Parameter : The directory name of the Task/Tool that updated oda     #
    #  Returns   : Nothing                                                  #
    #  This subroutine (SLOT) is called the InstallerWorkspace receives     #
    #  notice that another Task/Tool updated the oda database.              #
    #########################################################################
      my ($childname) = @_;
      
      # Ignore the signal if we were the one that updated oda
      return if ($childname ne "Opder");

      # Reread the oda database and update the GUI as necessary
      # ...
    }


SIGNALS emitted by Tasks/Tools
------------------------------

parent()->odaWasUpdated(char* childname)

    This is related to the SIGNAL/SLOT connection we just created above.
    This isn't really a SIGNAL implemented in the Task/Tool, but it is a
    signal that should be emitted when the Task/Tool updates the oda database.
    Here, "parent()" returns a pointer to the InstallerWorkspace, and since
    that is where the 'odaWasUpdated' SIGNAL is implemented, we end up
    notifying other Tasks/Tools of changes to the oda database.  So, put this
    statement after every write to oda performed by your Task/Tool.

taskToolClosing(char* childname)

    When a Task/Tool closes/exits, it needs to let the InstallerWorkspace know
    so the workspace can update the list of open windows.  Do to this, the
    MainWindow of each Task/Tool needs to emit the
    'taskToolClosing(childname)' SIGNAL when the main window closes.  To do
    this, you first define the SIGNAL as follows:

    use Qt::signals taskToolClosing => ['char*'];

    Next, you must override the main window's closeEvent as follows:

    sub closeEvent
    {
    #########################################################################
    #  Subroutine: closeEvent                                               #
    #  Parameter : A pointer to the QCloseEvent generated.                  #
    #  Returns   : Nothing                                                  #
    #########################################################################
      # Send a signal to the parent workspace letting it know we are closing.
      emit taskToolClosing("Opder");
      SUPER->closeEvent(@_);   # Call the parent's closeEvent
    }

    The parameter to the taskToolClosing SIGNAL is the name of the Task/Tool
    directory.

backButtonWasClicked(char* childname)
nextButtonWasClicked(char* childname)

    When the user clicks on a Task's "Back" or "Next" button, it needs to emit
    a SIGNAL to the InstallerWorkspace to have it go to the previous or next
    step in the installation sequence.  However, since a Task can have
    prerequisites that must be fulfilled before it is allowed to run, we don't
    necessarily go to the previous/next step.  So when the InstallerWorkspace
    gets notice of a Task's Back/Next button being pressed, it first checks to
    see if the prerequisites for the previous/next Task are fulfilled, and if
    so, it closes the current Task and opens the previous/next one.

    So first you must define these two SIGNALS as follows:

    use Qt::signals backButtonWasClicked => ['char*'],
                    nextButtonWasClicked => ['char*'];

    Then, you must connect the 'clicked' SIGNALs for the Back/Next buttons to
    appropriate SLOTS.  For example:

    Qt::Object::connect(backButton, SIGNAL 'clicked()', 
                                    SLOT   'backButton_clicked(char*)');
    Qt::Object::connect(nextButton, SIGNAL 'clicked()', 
                                    SLOT   'nextButton_clicked(char*)');

    And the implementations of these SLOTS might look like this:

    sub backButton_clicked
    {
    #########################################################################
    #  Subroutine: backButton_clicked                                       #
    #  Parameters: None                                                     #
    #  Returns   : Nothing                                                  #
    #  When the backButton is clicked, inform the InstallerWorkspace.       #
    #########################################################################
      emit backButtonWasClicked("Opder");
    }

    sub nextButton_clicked
    {
    #########################################################################
    #  Subroutine: nextButton_clicked                                       #
    #  Parameters: None                                                     #
    #  Returns   : Nothing                                                  #
    #  When the nextButton is clicked, inform the InstallerWorkspace.       #
    #########################################################################
      emit nextButtonWasClicked("Opder");
    }

    Note again that the argument to the backButtonWasClicked/
    nextButtonWasClicked SINGALs is the name of the Task's directory.


CODE CHANGES IN SUMMARY 
-----------------------

The following modifications need to be made to your Task/Tool to allow it to
run within the Installer Workspace.

    # At the top of your Main Window package:
    use Qt::signals
        taskToolClosing => ['char*'],
        backButtonWasClicked => ['char*'],
        nextButtonWasClicked => ['char*'];
    use Qt::slots
        setButtonShown => ['char*','char*','bool'],
        reReadOda => ['char*'],
        backButton_clicked => [],
        nextButton_clicked => [],
        closeEvent => ['QCloseEvent'];


    sub init
    {
      # If there is a parent of this MainWindow, then we are probably running
      # it in the InstallerWorkspace.  Need to connect some signals/slots.
      if (parent())
        {
          Qt::Object::connect(parent(),
                              SIGNAL 'signalButtonShown(char*,char*,bool)',
                              SLOT   'setButtonShown(char*,char*,bool)');
          Qt::Object::connect(parent(),
                              SIGNAL 'odaWasUpdated(char*)',
                              SLOT   'reReadOda(char*)');

          # For Tasks, do stuff when we click the Back or Next Buttons
          Qt::Object::connect(backButton, 
                              SIGNAL 'clicked()', 
                              SLOT   'backButton_clicked(char*)');
          Qt::Object::connect(nextButton, 
                              SIGNAL 'clicked()", 
                              SLOT   'nextButton_clicked(char*)');
        }
      else
        { # For Tasks, hide the Back/Next button if not running inside
          # the InstallerWorkspace window.
          backButton->hide();
          nextButton->hide();
        }
    }

    sub setButtonShown
    {
    #########################################################################
    #  Subroutine: setButtonShown                                           #
    #  Parameters: (1) The directory name of the target Task for the signal #
    #              (2) The name of the button to show/hide ("Back"/"Next")  #
    #              (3) 1 = Show / 0 = Hide                                  #
    #  Returns   : Nothing                                                  #
    #  This subroutine (SLOT) is called to show/hide the Back/Next button,  #
    #  usually when the parent InstallerWorkspace says to.                  #
    #########################################################################
      my ($childname,$buttonname,$shown) = @_;
      
      # Ignore Hide/Show requests to other Tasks
      return if ($childname ne "Opder");

      if ($buttonname =~ /Back/i)
        {
          ($shown) ? backButton->show() : backButton->hide();
        }
      elsif ($buttonname =~ /Next/i)
        {
          ($shown) ? nextButton->show() : nextButton->hide();
        }
    }

    sub backButton_clicked
    {
    #########################################################################
    #  Subroutine: backButton_clicked                                       #
    #  Parameters: None                                                     #
    #  Returns   : Nothing                                                  #
    #  When the backButton is clicked, inform the InstallerWorkspace.       #
    #########################################################################
      emit backButtonWasClicked("Opder");
    }

    sub nextButton_clicked
    {
    #########################################################################
    #  Subroutine: nextButton_clicked                                       #
    #  Parameters: None                                                     #
    #  Returns   : Nothing                                                  #
    #  When the nextButton is clicked, inform the InstallerWorkspace.       #
    #########################################################################
      emit nextButtonWasClicked("Opder");
    }

    sub reReadOda
    {
    #########################################################################
    #  Subroutine: reReadOda                                                #
    #  Parameter : The directory name of the Task/Tool that updated oda     #
    #  Returns   : Nothing                                                  #
    #  This subroutine (SLOT) is called the InstallerWorkspace receives     #
    #  notice that another Task/Tool updated the oda database.              #
    #########################################################################
      my ($childname) = @_;
      
      # Ignore the signal if we were the one that updated oda
      return if ($childname ne "Opder");

      # Reread the oda database and update the GUI as necessary
      # ...
    }

    sub closeEvent
    {
    #########################################################################
    #  Subroutine: closeEvent                                               #
    #  Parameter : A pointer to the QCloseEvent generated.                  #
    #  Returns   : Nothing                                                  #
    #########################################################################
      # Send a signal to the parent workspace letting it know we are closing.
      emit taskToolClosing("Opder");
      SUPER->closeEvent(@_);   # Call the parent's closeEvent
    }


