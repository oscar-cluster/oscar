#!/bin/sh
#
# Copyright (c) 2002 The Trustees of Indiana University.  
#                    All rights reserved.
# 
# This file is part of the OSCAR software package.  For license
# information, see the COPYING file in the top level directory of the
# OSCAR source distribution.

# $Id: test_cluster,v 1.24 2002/10/30 12:15:35 jsquyres Exp $
#
# test_cluster - script to test MPI, PVM, & PBS
# Authors: Jason Brechin
#          Jeremy Enos

#test to make sure root is not running this script
if [ `id -un` = root ] ; then 
  echo "This test script MUST be run from a user account."
  echo "Exiting..."
  exit 1
fi

function waitexit
{
        # Function to wait for a key press before
        # exiting. Used by guis.
        if [ $wizard_launch ] && [ $wizard_launch = yes ]; then
          echo "...Hit a key to exit..."
          read -n 1 -s  key
        fi
        exit 0
}


# Initialize environment
qsub='/opt/pbs/bin/qsub'
qstat='/opt/pbs/bin/qstat'
homedir=~/OSCAR_test
cd $homedir

# Check usage (since this can be run seperately)
if [ $# -eq 0 ]; then 
  # Get cluster info from user
  echo -n "Enter the number of client nodes: "
  read clients
  echo -n "Enter the number of processors per client: "
  read ppn
elif [ $# -ne 2 ]; then
  echo "usage: $0 [<num clients> <num procs/client>]"
  exit 1
else
  clients=$1
  ppn=$2
fi

numprocs=`/usr/bin/expr $clients \* $ppn`

function calc_timeout {
if [ ! $min_timeout ]; then min_timeout=30; fi
if [ ! $scaling_factor ]; then scaling_factor=3; fi
timeout=`echo "$numprocs $scaling_factor * p" | /usr/bin/dc | cut -d . -f 1`
if [ $timeout -lt 30 ] || [ $timeout -lt $min_timeout ]; then
  if [ $min_timeout -gt 30 ]; then
    timeout=$min_timeout;
  else
    timeout=30;
  fi
fi
}


# Initialize some functions (should work for RedHat and Mandrake)
source /etc/rc.d/init.d/functions

echo -e "\t\t\tUSER TESTS"
echo -e "\t\t\t----------"


#			DEFAULT PBS QUEUE
#			-----------------

echo -n "Checking PBS default queue definition:"
if [ `/opt/pbs/bin/qmgr -c "l s" | grep -c 'default_queue'` -eq 1 ]; then
  echo_success
  echo
else
  echo_failure
  echo
fi


#			SSH TESTS
#			---------
# Uses the server and free nodes starting from the end of the list (as PBS
# uses them).

node1=`/opt/pbs/bin/pbsnodes -a | /bin/grep -B1 'state = free' | /bin/egrep '^\w+' | /usr/bin/tail -1`

if [ `ping -c 1 $node1 2>/dev/null | grep -c avg` -eq 0 ]; then
  echo "No nodes free and pingable"
  waitexit
fi

echo -n "server -> node SSH:"
if [ "x`ssh $node1 hostname 2> /dev/null`" = "x$node1" ]; then
  echo_success
  echo
else
  echo_failure
  echo
  waitexit
fi

echo -n "node -> server SSH:"
server=`hostname`
testval=`ssh $node1 ssh $server hostname 2> /dev/null`
#echo "Testval is $testval"
if [ "x$testval" = "x$server" ]; then
  echo_success
  echo
else
  echo_failure
  echo
  waitexit
fi


if [ $clients -gt 1 ]; then # user specified more than one client, so
                            # we can do node -> node tests
  node2=`/opt/pbs/bin/pbsnodes -a | /bin/grep -B1 'state = free' | /bin/egrep '^\w+' | /usr/bin/tail -2 | /usr/bin/head -1`

  echo -n "node -> node SSH:"
  if [ "x`ssh $node1 ssh $node2 hostname 2> /dev/null`" = "x$node2" ]; then
    echo_success
    echo
  else
    echo_failure
    echo
    waitexit
  fi
fi 

#			PBSNODES FREE ROUTINE
#			---------------------
# Shows only failure to find free nodes
check_free_nodes () {
free=`/opt/pbs/bin/pbsnodes -a | grep -c 'state = free'`
if [ $free -eq $clients ] || [ $free -gt $clients ]; then    # at least $clients free nodes
echo -n ""
else
echo -n "Checking for $clients free nodes:"
  echo_failure
  echo
  echo Not enough free nodes.  Tests incomplete.
  waitexit
fi
}

#			PBS TEST ROUTINE
#			----------------
# Generic routine to run any test through PBS depending on environment
pbs_test_routine () {
sleep 1
calc_timeout
check_free_nodes
echo -n $pbs_test_type
echo -n ":    "
cd $homedir/$test_dir
if [ -f $output_file.out ]; then /bin/rm -f $output_file.out; fi
if [ -f $output_file.err ]; then /bin/rm -f $output_file.err; fi
job=`$qsub -l nodes=$clients:ppn=$ppn $pbs_script`
# Check that job submitted properly
if [ -z $job ]
then
  echo_failure
  echo
else
  timeleft=$timeout
  job_state=incomplete
  while [ $job_state = incomplete ]; do 
    # Displays remaining seconds
    max_digits=10
    time_left_digits=`echo $timeleft | wc -c`
    space_count=`expr $max_digits - $time_left_digits`
    while [ $space_count -gt 0 ]; do
      echo -n " "
      space_count=`expr $space_count - 1`
    done
    echo -n " $timeleft"
    for i in `seq 1 $max_digits`; do
      echo -n -e "\b"
    done
    sleep 1
  # Tests for success or timeout
    if [ -f $output_file.out ] ; then
      grep "$grep_string" $output_file.out > /dev/null
      string_test=$?
      if [ $string_test = 0 ] ; then
        job_state=success
        for i in `seq 1 $max_digits`; do
          echo -n -e " "
        done
        echo_success
	echo
      else
 	timeleft=0
      fi
    fi
    if [ $timeleft -eq 0 ]; then # more than timeout
      for i in `seq 1 $max_digits`; do
        echo -n -e " "
      done
      echo_failure
      echo
      job_state=fail
      if [ `/opt/pbs/bin/qstat |grep -c $job` -eq 1 ]; then
      /opt/pbs/bin/qdel $job
      sleep 1 # Allows nodes to free up again
      fi
      if [ $exit_on_fail = yes ]; then waitexit ; fi
    fi 
    timeleft=`expr $timeleft - 1`
  done
fi
unset min_timeout
unset scaling_factor
cd ..
}

  
#			PBS SHELL TEST
#			--------------

pbs_test_type="Simple PBS shell job"
test_dir=shell
pbs_script=pbs_script.shell
output_file=shelltest
grep_string=Hello
exit_on_fail=yes
scaling_factor=3
pbs_test_routine

#
# Setup MPI -- save any user default
#

user_default_mpi="`switcher mpi --show --user | grep default | cut -d= -f2`"

#			MPICH TEST
#			----------

mpi="`switcher mpi --list | grep mpich | head -1`"
if test "$mpi" != ""; then 
    switcher mpi --add-attr default $mpi --force --silent
    pbs_test_type="Simple PBS MPICH job"
    test_dir=mpi
    pbs_script=pbs_script.mpich
    output_file=mpichtest
    grep_string="test completed successfully"
    exit_on_fail=no
    min_timeout=60
    scaling_factor=3.1
    pbs_test_routine
else
    echo "Skipping MPICH test (doesn't seem to be installed)"
fi


#			LAM TEST
#			--------

mpi="`switcher mpi --list | grep lam | head -1`"
if test "$mpi" != ""; then 
    switcher mpi --add-attr default $mpi --force --silent
    pbs_test_type="Simple PBS LAM job"
    test_dir=mpi
    pbs_script=pbs_script.lam
    output_file=lamtest
    grep_string="test completed successfully"
    exit_on_fail=no
    min_timeout=60
    scaling_factor=10
    pbs_test_routine
else
    echo "Skipping LAM test (doesn't seem to be installed)"
fi



#			PVM TEST
#			--------

pbs_test_type="Simple PBS PVM job"
test_dir=pvm
pbs_script=pbs_script.pvm
output_file=pvmtest
grep_string=SUCCESSFUL
exit_on_fail=no
pbs_test_routine

#			HDF5 TEST
#			---------

mpi="`switcher mpi --list | grep mpich | head -1`"
if test "$mpi" != ""; then 
    switcher mpi --add-attr default $mpi --force --silent
    pbs_test_type="Simple PBS HDF5 job"
    test_dir=hdf5
    pbs_script=pbs_script.hdf5
    output_file=hdf5test
    grep_string="HDF5 SUCCESS"
    exit_on_fail=no
    min_timeout=30
    scaling_factor=10
# Skip this test for the moment -- hdf5 is currently non-operational.
    pbs_test_routine
else
    echo "Skipping HDF5 test (doesn't seem to be installed)"
fi

#
# If there was a user-default MPI, restore it
#

switcher mpi --rm-attr default --force --silent
if test "$user_default_mpi" != ""; then
    switcher mpi --add-attr default $user_default_mpi --force --silent
fi



# Done
waitexit

