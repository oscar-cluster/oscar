#!/usr/bin/env perl
#
# Copyright (c) Erich Focht <efocht@hpce.nec.com>
#               All rights reserved
#
# This file is part of the OSCAR software package.  For license
# information, see the COPYING file in the top level directory of the
# OSCAR source distribution.
#
# $Id$

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::OCA::OS_Detect;
use OSCAR::PackagePath;
use Data::Dumper;
use Carp;


my ($dumb, $smart, $verbose, $path);
GetOptions(
           "dumb"      => \$dumb,
           "smart"     => \$smart,
           "verbose"   => \$verbose,
           ) || &usage(1);
# check paths
&usage(1) if (!scalar(@ARGV));

my $ohome = $ENV{OSCAR_HOME};
my @prereqs;
for my $p (@ARGV) {
    if (! -d "$ohome/$p" || ! -f "$ohome/$p/prereq.cfg") {
	print "Error: $p is not a directory or doesn't contain a prereq.cfg file!\n";
	usage(1);
    } else {
	push @prereqs, "$ohome/$p";
    }
}

# need one of the two
&usage(1) if (!$smart && !$dumb);

#
# Own distro detection
#
my $os = &OSCAR::PackagePath::distro_detect_or_die();
my $distro    = $os->{distro};
my $distrover = $os->{distro_version};
my $arch      = $os->{arch};

# locate destination path for prereq package files and repository url
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_path();
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url();
my $suffix = &OSCAR::PackagePath::pkg_extension();
my $separator = &OSCAR::PackagePath::pkg_separator();

vprint("OSCAR pkg path: $oscar_pkg_pool\n");
vprint("Distro pkg path: $distro_pkg_pool\n");
vprint("Prereq paths: ".join(",",@prereqs))."\n";

#
# copy files to repository with generic-setup
#
my $gs = "$ohome/scripts/generic-setup";
die "ERROR: $gs is not executable!" if (! -x $gs);
$gs .= " --verbose" if ($verbose);

for my $p (@prereqs) {
    my $cmd = "env OSCAR_PACKAGE_HOME=$p $gs --pool $oscar_pkg_pool";
    vprint("Executing: $cmd\n");
    !system($cmd) or
	die "\nERROR: prereq install for $p failed!\n";
}

#
# Is this "smart mode"? Then load PackMan and regenerate the metadata cache
#
my $pm;
if ($smart) {
    require OSCAR::PackMan;
    require OSCAR::PackageSmart;
    $pm = OSCAR::PackageSmart::prepare_pools($verbose,$oscar_pkg_pool,$distro_pkg_pool);
    if (!$pm) {
	croak "\nERROR: Could not create PackMan instance!\n";
    }
}

# now go with the processing

# collect all config lines and build list of packages to be installed/removed
my (@removes, @installs);
for my $path (@prereqs) {
    # read in prereq.cfg file
    my $ref = &get_config($path, $distro, $distrover, $arch);
    if (!$ref) {
	print "Couldn't match any config block in $path/prereq.cfg\n";
	next;
    }
    for my $line (@{$ref}) {
	$line =~ s/^\s*//g;
	next if ($line =~ /^\#/ && $line =~ /^$/);
	my $remove = ($line =~ /^!/);
	if ($remove) {
	    $line =~ s/^!//g;
	}
	my ($pkg,$dummy) = split(/\s+/,$line);
	if ($remove) {
	    push @removes, $pkg;
	} else {
	    push @installs, $pkg;
	}
    }
}

vprint("Following packages will be removed:\n\t".
       join("\n\t",@removes) . "\n");
vprint("Following packages will be installed:\n\t".
       join("\n\t",@installs) . "\n");

if ($dumb) {
    if ($suffix eq ".rpm") {
	# do the removes before the installs
	handle_dumb_rpms(1,@removes);
	handle_dumb_rpms(0,@installs);
    } elsif ($suffix eq ".deb") {
	# do the removes before the installs
	handle_dumb_debs(1,@removes);
	handle_dumb_debs(0,@installs);
    } else {
	croak "Support for dumb ".$suffix." install is not implemented.\n";
    }
} else {
    # do the removes before the installs
    handle_smart_pkgs($path,1,@removes);
    handle_smart_pkgs($path,0,@installs);
}

exit 0;

sub handle_smart_pkgs {
    my ($path, $remove, @pkgs) = @_;
    my ($err, @out);

    return if (!scalar(@pkgs));
    if ($remove) {
	print("\tsmartly removing: ".join(",",@pkgs)."\n");
	($err, @out) = $pm->smart_remove(@pkgs);
    } else {
	print("\tsmartly installing: ".join(",",@pkgs)."\n");
	($err, @out) = $pm->smart_install(@pkgs);
    }
    if (!$err) {
	print "Error occured for prereq $path\n";
	print join("\n",@out);
	exit 1;
    }
    if (!$err) {
	print "Error occured for prereq $path\n";
	print join("\n",@out);
	exit 1;
    }

}

#
# Simple implementation for dumb rpm handling
#
sub handle_dumb_rpms {
    my ($remove, @pkgs) = @_;
    my $cmd;
    return if (!scalar(@pkgs));
    for my $pkg (@pkgs) {
	# make sure we deal with package names, not file names
	my $pkgname = $pkg; $pkgname =~ s/\.rpm$//;
	if ($remove) {
	    $cmd = "rpm -q $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (!system($cmd)) {
		# remove all instances of package
		$cmd = "rpm -ev --all --nodeps $pkgname";
		vprint("Executing: $cmd\n");
		!system($cmd) or print "Warning: removal failed: $!\n";
	    } else {
		vprint("Package $pkgname not installed.\n");
	    }
	} else {
	    # already installed?
	    $cmd = "rpm -q $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (system($cmd)) {
		# not installed, so do it now
		my $pkgpath = locate_pkg($pkg);
		if ($pkgpath) {
		    $cmd = "rpm -Uhv $pkgpath";
		    vprint("Executing: $cmd\n");
		    !system($cmd) or croak "install failed: $!\n";
		} else {
		    print "WARNING: Could not locate package $pkg\n";
		}
	    }
	}
    }
}

#
# Simple implementation for dumb debian package handling
# hacked by Erich Focht out of the dumb_rpms code, without much
# knowledge of dpkg
#
sub handle_dumb_debs {
    my ($remove, @pkgs) = @_;
    my $cmd;
    return if (!scalar(@pkgs));
    for my $pkg (@pkgs) {
	# make sure we deal with package names, not file names
	my $pkgname = $pkg; $pkgname =~ s/\.deb$//;
	if ($remove) {
	    $cmd = "dpkg --status $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (!system($cmd)) {
		# remove all instances of package
		$cmd = "dpkg --purge --force-depends $pkgname";
		vprint("Executing: $cmd\n");
		!system($cmd) or print "Warning: removal failed: $!\n";
	    } else {
		vprint("Package $pkgname not installed.\n");
	    }
	} else {
	    # already installed?
	    $cmd = "dpkg --status $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (system($cmd)) {
		# not installed, so do it now
		my $pkgpath = locate_pkg($pkg);
		if ($pkgpath) {
		    $cmd = "dpkg --install $pkgpath";
		    vprint("Executing: $cmd\n");
		    !system($cmd) or croak "install failed: $!\n";
		} else {
		    print "WARNING: Could not locate package $pkg\n";
		}
	    }
	}
    }
}

#
# try to locate a package file in the repositories
#
sub locate_pkg {
    my ($pkg) = @_;
    my $march = $arch;
    $march = "i?86" if ($arch eq "i386");
    my @pkgs;
    if ($pkg =~ /$suffix$/) {
	my @tmp = glob("$oscar_pkg_pool/$pkg $distro_pkg_pool/$pkg");
	for my $f (@tmp) {
	    push @pkgs, $f if (-f $f);
	}
    } else {
	@pkgs = glob("$oscar_pkg_pool/$pkg$separator"."[0-9]*{$march,noarch}$suffix ".
                     "$distro_pkg_pool/$pkg$separator"."[0-9]*{$march,noarch}$suffix");
    }
    vprint("locate_pkg glob result: ".join(",",@pkgs)."\n");
    # simply return the last one
    # EF: actually we need some version comparison here
    if (scalar @pkgs) {
	return (reverse(sort(@pkgs)))[0];
    }
    return undef;
}

sub vprint {
    print @_ if ($verbose);
}


############################################################################
# Prerequisites config file. This is called prereq.cfg and should be located
# in the top directory of the otherwise generic-setup compatible prerequisites
# directory. Because prereqs are installed long before OSCAR is able to parse
# config.xml files, prereq.cfg is much simpler. The format is:
#
# [distro:version:architecture]
# package_name_or_rpm_file
# ...
# !package_name
# ...
# [distro2:version:architecture]
# ...
#
# The distro name, version or arch info can contain a "*". This matches
# like a .* regexp.
# Examples:
# [redhat-el*:3:*] matches all rhel3 architectures.
# [fedora:*:*]     matches all fedora core distros on all architectures
# [mandr*:*:*]     matches both mandrake and mandriva
# [*:*:*]          matches everything.
#
# Attention! The real distro names are used here, not the compat names!
#
# The lines after a distro identifier are package names or package file names
# (without the full path info). One package/filename per line is allowed!
# Lines starting with "!" specify packages which should be deleted. The lines
# are executed in the order of appearance.
# Processing of the prereq.cfg file stops after the parsing of the first
# matching block!
############################################################################
sub get_config {
    my ($path, $distro, $distver, $arch) = @_;
    local *IN;
    my (@config, $line, $match);
    
    open IN, "$path/prereq.cfg" or die "Could not open $path/prereq.cfg $!";
    while ($line = <IN>) {
	chomp $line;
	if ($line =~ /^\s*\[([^:]+):([^:]+):([^:]+)\]/) {
	    my ($d,$v,$a) = ($1,$2,$3);
	    $d =~ s/\*/\.*/g;
	    $v =~ s/\*/\.*/g;
	    $a =~ s/\*/\.*/g;
	    my $str = "$distro:$distrover:$arch";
	    my $mstr = "$d:$v:$a";
	    $match = 0;
	    if ($str =~ m/^$mstr$/) {
		$match = 1;
		vprint("found matching block [$d:$v:$a]\n");
		last;
	    }
	}
    }
    if ($match) {
	while ($line = <IN>) {
	    chomp $line;
	    last if ($line =~ /^\[([^:]+):([^:]+):([^:]+)\]/);
	    next if ($line =~ /^\s*\#/);
	    $line =~ s/^ *//g;
	    next if ($line =~ /^$/);
	    push @config, $line;
	}
    }
    close IN;
    if (@config) {
	return \@config;
    } else {
	return undef;
    }
}

sub usage {
    my $ret = shift;
    print "Usage:\n";
    print "\t$0 --dumb|--smart [--verbose] prereq_path\n\n";
    print "Install prerequisites located in prereq_path. They should have\n";
    print "the same directory structure like normal OSCAR packages but\n";
    print "need to contain the configuration file prereq.cfg\n";
    print "This file is required because prereqs are installed before\n";
    print "config.xml files can be parsed.\n";
    print "One of --smart|--dumb must be selected! --dumb installs packages\n";
    print "listed in the prereq.cfg file with the base package manager and\n";
    print "is unable to resolve dependencies. It should be used for\n";
    print "bootstrapping a smart package manager. --smart installs prereqs\n";
    print "with the help of a smart package manager like yum(e).\n";
    print "The prereq_path arguments must be paths relative to the\n";
    print "\$OSCAR_HOME environment variable's value!\n";
    exit $ret if ($ret);
}
