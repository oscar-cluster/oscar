#!/usr/bin/env perl
#
# Copyright (c) Erich Focht <efocht@hpce.nec.com>
#               All rights reserved
# Copyright (c) 2007 The Trustees of Indiana University.  
#                    All rights reserved.
# Copyright (c) 2007, Oak Ridge National Laboratory.
#                     Geoffroy R. Vallee <valleegr@ornl.gov>
#                     All rights reserved.
#
# This file is part of the OSCAR software package.  For license
# information, see the COPYING file in the top level directory of the
# OSCAR source distribution.
#
# $Id$

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::OCA::OS_Detect;
use OSCAR::PackagePath;
use OSCAR::CmpVersions;
use OSCAR::Prereqs;
use OSCAR::Logger;
use Data::Dumper;
use Carp;


my ($dumb, $smart, $verbose, $path, $status);
GetOptions(
           "dumb"      => \$dumb,
           "smart"     => \$smart,
           "status"    => \$status,
           "verbose"   => \$verbose,
           ) || &usage(1);
# check paths
&usage(1) if (!scalar(@ARGV));

my $ohome = $ENV{OSCAR_HOME};
my @prereqs;
for my $p (@ARGV) {
    if (! -d "$ohome/$p" || ! -f "$ohome/$p/prereq.cfg") {
	print "Error: $p is not a directory or doesn't contain a prereq.cfg file!\n";
	usage(1);
    } else {
	push @prereqs, "$ohome/$p";
    }
}

#
# Own distro detection
#
my $os = &OSCAR::PackagePath::distro_detect_or_die();
my $distro    = $os->{distro};
my $distrover = $os->{distro_version};
my $arch      = $os->{arch};
my $suffix    = $os->{pkg};
my $dstring   = $os->{compat_distro}.$os->{compat_distrover}.
    "-".$os->{arch};
my $cstring   = "common-".$suffix."s";

my $march = $arch;
my $rarch = $arch;
if ($arch eq "i386") {
    $march = "i?86";  # used for shell-like globbing
    $rarch = "i.86";  # used for regular expressions
}elsif($arch eq "ppc64"){ # DIKIM added for supporting YDL-ppc64
    $march = "ppc64,ppc";
    $rarch = "ppc64|ppc";
}

if ($status) {
    show_prereqs_status ($distro, $distrover, $arch, @prereqs);
    exit 0;
}

# try to detect smart installer, fall-back to dumb installer if not found
if (!$dumb) {
    $dumb = 1;
    $smart = 0;
    eval "require OSCAR::PackMan";
    if (!$@ and eval("PackMan->new()") ) {
	my $tp;
	eval "\$tp = PackMan->new()";
	if ($tp->is_smart()) {
	#(system("which yume >/dev/null 2>&1") && ($suffix eq "rpm")) or
	#(system("which rapt >/dev/null 2>&1") && ($suffix eq "deb"))) {
	    $smart = 1;
	    $dumb = 0;
	    vprint("Detected OSCAR::PackMan, using smart mode\n");
	}
    }
    if ($dumb) {
	vprint("Could not detect OSCAR::PackMan, falling back to dumb mode\n");
    }
}

# locate destination path for prereq package files and repository url
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_url();
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url();
my $separator = &OSCAR::PackagePath::pkg_separator();

vprint("Prereq paths: ".join(",",@prereqs)."\n");

#
# Is this "smart mode"? Then load PackMan and regenerate the metadata cache
#
my $pm;
if ($smart) {
    require OSCAR::PackMan;
    require OSCAR::PackageSmart;

    $pm = OSCAR::PackageSmart::prepare_distro_pools ($os);
}

# now go with the processing

# collect all config lines and build list of packages to be installed/removed
# collect all shell commands to be executed
# ...
my (@installs, @removes, @shellcmds) = 
    OSCAR::Prereqs::get_prereqs($distro, $distrover, $arch, @prereqs);

vprint("Following packages will be removed:\n\t".
       join("\n\t",@removes) . "\n");
vprint("Following packages will be installed:\n\t".
       join("\n\t",@installs) . "\n");
vprint("Following shell commands will be executed:\n\t".
       join("\n\t",@shellcmds) . "\n");

if ($dumb) {
    if ($suffix eq "rpm") {
	# do the removes before the installs
	handle_dumb_rpms(1,@removes);
	handle_dumb_rpms(0,@installs);
    } elsif ($suffix eq "deb") {
	# do the removes before the installs
	handle_dumb_debs(1,@removes);
	handle_dumb_debs(0,@installs);
    } else {
	croak "Support for dumb $suffix install is not implemented.\n";
    }
} else {
    # do the removes before the installs
    handle_smart_pkgs($path,1,@removes);
    handle_smart_pkgs($path,0,@installs);
}

# check whether rpms were really installed!!!
# ...

if (scalar(@installs) && &check_installed(@installs)) {
    print "!!! Some packages were NOT installed !!!\n";
    exit 1;
}

for my $cmd (@shellcmds) {
    $cmd =~ s/\$OSCAR_HOME/$ohome/g;
    vprint("Executing: $cmd\n");
    my $ret = system("$cmd");
    if ($ret) {
	print "Command \"$cmd\" returned $?\n";
	exit $ret;
    }
}

exit 0;

sub handle_smart_pkgs {
    my ($path, $remove, @pkgs) = @_;
    my ($err, @out);

    return if (!scalar(@pkgs));
    if ($remove) {
	print("\tsmartly removing: ".join(",",@pkgs)."\n");
	($err, @out) = $pm->smart_remove(@pkgs);
    } else {
	print("\tsmartly installing: ".join(",",@pkgs)."\n");
	($err, @out) = $pm->smart_install(@pkgs);
    }
    if (!$err) {
	print "Error occured for prereq $path\n";
	print join("\n",@out);
	exit 1;
    }
    if (!$err) {
	print "Error occured for prereq $path\n";
	print join("\n",@out);
	exit 1;
    }

}

#
# Simple implementation for dumb rpm handling
#
sub handle_dumb_rpms {
    my ($remove, @pkgs) = @_;
    my $cmd;
    return if (!scalar(@pkgs));
    for my $pkg (@pkgs) {
	# make sure we deal with package names, not file names
	my $pkgname = $pkg; $pkgname =~ s/\.rpm$//;
	if ($remove) {
	    $cmd = "rpm -q $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (!system($cmd)) {
		# remove all instances of package
		$cmd = "rpm -ev --all --nodeps $pkgname";
		vprint("Executing: $cmd\n");
		!system($cmd) or print "Warning: removal failed: $!\n";
	    } else {
		vprint("Package $pkgname not installed.\n");
	    }
	} else {
	    # already installed?
	    $cmd = "rpm -q $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (system($cmd)) {
		# not installed, so do it now
		my $pkgpath = locate_pkg($pkg);
		if ($pkgpath) {
		    $cmd = "rpm -Uhv $pkgpath";
		    vprint("Executing: $cmd\n");
		    !system($cmd) or croak "install failed: $!\n";
		} else {
		    print "WARNING: Could not locate package $pkg\n";
		}
	    }
	}
    }
}

#
# Simple implementation for dumb debian package handling
# hacked by Erich Focht out of the dumb_rpms code, without much
# knowledge of dpkg
#
sub handle_dumb_debs {
    my ($remove, @pkgs) = @_;
    my $cmd;
    my $ret;
    return if (!scalar(@pkgs));
    for my $pkg (@pkgs) {
    	# make sure we deal with package names, not file names
	    my $pkgname = $pkg; $pkgname =~ s/\.deb$//;
    	if ($remove) {
	        # we test first if the package is installed
	        $cmd = "dpkg -l | grep \"ii  $pkgname \"";
    	    vprint("Executing: $cmd\n");
	        $ret = `$cmd`;
	        if (!is_deb_pkg_installed($pkgname)) {
        		# remove all instances of package
	        	$cmd = "apt-get remove $pkgname --assume-yes";
		        vprint("Executing: $cmd\n");
    		    system($cmd);
    	    }
	    } else {
    		# we try first to find the package locally
	    	my $pkgpath = locate_pkg($pkg);
		    if ($pkgpath) {
    		    # if we find a package locally we use it
	    	    vprint("Package $pkgname locally found $pkgpath\n");
		        $cmd = "dpkg -i $pkgpath";
		        vprint("Executing: $cmd\n");
    		    !system($cmd) or croak "install failed: $!\n";
	    	} else {
		        # if we do not find a package locally, we try to find one online
		        $cmd = "apt-get update && apt-get install $pkgname --assume-yes";
    		    vprint("Executing: $cmd\n");
	    	    system($cmd);
		    }
	    }
    }
}

#
# try to locate a package file in the repositories
#
# !!EF!! Need to deal with the case that the oscar repos are on the web!
# - try to locate first within package or prereq distro directory
#   (should we always deliver bootstrap packages, even when all other
#   packages are stripped away?)
# !!GV!! It should be ok now since the dumb mode uses apt.
#

sub locate_pkg {
    my ($pkg) = @_;
    my $found = 0;
    my @pkgs;
    my @globstr;
    my $pkgmatch;
    my $sepmatch = $separator."[0-9]";
    $pkgmatch = $pkg;
    if ($pkg =~ /\.$suffix$/) {
	$pkgmatch =~ s/\.$suffix$/*.$suffix/;
    } elsif ($pkg =~ /\.($rarch|noarch|all)$/) {
	my $parch = $1;
	$pkgmatch =~ s/\.$parch$/*.$parch.$suffix/;
    } else {
	$pkgmatch .= "*{$march,noarch,all}.$suffix";
    }
    # 
    my @lrepos;
    for my $repo ( split(",",$oscar_pkg_pool), split(",",$distro_pkg_pool) ) {
	if (($repo =~ /^\//) || ($repo =~ /^(file):/)) {
	    $repo =~ s/^file://;
	    push @lrepos, $repo;
	}
    }

    push @globstr, $ENV{OSCAR_HOME}."/packages/*/distro/{$cstring,$dstring}/$pkgmatch";
    push @globstr, $ENV{OSCAR_HOME}."/share/prereqs/*/distro/{$cstring,$dstring}/$pkgmatch";

    push @globstr, map { "$_/$pkgmatch" } @lrepos;

    vprint("globstring: ".join(" ",@globstr)."\n");
    my @tmp = glob(join(" ",@globstr));
    vprint("locate_pkg glob result: ".join(",",@tmp)."\n");

    # detect best version
    return &best_version($pkg,@tmp);

    #
    # Try downloading from remote repositories?
    #
}

sub best_version {
    my ($pkg, @candidates) = @_;
    my ($best, $bestversion);
    for my $p (@candidates) {
	my ($name, $ver, $parch);
	if ($suffix eq "rpm") {
	    my $info = `rpm -q --qf "%{NAME} %{VERSION}-%{RELEASE} %{ARCH}" -p $p`;
	    my $err = $?;
	    if (!$err) {
		($name,$ver,$parch) = split(" ",$info);
	    } else {
		vprint(" ? rpm query returned $err\n");
	    }
	} elsif ($suffix eq "deb") {
	    local *IN;
	    open IN, "dpkg --info $p |" or croak("Could not open $p");
	    while (<IN>) {
		chomp;
		if (/^ Package: (.*)$/) {
		    $name = $1;
		} elsif (/^ Version: (.*)$/) {
		    $ver = $1;
		} elsif (/^ Architecture: (.*)$/) {
		    $parch = $1;
		}
	    }
	    close IN;
	}
	vprint(":: $p :: $name $ver $parch<\n");
	next if (!$name || !$ver);
	next if ($pkg !~ /^$name/);
    #$rarch = "ppc64|pcc" if $rarch eq "ppc64"; # DIKIM added it for YDL
	next if ($parch !~ /^($rarch|noarch|all)$/);
	if (!$best || (cmp_version_strings($ver, $bestversion) == 1)) {
	    vprint("   - $p selected\n");
	    $best = $p;
	    $bestversion = $ver;
	}
    }		
    return $best;
}

sub usage {
    my $ret = shift;
    print "Usage:\n";
    print "\t$0 --dumb|--smart|--status [--verbose] prereq_path\n\n";
    print "Install prerequisites located in prereq_path. They should have\n";
    print "the same directory structure like normal OSCAR packages but\n";
    print "need to contain the configuration file prereq.cfg\n";
    print "This file is required because prereqs are installed before\n";
    print "config.xml files can be parsed.\n";
    print "The option --status only displays the current prereqs status.\n";
    print "Typically it shows if prereqs packages are already installed or\n";
    print "removed.\n";
    print "If --status is not used, one of --smart|--dumb must be selected!\n";
    print "--dumb installs packages listed in the prereq.cfg file with the\n";
    print "base package manager and is unable to resolve dependencies. It \n";
    print "should be used for bootstrapping a smart package manager.\n";
    print "--smart installs prereqs with the help of a smart package manager\n";
    print " like yum(e).\n";
    print "The prereq_path arguments must be paths relative to the\n";
    print "\$OSCAR_HOME environment variable's value!\n";
    exit $ret if ($ret);
}

__END__

=head1 NAME

install_prereq, a command line tool for OSCAR for the management of
prerequriments.

=head1 SYNOPSIS

install_prereq OPTIONS <prereq_path>

=head1 DESCRIPTION

install_prereq is a command line tool for OSCAR for the management of
prerequirements. Prereqs may be binary packages to install or remove, as well as
scripts to execute. The prereqs are mandatory for the usage of OSCAR.
Install prerequisites located in prereq_path. They should have the same
directory structure like normal OSCAR packages but need to contain the
configuration file prereq.cfg. This file is required because prereqs are 
installed before config.xml files can be parsed.
For more information about this configuration file and prereqs functionnalities,
please refer to the OSCAR documentation. For more information about OSCAR, please 
visit http://oscar.openclustergroup.org/.

=head2 Syntax

install_prereq [options] <prereq_path>

=over 1

=item prereq_path

The path of the configuration file for a given prereq.

=head2 Options

Recognized options include: --dumb|--smart|--status [--verbose]

=over 4

=item --dumb

Installs packages listed in the prereq.cfg file with the base package manager 
and is unable to resolve dependencies. It should be used for bootstrapping a 
smart package manager.

=item --smart

Installs prereqs with the help of a smart package manager like yum(e).

=item --status

Give the current status of a given prereq.

=item --verbose

Display debugging information.
