#!/usr/bin/env perl
#
# Copyright (c) Erich Focht <efocht@hpce.nec.com>
#               All rights reserved
#
# This file is part of the OSCAR software package.  For license
# information, see the COPYING file in the top level directory of the
# OSCAR source distribution.
#
# $Id$

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::OCA::OS_Detect;
use OSCAR::PackagePath;
use OSCAR::CmpVersions;
use Data::Dumper;
use Carp;


my ($dumb, $smart, $verbose, $path);
GetOptions(
           "dumb"      => \$dumb,
           "smart"     => \$smart,
           "verbose"   => \$verbose,
           ) || &usage(1);
# check paths
&usage(1) if (!scalar(@ARGV));

my $ohome = $ENV{OSCAR_HOME};
my @prereqs;
for my $p (@ARGV) {
    if (! -d "$ohome/$p" || ! -f "$ohome/$p/prereq.cfg") {
	print "Error: $p is not a directory or doesn't contain a prereq.cfg file!\n";
	usage(1);
    } else {
	push @prereqs, "$ohome/$p";
    }
}

#
# Own distro detection
#
my $os = &OSCAR::PackagePath::distro_detect_or_die();
my $distro    = $os->{distro};
my $distrover = $os->{distro_version};
my $arch      = $os->{arch};
my $suffix    = $os->{pkg};
my $dstring   = $os->{compat_distro}.$os->{compat_distrover}.
    "-".$os->{arch};
my $cstring   = "common-".$suffix."s";

my $march = $arch;
my $rarch = $arch;
if ($arch eq "i386") {
    $march = "i?86";  # used for shell-like globbing
    $rarch = "i.86";  # used for regular expressions
}

# try to detect smart installer, fall-back to dumb installer if not found
if (!$dumb) {
    $dumb = 1;
    $smart = 0;
    eval "require OSCAR::PackMan";
    if (!$@ and eval("PackMan->new()") ) {
	my $tp;
	eval "\$tp = PackMan->new()";
	if ($tp->is_smart()) {
	#(system("which yume >/dev/null 2>&1") && ($suffix eq "rpm")) or
	#(system("which rapt >/dev/null 2>&1") && ($suffix eq "deb"))) {
	    $smart = 1;
	    $dumb = 0;
	    vprint("Detected OSCAR::PackMan, using smart mode\n");
	}
    }
    if ($dumb) {
	vprint("Could not detect OSCAR::PackMan, falling back to dumb mode\n");
    }
}


# locate destination path for prereq package files and repository url
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_url();
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url();
my $separator = &OSCAR::PackagePath::pkg_separator();

vprint("OSCAR pkg path: $oscar_pkg_pool\n");
vprint("Distro pkg path: $distro_pkg_pool\n");
vprint("Prereq paths: ".join(",",@prereqs))."\n";

#
# Is this "smart mode"? Then load PackMan and regenerate the metadata cache
#
my $pm;
if ($smart) {
    require OSCAR::PackMan;
    require OSCAR::PackageSmart;
    $pm = OSCAR::PackageSmart::prepare_pools($verbose,$oscar_pkg_pool,$distro_pkg_pool);
    if (!$pm) {
	croak "\nERROR: Could not create PackMan instance!\n";
    }
}

# now go with the processing

# collect all config lines and build list of packages to be installed/removed
# collect all shell commands to be executed
# ...

my (@removes, @installs, @shellcmds, %files);
for my $path (@prereqs) {
    # read in prereq.cfg file
    my $ref = &get_config($path, $distro, $distrover, $arch);
    if (!$ref) {
	print "Couldn't match any config block in $path/prereq.cfg\n";
	next;
    }
    for my $line (@{$ref}) {
	$line =~ s/^\s*//g;
	next if ($line =~ /^\#/ && $line =~ /^$/);

	if ($line =~ /^sh:(.*)$/) {
	    # shell script execution
	    my $cmd = $1;
	    $cmd =~ s/^\s*//;
	    next if (!$cmd);
	    push @shellcmds, $cmd;
	} else {
	    # replace $arch with architecture in package config lines
	    # this prevents packages to be interpreted as capabilities
	    if ($line =~ /\$arch/) {
		$line =~ s:\$arch:$march:g;
	    }
	    my $remove = ($line =~ /^!/);
	    if ($remove) {
		$line =~ s/^!//g;
	    }
	    my ($pkg,$dummy) = split(/\s+/,$line);
	    if ($remove) {
		push @removes, $pkg;
	    } else {
		push @installs, $pkg;
	    }
	}
    }
}

vprint("Following packages will be removed:\n\t".
       join("\n\t",@removes) . "\n");
vprint("Following packages will be installed:\n\t".
       join("\n\t",@installs) . "\n");
print("Following packages will be installed:\n\t".
       join("\n\t",@installs) . "\n");
vprint("Following shell commands will be executed:\n\t".
       join("\n\t",@shellcmds) . "\n");

if ($dumb) {
    if ($suffix eq "rpm") {
	# do the removes before the installs
	handle_dumb_rpms(1,@removes);
	handle_dumb_rpms(0,@installs);
    } elsif ($suffix eq "deb") {
	# do the removes before the installs
	handle_dumb_debs(1,@removes);
	handle_dumb_debs(0,@installs);
    } else {
	croak "Support for dumb ".$suffix." install is not implemented.\n";
    }
} else {
    # do the removes before the installs
    handle_smart_pkgs($path,1,@removes);
    handle_smart_pkgs($path,0,@installs);
}

# check whether rpms were really installed!!!
# ...

if (scalar(@installs) && &check_installed(@installs)) {
    print "!!! Some packages were NOT installed !!!\n";
    exit 1;
}

for my $cmd (@shellcmds) {
    $cmd =~ s/\$OSCAR_HOME/$ohome/g;
    vprint("Executing: $cmd\n");
    !system("$cmd") or print "Command \"$cmd\" returned $?\n";
}

exit 0;

sub handle_smart_pkgs {
    my ($path, $remove, @pkgs) = @_;
    my ($err, @out);

    return if (!scalar(@pkgs));
    if ($remove) {
	print("\tsmartly removing: ".join(",",@pkgs)."\n");
	($err, @out) = $pm->smart_remove(@pkgs);
    } else {
	print("\tsmartly installing: ".join(",",@pkgs)."\n");
	($err, @out) = $pm->smart_install(@pkgs);
    }
    if (!$err) {
	print "Error occured for prereq $path\n";
	print join("\n",@out);
	exit 1;
    }
    if (!$err) {
	print "Error occured for prereq $path\n";
	print join("\n",@out);
	exit 1;
    }

}

#
# Simple implementation for dumb rpm handling
#
sub handle_dumb_rpms {
    my ($remove, @pkgs) = @_;
    my $cmd;
    return if (!scalar(@pkgs));
    for my $pkg (@pkgs) {
	# make sure we deal with package names, not file names
	my $pkgname = $pkg; $pkgname =~ s/\.rpm$//;
	if ($remove) {
	    $cmd = "rpm -q $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (!system($cmd)) {
		# remove all instances of package
		$cmd = "rpm -ev --all --nodeps $pkgname";
		vprint("Executing: $cmd\n");
		!system($cmd) or print "Warning: removal failed: $!\n";
	    } else {
		vprint("Package $pkgname not installed.\n");
	    }
	} else {
	    # already installed?
	    $cmd = "rpm -q $pkgname >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (system($cmd)) {
		# not installed, so do it now
		my $pkgpath = locate_pkg($pkg);
		if ($pkgpath) {
		    $cmd = "rpm -Uhv $pkgpath";
		    vprint("Executing: $cmd\n");
		    !system($cmd) or croak "install failed: $!\n";
		} else {
		    print "WARNING: Could not locate package $pkg\n";
		}
	    }
	}
    }
}

#
# Simple implementation for dumb debian package handling
# hacked by Erich Focht out of the dumb_rpms code, without much
# knowledge of dpkg
#
sub handle_dumb_debs {
    my ($remove, @pkgs) = @_;
    my $cmd;
    my $ret;
    return if (!scalar(@pkgs));
    print "Debian packages to install @pkgs\n";
    for my $pkg (@pkgs) {
	# make sure we deal with package names, not file names
	my $pkgname = $pkg; $pkgname =~ s/\.deb$//;
	if ($remove) {
	    # we test first if the package is installed
	    $cmd = "dpkg -l | grep $pkgname";
	    vprint("Executing: $cmd\n");
	    $ret = `$cmd`;
	    if (!$ret)) {
	      vprint("Package not installed, we do not try to remove it\n");
	    } else {
	      # remove all instances of package
	      $cmd = "apt-get remove $pkgname --assume-yes";
	      vprint("Executing: $cmd\n");
	      system($cmd);
	    }
	} else {
	  # we first check if the package is already installed or not
	  $cmd = "dpkg -l | grep $pkgname";
	  vprint("Executing: $cmd\n");
	  $ret = `$cmd`;
	  if (!$ret) {
	    vprint("Package $pkgname already installed\n");
	  } else {
	    # we try first to find the package locally
	    my $pkgpath = locate_pkg($pkg);
	    if ($pkgpath) {
	      # if we find a package locally we use it
	      vprint("Package $pkgname locally found $pkgpath\n");
	      $cmd = "dpkg -i $pkgpath";
	      vprint("Executing: $cmd\n");
	      !system($cmd) or croak "install failed: $!\n";
	    } else {
	      # if we do not find a package locally, we try to find one online
	      $cmd = "apt-get install $pkgname --assume-yes";
	      vprint("Executing: $cmd\n");
	      system($cmd);
	    }
	  }
	}
    }
}

#
# try to locate a package file in the repositories
#
# !!EF!! Need to deal with the case that the oscar repos are on the web!
# - try to locate first within package or prereq distro directory
#   (should we always deliver bootstrap packages, even when all other
#   packages are stripped away?)
#

sub locate_pkg {
    my ($pkg) = @_;
    my $found = 0;
    my @pkgs;
    my @globstr;
    my $pkgmatch;
    my $sepmatch = $separator."[0-9]";
    $pkgmatch = $pkg;
    if ($pkg =~ /\.$suffix$/) {
	$pkgmatch =~ s/\.$suffix$/*.$suffix/;
    } elsif ($pkg =~ /\.($rarch|noarch|all)$/) {
	my $parch = $1;
	$pkgmatch =~ s/\.$parch$/*.$parch.$suffix/;
    } else {
	$pkgmatch .= "*{$march,noarch,all}.$suffix";
    }
    # 
    my @lrepos;
    for my $repo ( split(",",$oscar_pkg_pool), split(",",$distro_pkg_pool) ) {
	if (($repo =~ /^\//) || ($repo =~ /^(file):/)) {
	    $repo =~ s/^file://;
	    push @lrepos, $repo;
	}
    }

    push @globstr, $ENV{OSCAR_HOME}."/packages/*/distro/{$cstring,$dstring}/$pkgmatch";
    push @globstr, $ENV{OSCAR_HOME}."/share/prereqs/*/distro/{$cstring,$dstring}/$pkgmatch";

    push @globstr, map { "$_/$pkgmatch" } @lrepos;

    vprint("globstring: ".join(" ",@globstr)."\n");
    my @tmp = glob(join(" ",@globstr));
    vprint("locate_pkg glob result: ".join(",",@tmp)."\n");

    # detect best version
    return &best_version($pkg,@tmp);

    #
    # Try downloading from remote repositories?
    #
}

sub best_version {
    my ($pkg, @candidates) = @_;
    my ($best, $bestversion);
    for my $p (@candidates) {
	my ($name, $ver, $parch);
	if ($suffix eq "rpm") {
	    my $info = `rpm -q --qf "%{NAME} %{VERSION}-%{RELEASE} %{ARCH}" -p $p`;
	    my $err = $?;
	    if (!$err) {
		($name,$ver,$parch) = split(" ",$info);
	    } else {
		vprint(" ? rpm query returned $err\n");
	    }
	} elsif ($suffix eq "deb") {
	    local *IN;
	    open IN, "dpkg --info $p |" or croak("Could not open $p");
	    while (<IN>) {
		chomp;
		if (/^ Package: (.*)$/) {
		    $name = $1;
		} elsif (/^ Version: (.*)$/) {
		    $ver = $1;
		} elsif (/^ Architecture: (.*)$/) {
		    $parch = $1;
		}
	    }
	    close IN;
	}
	vprint(":: $p :: $name $ver $parch<\n");
	next if (!$name || !$ver);
	next if ($pkg !~ /^$name/);
	next if ($parch !~ /^($rarch|noarch|all)$/);
	if (!$best || (cmp_version_strings($ver, $bestversion) == 1)) {
	    vprint("   - $p selected\n");
	    $best = $p;
	    $bestversion = $ver;
	}
    }		
    return $best;
}

#
# Check whether packages were really installed or not
#
sub check_installed {
    my (@pkgs) = @_;
    my ($cmd, $err);
    $err = 0;
    for my $p (@pkgs) {
	# strip suffix is argument is a complete package name
	if ($p =~ /\.$suffix$/) {
	    $p =~ s/\.$suffix$//;
	}
	if ($p =~ /\.($rarch|noarch)$/) {
	    $p =~ s/\.($rarch|noarch)$//;
	}
	if ($suffix eq "rpm") {
	    $cmd = "rpm -q $p >/dev/null 2>&1";
	    vprint("Executing: $cmd\n");
	    if (system($cmd)) {
		$err++;
		print "WARNING: Package $p was not installed!\n";
	    }
	} elsif ($suffix eq "deb") {
	    $cmd = "dpkg -l | grep $p";
	    vprint("Executing: $cmd\n");
	    my $ret=`$cmd`;
	    if (!$ret) {
		$err++;
		print "WARNING: Package $p was not installed!\n";
	    }
	}
    }
    return $err;
}

sub vprint {
    print @_ if ($verbose);
}


############################################################################
# Prerequisites config file. This is called prereq.cfg and should be located
# in the top directory of the otherwise generic-setup compatible prerequisites
# directory. Because prereqs are installed long before OSCAR is able to parse
# config.xml files, prereq.cfg is much simpler. The format is:
#
# [distro:version:architecture]
# package_name_or_rpm_file
# ...
# !package_name
# ...
# [distro2:version:architecture]
# ...
#
# The distro name, version or arch info can contain a "*". This matches
# like a .* regexp.
# Examples:
# [redhat-el*:3:*] matches all rhel3 architectures.
# [fedora:*:*]     matches all fedora core distros on all architectures
# [mandr*:*:*]     matches both mandrake and mandriva
# [*:*:*]          matches everything.
#
# Attention! The real distro names are used here, not the compat names!
#
# The lines after a distro identifier are package names or package file names
# (without the full path info). One package/filename per line is allowed!
# Lines starting with "!" specify packages which should be deleted. The lines
# are executed in the order of appearance.
# Processing of the prereq.cfg file stops after the parsing of the first
# matching block!
############################################################################
sub get_config {
    my ($path, $distro, $distver, $arch) = @_;
    local *IN;
    my (@config, $line, $match);
    
    open IN, "$path/prereq.cfg" or die "Could not open $path/prereq.cfg $!";
    while ($line = <IN>) {
	chomp $line;
	if ($line =~ /^\s*\[([^:]+):([^:]+):([^:]+)\]/) {
	    my ($d,$v,$a) = ($1,$2,$3);
	    $d =~ s/\*/\.*/g;
	    $v =~ s/\*/\.*/g;
	    $a =~ s/\*/\.*/g;
	    my $str = "$distro:$distrover:$arch";
	    my $mstr = "$d:$v:$a";
	    $match = 0;
	    if ($str =~ m/^$mstr$/) {
		$match = 1;
		vprint("found matching block [$d:$v:$a]\n");
		last;
	    }
	}
    }
    if ($match) {
	while ($line = <IN>) {
	    chomp $line;
	    last if ($line =~ /^\[([^:]+):([^:]+):([^:]+)\]/);
	    next if ($line =~ /^\s*\#/);
	    $line =~ s/^ *//g;
	    next if ($line =~ /^$/);
	    push @config, $line;
	}
    }
    close IN;
    if (@config) {
	return \@config;
    } else {
	return undef;
    }
}

sub usage {
    my $ret = shift;
    print "Usage:\n";
    print "\t$0 --dumb|--smart [--verbose] prereq_path\n\n";
    print "Install prerequisites located in prereq_path. They should have\n";
    print "the same directory structure like normal OSCAR packages but\n";
    print "need to contain the configuration file prereq.cfg\n";
    print "This file is required because prereqs are installed before\n";
    print "config.xml files can be parsed.\n";
    print "One of --smart|--dumb must be selected! --dumb installs packages\n";
    print "listed in the prereq.cfg file with the base package manager and\n";
    print "is unable to resolve dependencies. It should be used for\n";
    print "bootstrapping a smart package manager. --smart installs prereqs\n";
    print "with the help of a smart package manager like yum(e).\n";
    print "The prereq_path arguments must be paths relative to the\n";
    print "\$OSCAR_HOME environment variable's value!\n";
    exit $ret if ($ret);
}

