#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Copyright © 2003, The Board of Trustees of the University of Illinois. All rights reserved.
# Copyright 2003 NCSA
#                Neil Gorsuch <ngorsuch@ncsa.uiuc.edu>
# Copyright 2004 Revolution Linux
#           Benoit des Ligneris <bdesligneris@revolutionlinux.com>
# Copyright (c) 2005-2006 The Trustees of Indiana University.  
#                    All rights reserved.
# Copyright (c) 2005 Bernard Li <bli@bcgsc.ca>.
#                    All rights reserved.
# Copyright (c) 2006 Erich Focht <efocht@hpce.nec.com>
#                    All rights reserved.
#       
# $Id$

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib","$ENV{OSCAR_HOME}/lib/OSCAR","../../../lib","../../../lib/OSCAR";
use OSCAR::Package;
use OSCAR::PackagePath;
use OSCAR::Network;
use Data::Dumper;
use XML::Simple;
use OSCAR::Distro;
use OSCAR::Database;
use OSCAR::oda;

my $folding_character = "_";
my %list_of_multiple_value_folded_fields = ();
my %multiple_value_folded_fields = ();
my %oda_fieldnames = ();
my %oda_shortcuts = ();
my $package_tables_name_prefix = "package_";
my $packages_table_name = "Packages";
my %single_value_folded_fields = ();
my $xml_file_name = "config.xml";

my @error_strings = ();
my %table_fields_hash = ();
my %oda_options = ( 'debug'        => 0,
                    'verbose'      => 0 );
my %options = (  'changes'      => 1,
                 'debug'        => 0,
                 'verbose'      => 0 );

if ( (exists $ENV{OSCAR_VERBOSE} && $ENV{OSCAR_VERBOSE} == 10) 
    || $ENV{OSCAR_DB_VERBOSE} ){
    $options{verbose} = 1;
    $oda_options{verbose} = 1;
}

if ($ENV{OSCAR_DB_DEBUG}) {
    $oda_options{debug} = 1;
    $options{debug} = 1;
}

my $DEFAULT = "Default";                 
# find the base directory of the oscar distribution,
my $oscar_home;
# first try the environmental variable
if ( exists $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
    die "DB_DEBUG>$0:\n====> bad OSCAR_HOME environmental variable value <$oscar_home>"
	if ( ! -d "$oscar_home");
} else {
    die "\nEnvironment variable \$OSCAR_HOME is not set!\n";
}

print "DB_DEBUG>$0:\n====> oscar_home=<$oscar_home>\n" if $options{debug};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("bundling");    # allow -a -b or -ab
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

# parse command line options
GetOptions( \%options,
        'changes!',
            'debug!',
            'help',
        'oda=s',
            'verbose!',
            'version' )
    || usage(1);
print "DB_DEBUG>$0:\n====> after GetOptions ARGV=<@ARGV>\n" if $options{debug};
oda::print_hash( "", "DB_DEBUG>$0:\n====> options after GetOptions", \%options)
    if $oda_options{debug};


# function to do a debug print of a hash
# inputs: leading_spaces  string to put in front of lines
#         name            string to print as the hash name
#         hash_ref        pointer to the hash to print       

sub print_hash {
    my( $leading_spaces, $name, $hashref ) = @_;
    print "DB_DEBUG>$0:\n====> $leading_spaces$name ->\n";
    foreach my $key ( sort keys %$hashref ) {
    my $value = $$hashref{$key};
    if (ref($value) eq "HASH") {
        print_hash(  "$leading_spaces    ", $key, $value );
    } elsif (ref($value) eq "ARRAY") {
        my $string = join(',', @$value);
        print "DB_DEBUG>$0:\n====> $leading_spaces    $key => ($string)\n";
    } elsif (ref($value) eq "SCALAR") {
        print "DB_DEBUG>$0:\n====> $leading_spaces    $key is a scalar ref\n";
        print "DB_DEBUG>$0:\n====> $leading_spaces    $key => $$value\n";
    } else {
        $value = "undef" unless defined $value;
        print "DB_DEBUG>$0:\n====> $leading_spaces    $key => <$value>\n";
    }
    }
}

sub get_xml_ref{
    my ($package_directory,
        $package_name,
        $msg) = @_;
    # if a config.xml file does not exist for this package directory,
    # we'll fake a simple one, otherwise read it in
    my $config_file = "$package_directory/$xml_file_name";
    my $xml_ref = undef;
    if ( ! -f $config_file ) {
        print "Warning, no $config_file exists, supplying one for package $package_name\n";
    } else {
        print "Processing $config_file for package $package_name ...\n$msg" if $msg;
        my $xs = new XML::Simple();
        $xml_ref = eval { $xs->XMLin( $config_file ); };
        if ($@) {
        print "ERROR, $config_file is invalid, supplying one for package $package_name\n";
            $xml_ref = undef;
        print "Trying to xmllint the $config_file to show problems:\n";
        system "xmllint $config_file";
        }
    }
    if ( ! defined $xml_ref ) {
        my %faked_xml;
        $faked_xml{class} = "third-party";
        $faked_xml{description} = "Not provided";
        $faked_xml{name} = $package_name;
        $faked_xml{summary} = "Not provided";
        $xml_ref = \%faked_xml;
    }
    if ( $oda_options{debug} ) {
        print "DB_DEBUG>$0:\n====> xml_ref:\n";
        print Dumper($xml_ref);
    }

    return $xml_ref;
}

sub is_installed {
    my ($package,
        $version) = @_;
    print "DB_DEBUG>$0:\n====> in is_installed Checking to see if Packages table has been already populated\n"
        if $options{debug} || $options{verbose};
    my $result_ref = get_package_info_with_name($package,
                        \%options,\@error_strings,$version);
    return ($result_ref?1:0);                    
}

sub delete_packages_related_table {
    my ($package,$options_ref,$error_ref,$package_version) = @_;
    my $where = "";
    my $package_ref = 
        get_package_info_with_name($package,
                                   $options_ref,
                                   $error_ref,
                                   $package_version);
    my $package_id = $$package_ref{id};

    my @list_of_tables = ("Packages_rpmlists", 
                          "Packages_conflicts", "Packages_provides",
                          "Packages_requires", "Packages_servicelists",
                          "Packages_switcher");
    foreach my $table_name (@list_of_tables){
        if ($table_name eq "Packages_conflicts" ||
            $table_name eq "Packages_provides" ||
            $table_name eq "Packages_requires"){
            $where = "WHERE p1_id='$package_id'";
        }else{
            $where = "WHERE package_id='$package_id'";
        }
        delete_table($options_ref,$table_name, $where ,$error_ref);
    }
    return $package_id;
}    

sub usage {
    my ( $exit_status, @error_strings ) = @_;
    my $progname = $0;
    print <<USAGE;

$progname [options] [directory [ package_name [ package_version ] ] ]

1. NO Argument
$progname creates the OSCAR tables if they don't exist.
And then, it goes through all the packages on the OSCAR 
package directory($ENV{OSCAR_HOME}/packages) and look 
into each package to parse a $xml_file_name file.
The parsed information is stored to the OSCAR database.
This program mainly does three things without argument:
1) Create all the OSCAR tables from the SQL which is already
   defined (ODA tables are created with InnoDB type)
2) Inserts the package records parsed from $xml_file_name into
   the following tables:
- Packages
- Packages_rpmlists
- Packages_servicelists
- Packages_switcher
- Packages_conflict
- Packages_requiers
- Packages_provides
3) Call set_global_oscar_values to set the global oscar values
   to the following tables
- Clusters   
- Groups
- Status

2. With one or two arguments
$progname reads a $xml_file_name file for a single package
from a specified directory.  It parses database information
from that file, and stores it into the OSCAR database.
Any previously existing database information for that
version of that package is removed from the database before 
inserting information from the $xml_file_name file.
This implements the only section #2 of the "NO Argument" case.

Options:
  --[no]changes     turns on[off] database changes, default is on
  --[no]debug       turns on[off] debug output, default is off
  --help            prints out usage information then exits
  --oda=OPTION(S)   specifies options to be passed to ODA
  --[no]verbose     turns on[off] verbose output, default is off

Usage:
$progname [options] [directory [ package_name [ package_version ] ] ]

USAGE
    if ( @error_strings ) {
	print "\n";
	warn shift @error_strings while @error_strings;
    }
    exit $exit_status;
}

# --help flag just prints out usage information and exits
if ( exists $options{help} ) {
    usage( 0 );
}

my $directory_argument;
my $package_directory;
my $package_name;
my $package_version = "";
if( @ARGV ){
    $directory_argument = shift @ARGV if @ARGV;
    $package_directory = $directory_argument;
    $package_directory = `pwd` . "/$package_directory" 
        if $package_directory !~ /^\//;
    $package_directory =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
    $package_directory =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
    $package_directory =~ s,/\./,/,g;                 # change /./       to /
    $package_directory =~ s,/$,,;       # take / off the end
    print "DB_DEBUG>$0:\n====> package_directory=<$package_directory>\n" if $options{debug};

    # there might be a package short name argument, if not,
    # take the last portion of the directory path,
    if ( @ARGV ) {
        $package_name = shift @ARGV;
    } else {
        $package_name = $package_directory;
        $package_name = $package_name . "/" if $package_name !~ /\/$/;
        $package_name =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
        $package_name =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
        $package_name =~ s,/\./,/,g;                 # change /./       to /
        $package_name =~ s,/$,,;       # take / off the end
        $package_name =~ s,^.*/,,;     # take */ off the beginning
    }
    print "DB_DEBUG>$0:\n====> package_name=<$package_name>\n" if $options{debug};
    usage(1,
          "Package name $package_name from directory $package_directory has to start with a letter" )
        if $package_name !~ /^[a-zA-Z]/;
    usage(1,
          "Package name $package_name from directory $package_directory has illegal characters" )
        if $package_name !~ /^[a-zA-Z0-9][a-zA-Z0-9\.\_\-]*$/;

    # and if there is another argument, there
    # might be a package version argument
    if ( @ARGV ) {
        $package_version = shift @ARGV;
    }

    # any arguments left is an error
    usage( 1, "unknown argument(s) " . join( ' ', @ARGV ) ) if @ARGV;
}

my @base_directories = @OSCAR::PackagePath::PKG_SOURCE_LOCATIONS;
if ( !($directory_argument && $package_name) ){

    # find the name of the mysql service and start the mysql server,
    # and make sure it is run on every system reboot
    my ($oscar_server_distribution,$oscar_server_distribution_version) = which_distro_server();
    my $mysql_service_name=which_mysql_name($oscar_server_distribution,$oscar_server_distribution_version);

    my $command="/etc/init.d/$mysql_service_name status";
    my @command_output = `$command`;
    my $status = $?;
    chomp @command_output;
    if ( ! grep( /is\ running/, @command_output ) || ! $status ) {
        print "Starting the mysql database server ...\n";
        my $command = "/etc/init.d/$mysql_service_name start";
        print "$command\n";
        if ( system( $command ) ) {
        my @error_strings = ();
        oda::oda_disconnect( \%options );
        warn shift @error_strings while @error_strings;
        die "DB_DEBUG>$0:\n====> cannot start the mysql database server!";
        }
        sleep 2;
    }
    print "Making sure that the mysql database server starts on subsequent boots ...\n";
    my $command = "chkconfig $mysql_service_name on";
    print "$command\n";
    warn "DB_DEBUG>$0:\n====> WARNING: the mysql database service may not start on subsequent reboots"
        if system( $command );
        
    # create the database if not already there and leave us connected to it
    my %databases = ();
    oda::list_databases( \%options, \%databases );
    if ( ! $databases{ oscar } ) {
        print "Creating the OSCAR database ...\n";
        my @error_strings = ();
        if ( ! oda::create_database( \%options,
                     \@error_strings ) ) {
        warn shift @error_strings while @error_strings;
        die "DB_DEBUG>$0:\n====> cannot create the OSCAR database";
        }
        print "... OSCAR database successfully created.\n";
    }
    print "Searching these directories for packages:\n";
    foreach my $base_directory ( @base_directories ) {
        print "    $base_directory\n";
    }
}

if ( ! oda::oda_connect( \%options,
             \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
    die "DB_DEBUG>$0:\n====> cannot connect to the OSCAR database";
}

# Initialize the oscar packages related database information by
# slurping in (or supplying default) package config.xml files
# for all packages that were supplied in the oscar tarball/rpm
# and that have been downloaded through opd before this.
# The config.xml file for oda is a special case and is always 
# read in first since it defines a number of database tables
# and is critical for oscar operations.
# First find the list of all the package directories,
# keeping a seperate list of the oda package directories
# (a newer version of the oda package might have been downloaded).
my @directories = ();
my @oda_directories = ();
my $msg = "";
my $xml_ref = undef;

if( $directory_argument ){
    push @directories, $package_directory;
}else{    
    foreach my $packages_base_directory ( @base_directories ) {
        opendir(PACKAGES, $packages_base_directory)
        || next;
        while ( my $package = readdir(PACKAGES) ) {
            chomp $package;
            if ( $package eq "oda" ) {
                push @oda_directories,
                "$packages_base_directory/$package";
            } 
            push @directories,
            "$packages_base_directory/$package";
        }
    }
    my @valid_oda_directories = ();
    foreach my $oda_directory ( @oda_directories ) {
        if ( ! -f "$oda_directory/$xml_file_name" ) {
        warn "DB_DEBUG>$0:\n====> ignoring the invalid oda package directory $oda_directory" .
            " that does not contain a $xml_file_name file";
        } else {
        push @valid_oda_directories, $oda_directory;
        }
    }
    die "DB_DEBUG>$0:\n====> cannot find any valid oda packages in these directories: @base_directories"
        if ! (@valid_oda_directories || @directories);
    my $oda_directory = pop @valid_oda_directories;
    foreach my $skipped_oda_directory ( @valid_oda_directories ) {
        warn "DB_DEBUG>$0:\n====> ignoring oda package directory $skipped_oda_directory";
    }
    # Create oscar tables through the config.xml which contains the table information
    # If the table already exists, it will not be created again but
    # %table_fields_hash is updated everytime package_config_xmls_to_database runs.
    #$xml_ref = get_xml_ref($oda_directory, "oda", $msg);
    #foreach my $table_name (keys (%{$xml_ref->{database_tables}})){
    #    my $tmp_hash =  $xml_ref->{database_tables}->{$table_name};
    #    die "DB_DEBUG>$0:\n====> cannot create a table, $table_name"
    #        if ! create_table($tmp_hash,$table_name,\%table_fields_hash,\%options, \@error_strings);
    #}
    die "DB_DEBUG>$0:\n====> cannot create OSCAR tables" 
        if ! create_table(\%options, \@error_strings);
    print "\nDB_DEBUG>$0:\n===========================((( All the OSCAR tables are created )))===========================\n"
        if $options{debug} || $options{verbose};
    $ENV{OSCAR_HEAD_INTERNAL_INTERFACE} = "eth0"    
        if ! exists $ENV{OSCAR_HEAD_INTERNAL_INTERFACE};    
    my $exit_status = system("$ENV{OSCAR_HOME}/scripts/set_global_oscar_values "
                ."--interface $ENV{OSCAR_HEAD_INTERNAL_INTERFACE}". ($options{debug}?" --debug":"") )/256;
    croak("Couldn't initialize the global database values table") if $exit_status;
    print "\nDB_DEBUG>$0:\n===========================((( All the OSCAR global values are set )))===========================\n"
        if $options{debug} || $options{verbose};
    my $exit_status =
        system("$ENV{OSCAR_HOME}/scripts/create_and_populate_basic_node_info". ($options{debug}?" --debug":"") )/256;
    croak("Couldn't set up a default package set") if $exit_status;
    print "\nDB_DEBUG>$0:\n===========================((( All the basic node infos are set  )))===========================\n"
        if $options{debug} || $options{verbose};
        
}    

my %fields = ();
if ( (scalar keys %table_fields_hash) == 0 ){
    oda::list_fields(\%options,"Packages",\%fields,\@error_strings);
    my %packages_hash = %fields;
    foreach my $field (keys %packages_hash){
        if($field == "__group"){ $field = "group"; }
        if($field == "__class"){ $field = "class"; }
        $packages_hash{$field} = 1;
    }
    $table_fields_hash{"Packages"} = \%packages_hash;
}    


my @packages_in_db = get_packages(\%options,\@error_strings);
my %opkg_to_be_deleted = ();
foreach my $key_package (@packages_in_db){
    $opkg_to_be_deleted{$key_package} = 1;
}    

print "\nDB_DEBUG>$0:\n<<<<<=========================== Creation of Packages table is beginning\n"
    if $options{debug} || $options{verbose};
foreach my $directory ( @directories ) {
    my $package = $directory;
    $package =~ s,^.*/,,;
    if ( -d $directory &&
         $package ne "." &&
         $package ne ".." &&
         $package ne "CVS" &&
         $package ne ".svn" &&
         ! -e "$directory/.oscar_ignore" ) {

        # Assign 1 to %opkg_to_be_deleted if $package is already in the DB
        # ,which means it($package) should be kept.
        # The rest of packages with 1 in %opkg_to_be_deleted will be removed
        $opkg_to_be_deleted{$package} = 0 if $opkg_to_be_deleted{$package};
         
        print "\nDB_DEBUG>$0:\nPACKAGE : <<<<<<<<<<<<< $package >>>>>>>>>>>>> : Packages Table\n"
            if $options{debug};
        $msg = "";
        $xml_ref = get_xml_ref($directory, $package,$msg);
        if( is_installed($package,$package_version) ){
            my $package_id = delete_packages_related_table($package,\%options,\@error_strings,$package_version);
            update_packages($xml_ref, "Packages", $package_id, $package, 
                            $directory, \%table_fields_hash, \%options, \@error_strings);
            $msg = "Modifying existing $packages_table_name record for package";
        }else{
            $msg = "Writing a new $packages_table_name record for package";

            print Dumper(\%table_fields_hash) if $oda_options{debug};
            print_hash("", "Print the package $package/$xml_file_name", $xml_ref)
                if $oda_options{debug};
                    
            # Insert into "Packages" table
            insert_packages($xml_ref, "Packages", $package, $directory,
                            \%table_fields_hash, \%options, \@error_strings);
        }        
    }
}

print "\nDB_DEBUG>$0:\n===========================>>>>> Creation of Packages table is finished\n"
    if $options{debug} || $options{verbose};
my @nics_results = ();
my $server_node = "oscar_server";

# Determine if it is the first time installation or not.
# If nics table is already filled in, this is not first time installation
# and skip the process of inserting into the Group_Packages table.
get_nics_info_with_node($server_node,\@nics_results,\%options,\@error_strings);
print "DB_DEBUG>$0:\n====> If get_nics_info_with_node returns nothing, just go to next step: handling Packages related tables.\n"
      . "Otherwise, initialize the Packages related tables\n"
      if $options{debug} || $options{verbose};

# Delete the packages to be deleted when there is no $directory_argument,
# which means it is a call from normal installation but not from OPD.
# This needs to clean the tables related to Packages too.
if(!$directory_argument){
    foreach my $pkg (keys %opkg_to_be_deleted){
        if($opkg_to_be_deleted{$pkg} == 1){
            delete_packages_related_table($pkg,\%options,\@error_strings,$package_version);
            delete_package($pkg,\%options,\@error_strings);
        }
    }    
}

print "\nDB_DEBUG>$0:\n<<<<<=========================== Adding/Modifying entries of Packages related tables is beginning\n"
    if $options{debug} || $options{verbose};
foreach my $directory ( @directories ) {
    my $package = $directory;
    $package =~ s,^.*/,,;
    if ( -d $directory &&
         $package ne "." &&
         $package ne ".." &&
         $package ne "CVS" &&
         $package ne ".svn" &&
         ! -e "$directory/.oscar_ignore" ) {
        print "\nDB_DEBUG>$0:\nPACKAGE : <<<<<<<<<<<<< $package >>>>>>>>>>>>> : Packages_related Table\n"
            if $options{debug};
        my $each_msg = $msg . " $package ".($package_version?"$package_version\n":"\n");
        $xml_ref = get_xml_ref($directory, $package,$each_msg);
        print_hash("", "Print the package $package/$xml_file_name", $xml_ref)
            if $oda_options{debug};
                    
        my $package_ref = 
            get_package_info_with_name($package,\%options,\@error_strings,$package_version);
        my $package_id = $$package_ref{id};
        
        # Insert into "Packages_rpmlists" table
        insert_pkg_rpmlist($xml_ref->{"binary-package-list"}, 
                            "Packages_rpmlists",
                            $package_id,
                            \%options,\@error_strings)
            if $xml_ref->{"binary-package-list"}; 
            
        # Insert into "Group_Packages" table at the initial process.
        # If a packaged is added with the arguments to this script, 
        # then initial process of oscar database is finished.
        # The newly downloaded packages is not determined to
        # add to the selected "Group" (i.e., Default).
        my %field_value_hash = ();
        if ( ! $directory_argument && !@nics_results ){
            %field_value_hash = ( "group_name"=>$DEFAULT,
                                  "package_id"=>"$package_id",
                                  "selected" => 1);
            push  @error_strings,
                 "Inserting $package with package_id ($package_id), group_name ($DEFAULT)"
                 . " and selected flag (1) into Group_Packages table";
            insert_into_table (\%options,"Group_Packages",\%field_value_hash,\@error_strings);
            @error_strings = ();
        }

        # Insert into "Packages_[conflicts|provides|requires]" table
        foreach my $tag ("conflicts", "provides", "requires"){
            if ( $xml_ref->{$tag} ){ 
                my $tag_ref = $xml_ref->{$tag};
                foreach my $each_tag (keys %$tag_ref){
                    if( $each_tag eq "name" || $each_tag eq "type" ){
                        %field_value_hash = ( "p1_id"=>"$package_id",
                                              "p2_name"=>$tag_ref->{name},
                                              "type"=>$tag_ref->{type} );
                        insert_into_table (\%options,"Packages_$tag",\%field_value_hash,\@error_strings);
                        last;
                    }else{    
                        # Handling a case when the conflicts tag is used more than one time.
                        %field_value_hash = ( "p1_id"=>"$package_id",
                                              "p2_name"=>$each_tag,
                                              "type"=>$tag_ref->{$each_tag}->{type} );
                        insert_into_table (\%options,"Packages_$tag",\%field_value_hash,\@error_strings);
                    }
                }
            }
        }

        # Insert into "Packages_servicelists" table
        if( $xml_ref->{servicelist} ){
            my $service_ref = $xml_ref->{servicelist};
            if( ref($service_ref) eq "ARRAY") {
                foreach my $ref (@$service_ref){
                    my $value = $ref->{service};
                    my $group = ($ref->{filter}->{group}?$ref->{filter}->{group}:"all");
                    %field_value_hash = ( "package_id"=>"$package_id",
                                          "group_name"=>$group,
                                          "service"=>$value);
                    insert_into_table (\%options,"Packages_servicelists",\%field_value_hash,\@error_strings);
                }
            }else{
                my $value = $service_ref->{service}; 
                my $group = ($service_ref->{filter}->{group}?$service_ref->{filter}->{group}:"all");
                %field_value_hash = ( "package_id"=>"$package_id",
                                      "group_name"=>$group,
                                      "service"=>$value);
                insert_into_table (\%options,"Packages_servicelists",\%field_value_hash,\@error_strings);
            }
        }    
            
        # Insert into "Packages_switcher" table
        if ($xml_ref->{"package-specific-attributes"}->{switcher}){
            my $switcher_name = $xml_ref->{"package-specific-attributes"}->{switcher}->{name};
            my $switcher_tag = $xml_ref->{"package-specific-attributes"}->{switcher}->{tag};
                %field_value_hash = ( "package_id"=>"$package_id",
                                      "switcher_name"=>$switcher_name,
                                      "switcher_tag"=>$switcher_tag );
            insert_into_table (\%options,"Packages_switcher",\%field_value_hash,\@error_strings);
        }
    }
}
print "\nDB_DEBUG>$0:\n===========================>>>>> Adding/Modifying entries of Packages related tables is finished\n"
    if $options{debug} || $options{verbose};

oda::oda_disconnect( \%options );
exit 0;

