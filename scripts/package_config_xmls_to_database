#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Copyright © 2003, The Board of Trustees of the University of Illinois. All rights reserved.
# Copyright 2003 NCSA
#                Neil Gorsuch <ngorsuch@ncsa.uiuc.edu>
# Copyright 2004 Revolution Linux
#           Benoit des Ligneris <bdesligneris@revolutionlinux.com>
# Copyright (c) 2005 The Trustees of Indiana University.  
#                    All rights reserved.
# Copyright (c) 2005 Bernard Li <bli@bcgsc.ca>.
#                    All rights reserved.
# Copyright (c) 2006 Erich Focht <efocht@hpce.nec.com>
#                    All rights reserved.
#       
# $Id$

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib","$ENV{OSCAR_HOME}/lib/OSCAR","../../../lib","../../../lib/OSCAR";
use OSCAR::Package;
use OSCAR::Network;
use Data::Dumper;
use XML::Simple;
use OSCAR::Distro;
use OSCAR::Database;

my $folding_character = "_";
my %list_of_multiple_value_folded_fields = ();
my %multiple_value_folded_fields = ();
my %oda_fieldnames = ();
my %oda_shortcuts = ();
my $package_tables_name_prefix = "package_";
my $packages_table_name = "packages";
my %single_value_folded_fields = ();
my $xml_file_name = "config.xml";

my @error_strings = ();
my %table_fields_hash = ();
my %oda_options = ( 'debug'        => 0,
                    'verbose'      => 0 );
my %options = (  'changes'      => 1,
                 'debug'        => 0,
                 'verbose'      => 0 );
my $DEFAULT = "Default";                 
# find the base directory of the oscar distribution,
my $oscar_home;
# first try the environmental variable
if ( exists $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
    die "$0: bad OSCAR_HOME environmental variable value <$oscar_home>"
    if ( ! -d "$oscar_home");
} else {
    die "\nEnvironment variable \$OSCAR_HOME is not set!\n";
}

print "$0: oscar_home=<$oscar_home>\n" if $options{debug};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("bundling");    # allow -a -b or -ab
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

# parse command line options
GetOptions( \%options,
        'changes!',
            'debug!',
            'help',
        'oda=s',
            'verbose!',
            'version' )
    || usage(1);
print "$0: after GetOptions ARGV=<@ARGV>\n" if $options{debug};
oda::print_hash( "", "$0: options after GetOptions", \%options)
    if $options{debug};

# function to convert an options hash into a string of
# appropriate oda command line options

sub options_to_string {
    my( $options_ref ) = @_;
    
    my $string = "";
    $string = "$string --database=$$options_ref{database}" 
    if exists $$options_ref{database};
    $string = "$string --debug" if $$options_ref{debug};
    $string = "$string --host=$$options_ref{host}"
    if exists $$options_ref{host};
    $string = "$string --host=$$options_ref{password}"
    if exists $$options_ref{password};
    $string = "$string --host=$$options_ref{port}"
    if exists $$options_ref{port};
    $string = "$string --host=$$options_ref{type}"
    if exists $$options_ref{type};
    $string = "$string --verbose" if $$options_ref{verbose};
    $string =~ s/^ //;
    return $string;
}

# function to do a debug print of a hash
# inputs: leading_spaces  string to put in front of lines
#         name            string to print as the hash name
#         hash_ref        pointer to the hash to print       

sub print_hash {
    my( $leading_spaces, $name, $hashref ) = @_;
    print "$0: $leading_spaces$name ->\n";
    foreach my $key ( sort keys %$hashref ) {
    my $value = $$hashref{$key};
    if (ref($value) eq "HASH") {
        print_hash(  "$leading_spaces    ", $key, $value );
    } elsif (ref($value) eq "ARRAY") {
        my $string = join(',', @$value);
        print "$0: $leading_spaces    $key => ($string)\n";
    } elsif (ref($value) eq "SCALAR") {
        print "$0: $leading_spaces    $key is a scalar ref\n";
        print "$0: $leading_spaces    $key => $$value\n";
    } else {
        $value = "undef" unless defined $value;
        print "$0: $leading_spaces    $key => <$value>\n";
    }
    }
}

sub get_xml_ref{
    my ($package_directory,
        $package_name,
        $msg) = @_;
    # if a config.xml file does not exist for this package directory,
    # we'll fake a simple one, otherwise read it in
    my $config_file = "$package_directory/$xml_file_name";
    my $xml_ref = undef;
    if ( ! -f $config_file ) {
        print "Warning, no $config_file exists, supplying one for package $package_name\n";
    } else {
        print "Processing $config_file for package $package_name ...\n$msg" if $msg;
        my $xs = new XML::Simple();
        $xml_ref = eval { $xs->XMLin( $config_file ); };
        if ($@) {
        print "ERROR, $config_file is invalid, supplying one for package $package_name\n";
            $xml_ref = undef;
        print "Trying to xmllint the $config_file to show problems:\n";
        system "xmllint $config_file";
        }
    }
    if ( ! defined $xml_ref ) {
        my %faked_xml;
        $faked_xml{class} = "third-party";
        $faked_xml{description} = "Not provided";
        $faked_xml{name} = $package_name;
        $faked_xml{summary} = "Not provided";
        $xml_ref = \%faked_xml;
    }
    if ( $options{debug} ) {
        print "$0: xml_ref:\n";
        print Dumper($xml_ref);
    }

    return $xml_ref;
}

sub is_installed {
    my ($package,
        $version) = @_;
    my $result_ref = get_package_info_with_name($package,
                        \%options,\@error_strings,$version);
    return ($result_ref?1:0);                    
}

sub delete_packages_related_table {
    my ($package,$options_ref,$error_ref,$package_version) = @_;
    my $where = "";
    my $package_ref = 
        get_package_info_with_name($package,
                                   $options_ref,
                                   $error_ref,
                                   $package_version);
    my $package_id = $$package_ref{id};

    my @list_of_tables = ("Packages_rpmlists", 
                          "Packages_conflicts", "Packages_provides",
                          "Packages_requires", "Packages_servicelists",
                          "Packages_switcher");
    foreach my $table_name (@list_of_tables){
        if ($table_name eq "Packages_conflicts" ||
            $table_name eq "Packages_provides" ||
            $table_name eq "Packages_requires"){
            $where = "WHERE p1_id='$package_id'";
        }else{
            $where = "WHERE package_id='$package_id'";
        }
        delete_table(\%options,$table_name, $where ,\@error_strings);
    }
    return $package_id;
}    

sub usage {
    my ( $exit_status, @error_strings ) = @_;
    my $progname = $0;
    print <<USAGE;

$progname [directory [ package_name [ package_version ] ] ]

$progname reads a $xml_file_name file for a single package
from a specified directory.  It parses database information
from that file, and stores it into the Oscar database.
Any previously existing database information for that
version of that package is removed from the database before 
inserting information from the $xml_file_name file.
The only database fields in the package records that are
preserved are: installable.

Options:
  --[no]changes     turns on[off] database changes, default is on
  --[no]debug       turns on[off] debug output, default is off
  --help            prints out usage information then exits
  --oda=OPTION(S)   specifies options to be passed to ODA
  --[no]verbose     turns on[off] verbose output, default is off

Usage:
$progname [options]

USAGE
    if ( @error_strings ) {
	print "\n";
	warn shift @error_strings while @error_strings;
    }
    exit $exit_status;
}

# --help flag just prints out usage information and exits
if ( exists $options{help} ) {
    usage( 0 );
}

my $directory_argument = shift @ARGV;
my $package_directory = $directory_argument;
$package_directory = `pwd` . "/$package_directory" 
    if $package_directory !~ /^\//;
$package_directory =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
$package_directory =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
$package_directory =~ s,/\./,/,g;                 # change /./       to /
$package_directory =~ s,/$,,;       # take / off the end
print "$0: package_directory=<$package_directory>\n" if $options{debug};

# there might be a package short name argument, if not,
# take the last portion of the directory path,
my $package_name;
if ( @ARGV ) {
    $package_name = shift @ARGV;
} else {
    $package_name = $package_directory;
    $package_name = $package_name . "/" if $package_name !~ /\/$/;
    $package_name =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
    $package_name =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
    $package_name =~ s,/\./,/,g;                 # change /./       to /
    $package_name =~ s,/$,,;       # take / off the end
    $package_name =~ s,^.*/,,;     # take */ off the beginning
}
print "$0: package_name=<$package_name>\n" if $options{debug};
usage(1,
      "Package name $package_name from directory $package_directory has to start with a letter" )
    if $package_name !~ /^[a-zA-Z]/;
usage(1,
      "Package name $package_name from directory $package_directory has illegal characters" )
    if $package_name !~ /^[a-zA-Z0-9][a-zA-Z0-9\.\_\-]*$/;

# and if there is a package short name argument, there
# might be a package version argument
my $package_version = "";
if ( @ARGV ) {
    $package_version = shift @ARGV;
}

# any arguments left is an error
usage( 1, "unknown argument(s) " . join( ' ', @ARGV ) ) if @ARGV;

my @base_directories = @OSCAR::Package::PKG_SOURCE_LOCATIONS;
if ( !($directory_argument && $package_name) ){

    # find the name of the mysql service and start the mysql server,
    # and make sure it is run on every system reboot
    my ($oscar_server_distribution,$oscar_server_distribution_version) = which_distro_server();
    my $mysql_service_name=which_mysql_name($oscar_server_distribution,$oscar_server_distribution_version);

    my $command="/etc/init.d/$mysql_service_name status";
    my @command_output = `$command`;
    my $status = $?;
    chomp @command_output;
    if ( ! grep( /is\ running/, @command_output ) || ! $status ) {
        print "Starting the mysql database server ...\n";
        my $command = "/etc/init.d/$mysql_service_name start";
        print "$command\n";
        if ( system( $command ) ) {
        my @error_strings = ();
        oda::oda_disconnect( \%options );
        warn shift @error_strings while @error_strings;
        die "$0: cannot start the mysql database server!";
        }
        sleep 2;
    }
    print "Making sure that the mysql database server starts on subsequent boots ...\n";
    my $command = "chkconfig $mysql_service_name on";
    print "$command\n";
    warn "$0: WARNING: the mysql database service may not start on subsequent reboots"
        if system( $command );
        
    # create the database if not already there and leave us connected to it
    my %databases = ();
    oda::list_databases( \%options, \%databases );
    if ( ! $databases{ oscar } ) {
        print "Creating the OSCAR database ...\n";
        my @error_strings = ();
        if ( ! oda::create_database( \%options,
                     \@error_strings ) ) {
        warn shift @error_strings while @error_strings;
        die "$0: cannot create the OSCAR database";
        }
        print "... OSCAR database successfully created.\n";
    }
    print "Searching these directories for packages:\n";
    foreach my $base_directory ( @base_directories ) {
        print "    $base_directory\n";
    }
}

if ( ! oda::oda_connect( \%options,
             \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
    die "$0: cannot connect to the OSCAR database";
}

# Initialize the oscar packages related database information by
# slurping in (or supplying default) package config.xml files
# for all packages that were supplied in the oscar tarball/rpm
# and that have been downloaded through opd before this.
# The config.xml file for oda is a special case and is always 
# read in first since it defines a number of database tables
# and is critical for oscar operations.
# First find the list of all the package directories,
# keeping a seperate list of the oda package directories
# (a newer version of the oda package might have been downloaded).
my @directories = ();
my @oda_directories = ();
my $msg = "";
my $xml_ref = undef;

if( $directory_argument ){
    push @directories, $package_directory;
}else{    
    foreach my $packages_base_directory ( @base_directories ) {
        opendir(PACKAGES, $packages_base_directory)
        || next;
        while ( my $package = readdir(PACKAGES) ) {
            chomp $package;
            if ( $package eq "oda" ) {
                push @oda_directories,
                "$packages_base_directory/$package";
            } 
            push @directories,
            "$packages_base_directory/$package";
        }
    }
    my @valid_oda_directories = ();
    foreach my $oda_directory ( @oda_directories ) {
        if ( ! -f "$oda_directory/$xml_file_name" ) {
        warn "$0: ignoring the invalid oda package directory $oda_directory" .
            " that does not contain a $xml_file_name file";
        } else {
        push @valid_oda_directories, $oda_directory;
        }
    }
    die "$0: cannot find any valid oda packages in these directories: @base_directories"
        if ! (@valid_oda_directories || @directories);
    my $oda_directory = pop @valid_oda_directories;
    foreach my $skipped_oda_directory ( @valid_oda_directories ) {
        warn "$0: ignoring oda package directory $skipped_oda_directory";
    }
    # Create oscar tables through the config.xml which contains the table information
    # If the table already exists, it will not be created again but
    # %table_fields_hash is updated everytime package_config_xmls_to_database runs.
    $xml_ref = get_xml_ref($oda_directory, "oda", $msg);
    foreach my $table_name (keys (%{$xml_ref->{database_tables}})){
        my $tmp_hash =  $xml_ref->{database_tables}->{$table_name};
        die "$0: cannot create a table, $table_name"
            if ! create_table($tmp_hash,$table_name,\%table_fields_hash,\%options, \@error_strings);
    }

}    

my %fields = ();
if ( (scalar keys %table_fields_hash) == 0 ){
    oda::list_fields(\%options,"Packages",\%fields,\@error_strings);
    my %packages_hash = %fields;
    foreach my $field (keys %packages_hash){
        if($field == "__group"){ $field = "group"; }
        if($field == "__class"){ $field = "class"; }
        $packages_hash{$field} = 1;
    }
    $table_fields_hash{"Packages"} = \%packages_hash;
}    

my @packages_in_db = get_packages(\%options,\@error_strings);
my %opkg_to_be_deleted = ();
foreach my $key_package (@packages_in_db){
    $opkg_to_be_deleted{$key_package} = 1;
}    

foreach my $directory ( @directories ) {
    my $package = $directory;
    $package =~ s,^.*/,,;
    if ( -d $directory &&
         $package ne "." &&
         $package ne ".." &&
         $package ne "CVS" &&
         $package ne ".svn" &&
         ! -e "$directory/.oscar_ignore" ) {

        # Assign 1 to %opkg_to_be_deleted if $package is already in the DB
        # ,which means it($package) should be kept.
        # The rest of packages with 1 in %opkg_to_be_deleted will be removed
        $opkg_to_be_deleted{$package} = 0 if $opkg_to_be_deleted{$package};
         
        print "$0: package=<$package>\n" if $options{debug};
        $msg = "";
        $xml_ref = get_xml_ref($directory, $package,$msg);
        if( is_installed($package,$package_version) ){
            my $package_id = delete_packages_related_table($package,\%options,\@error_strings,$package_version);
            update_packages($xml_ref, "Packages", $package_id, $package, 
                            $directory, \%table_fields_hash, \%options, \@error_strings);
            $msg = "Modifying existing $packages_table_name record for package";
        }else{
            $msg = "Writing a new $packages_table_name record for package";

            print Dumper(\%table_fields_hash) if $options{debug};
            print_hash("", "Print the package $xml_file_name", $xml_ref)
                if $options{debug};
                    
            # Insert into "Packages" table
            insert_packages($xml_ref, "Packages", $package, $directory,
                            \%table_fields_hash, \%options, \@error_strings);
        }        
    }
}

my @nics_results = ();
my $server_node = "oscar_server";

# Determine if it is the first time installation or not.
# If nics table is already filled in, this is not first time installation
# and skip the process of inserting into the Group_Packages table.
get_nics_info_with_node($server_node,\@nics_results,\%options,\@error_strings);

# Delete the packages to be deleted when there is no $directory_argument,
# which means it is a call from normal installation but not from OPD.
# This needs to clean the tables related to Packages too.
if(!$directory_argument){
    foreach my $pkg (keys %opkg_to_be_deleted){
        if($opkg_to_be_deleted{$pkg} == 1){
            delete_packages_related_table($pkg,\%options,\@error_strings,$package_version);
            delete_package($pkg,\%options,\@error_strings);
        }
    }    
}

foreach my $directory ( @directories ) {
    my $package = $directory;
    $package =~ s,^.*/,,;
    if ( -d $directory &&
         $package ne "." &&
         $package ne ".." &&
         $package ne "CVS" &&
         $package ne ".svn" &&
         ! -e "$directory/.oscar_ignore" ) {
        print "$0: package=<$package>\n" if $options{debug};
        my $each_msg = $msg . " $package ".($package_version?"$package_version\n":"\n");
        $xml_ref = get_xml_ref($directory, $package,$each_msg);
        my $package_ref = 
            get_package_info_with_name($package,\%options,\@error_strings,$package_version);
        my $package_id = $$package_ref{id};
        
        # Insert into "Packages_rpmlists" table
        insert_pkg_rpmlist($xml_ref->{"binary-package-list"}, "Packages_rpmlists", $package_id)
            if $xml_ref->{"binary-package-list"}; 
            
        # Insert into "Group_Packages" table at the initial process.
        # If a packaged is added with the arguments to this script, 
        # then initial process of oscar database is finished.
        # The newly downloaded packages is not determined to
        # add to the selected "Group" (i.e., Default).
        my %field_value_hash = ();
        if ( ! $directory_argument && !@nics_results ){
            %field_value_hash = ( "group_name"=>$DEFAULT,
                                  "package_id"=>"$package_id",
                                  "selected" => 1);
            insert_into_table (\%options,"Group_Packages",\%field_value_hash,\@error_strings);
        }

        # Insert into "Packages_[conflicts|provides|requires]" table
        foreach my $tag ("conflicts", "provides", "requires"){
            if ( $xml_ref->{$tag} ){ 
                my $tag_ref = $xml_ref->{$tag};
                foreach my $each_tag (keys %$tag_ref){
                    if( $each_tag eq "name" || $each_tag eq "type" ){
                        %field_value_hash = ( "p1_id"=>"$package_id",
                                              "p2_name"=>$tag_ref->{name},
                                              "type"=>$tag_ref->{type} );
                        insert_into_table (\%options,"Packages_$tag",\%field_value_hash,\@error_strings);
                        last;
                    }else{    
                        # Handling a case when the conflicts tag is used more than one time.
                        %field_value_hash = ( "p1_id"=>"$package_id",
                                              "p2_name"=>$each_tag,
                                              "type"=>$tag_ref->{$each_tag}->{type} );
                        insert_into_table (\%options,"Packages_$tag",\%field_value_hash,\@error_strings);
                    }
                }
            }
        }

        # Insert into "Packages_servicelists" table
        if( $xml_ref->{servicelist} ){
            my $service_ref = $xml_ref->{servicelist};
            if( ref($service_ref) eq "ARRAY") {
                foreach my $ref (@$service_ref){
                    my $value = $ref->{service};
                    my $group = ($ref->{filter}->{group}?$ref->{filter}->{group}:"all");
                    %field_value_hash = ( "package_id"=>"$package_id",
                                          "group_name"=>$group,
                                          "service"=>$value);
                    insert_into_table (\%options,"Packages_servicelists",\%field_value_hash,\@error_strings);
                }
            }else{
                my $value = $service_ref->{service}; 
                my $group = ($service_ref->{filter}->{group}?$service_ref->{filter}->{group}:"all");
                %field_value_hash = ( "package_id"=>"$package_id",
                                      "group_name"=>$group,
                                      "service"=>$value);
                insert_into_table (\%options,"Packages_servicelists",\%field_value_hash,\@error_strings);
            }
        }    
            
        # Insert into "Packages_switcher" table
        if ($xml_ref->{"package-specific-attributes"}->{switcher}){
            my $switcher_name = $xml_ref->{"package-specific-attributes"}->{switcher}->{name};
            my $switcher_tag = $xml_ref->{"package-specific-attributes"}->{switcher}->{tag};
                %field_value_hash = ( "package_id"=>"$package_id",
                                      "switcher_name"=>$switcher_name,
                                      "switcher_tag"=>$switcher_tag );
            insert_into_table (\%options,"Packages_switcher",\%field_value_hash,\@error_strings);
        }
    }
}


oda::oda_disconnect( \%options );
exit 0;

