#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Copyright 2002 NCSA
#                Neil Gorsuch <ngorsuch@ncsa.uiuc.edu>

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib","$ENV{OSCAR_HOME}/lib/OSCAR","../../../lib","../../../lib/OSCAR";
use OSCAR::Package;
use OSCAR::Network;
use oda;
use Data::Dumper;
use OSCAR::Distro;

my $folding_character = "_";
my %list_of_multiple_value_folded_fields = ();
my %multiple_value_folded_fields = ();
my %oda_fieldnames = ();
my %oda_shortcuts = ();
my %options = ();
my $package_tables_name_prefix = "package_";
my $packages_table_name = "packages";
my %single_value_folded_fields = ();


my ($distro,$version) = which_distro_server();
my $mysql_service_name;
if ($distro eq "RedHat") {
    $mysql_service_name="mysqld";
}
elsif ($distro eq "Mandrake") {
    $mysql_service_name="mysql";
}

# function to create a database table with the
# proper field definitions if the table doesn't
# already exist, or add any missing fields
# if the table already exists.
#
# inputs:  options_ref       pointer to command option parameters
#                            hash to pass to oda functions
#          table_name        string 
#          fields_params_ref pointer to a hash of the
#                            wanted field names and parameters

sub make_fix_table_fields{
    my ( $options_ref,
	 $table_name, 
	 $table_parameters,
	 $fields_params_ref ) = @_;

    print_hash( "", "$0: in make_fix_table_fields table_name=<$table_name> fields_params=",
		$fields_params_ref )
	if $$options_ref{debug};

    # get a list of the tables and fields
    # that are already in the database
    my @error_strings = ();
    my $existing_tables_fields_ref = 
      oda::list_tables_fields( $options_ref,
			       \@error_strings );
    warn shift @error_strings while @error_strings;

    # check if the table in question exists
    if ( ! exists $$existing_tables_fields_ref{ $table_name } ) {
	print "Creating database table $table_name\n";
	print_hash( "", "in make_fix_table_fields adding table <$table_name> fields=",
		    $fields_params_ref ) if $$options_ref{debug};
	@error_strings = ();
	if ( ! oda::create_table( $options_ref,
				  $table_name,
				  $table_parameters,
				  $fields_params_ref,
				  \@error_strings ) ) {
	    oda::disconnect( $options_ref,
			     \@error_strings );
	    warn shift @error_strings while @error_strings;
	    exit 1;
	  }
#	$existing_tables_fields_ref = 
#	  oda::list_tables_fields( $options_ref,
#				   \@error_strings );
#	my %table_hash = ();
#	$$existing_tables_fields{ $table_name } = \%table_hash;
    } else {
	my $table_hash_ref = $$existing_tables_fields_ref{ $table_name };
	foreach my $field_name ( sort keys %$fields_params_ref ) {
	    if ( ! exists $$table_hash_ref{ $field_name } ) {
		print "Adding to database table $table_name field $field_name" .
		    (( exists $$fields_params_ref{$field_name} &&
		       $$fields_params_ref{$field_name} ne "" ) ?
		     " with parameters $$fields_params_ref{$field_name}" : "" ) .
		     "\n";
		my %new_field;
		$new_field{ $field_name } =
		    $$fields_params_ref{ $field_name };
		my @error_strings = ();
		if ( ! oda::add_fields( $options_ref,
					$table_name,
					\%new_field,
					\@error_strings ) ) {
		    oda::disconnect( $options_ref,
				     \@error_strings );
		    warn shift @error_strings while @error_strings;
		    exit 1;
	        }
	    }
	}
    }
}

# function to do a debug print of a hash
# inputs: leading_spaces  string to put in front of lines
#         name            string to print as the hash name
#         hash_ref        pointer to the hash to print       

sub print_hash {
    my( $leading_spaces, $name, $hashref ) = @_;
    print "$0: $leading_spaces$name ->\n";
    foreach my $key ( sort keys %$hashref ) {
	my $value = $$hashref{$key};
	if (ref($value) eq "HASH") {
	    print_hash(  "$leading_spaces    ", $key, $value );
	} elsif (ref($value) eq "ARRAY") {
	    my $string = join(',', @$value);
	    print "$0: $leading_spaces    $key => ($string)\n";
	} elsif (ref($value) eq "SCALAR") {
	    print "$0: $leading_spaces    $key is a scalar ref\n";
	    print "$0: $leading_spaces    $key => $$value\n";
	} else {
	    $value = "undef" unless defined $value;
	    print "$0: $leading_spaces    $key => <$value>\n";
	}
    }
}

# note that this will leave arrays of hash references
# in the output tree unchanged (without unfolding)

sub recursive_fold_fields{
    my ( $options_ref,
	 $single_values_ref, 
	 $multiple_values_ref,
	 $level_ref, 
	 $input_ids_list_ref ) = @_;
    foreach my $level_key ( sort keys %$level_ref ) {
	my $level_value = $$level_ref{$level_key};
	my $folded_fields_id = join( '_', 
				     @$input_ids_list_ref,
				     $level_key );
	if ( ref( $level_value ) eq "HASH" ) {
	    my @ids_list = ( @$input_ids_list_ref,
			     $level_key );
	    recursive_fold_fields( $options_ref,
				   $single_values_ref,
				   $multiple_values_ref,
				   $level_value, 
				   \@ids_list );
	} elsif ( ref( $level_value ) eq "ARRAY" ) {
	    print "$0: adding folded field <$folded_fields_id> value <$level_value> to multiple values tables\n"
		if $$options_ref{debug};
	    $$multiple_values_ref{ $folded_fields_id } =
		$level_value;
	    $list_of_multiple_value_folded_fields
	    { $folded_fields_id } = 1;
	} else {
	    $$single_values_ref{ $folded_fields_id } =
		$level_value;
	}
	delete $$level_ref{$level_key};
    }
}

sub usage {
    my ( $exit_status, @error_strings ) = @_;
    my $progname = $0;
    print <<USAGE;

$progname reads the package configuration XML files
that reside in the OSCAR_INSTALL_BASE/packages/*
directories, and makes or updates the oda database.
Already existing records and fields are not modified.

Options:
  --debug             turns on debug output
  --database=DATABASE database name, default is oscar
  --help              prints out usage information then exits
  --host=HOST         database host, default localhost
  --nodebug           turns off debug output
  --password=PASSWORD database password, default allows access
  --port=PORT         database port number, default 3306
  --noverbose         turns off verbose output
  --type=DATABASETYPE set the database type, default is mysql
  --user USER         database user id, default anonymous if non-root
  --verbose           turns on verbose output

Usage:
$progname [options]

USAGE
    if ( @error_strings ) {
	print "\n";
	warn shift @error_strings while @error_strings;
    }
    exit $exit_status;
}

# find the base directory of the oscar distribution,
my $oscar_home;
# first try the environmental variable
if ( exists $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
    die "Bad OSCAR_HOME environmental variable value <$oscar_home>"
	if ( ! -d "$oscar_home");
} 
# then try to figure out the directory this program was run from
else {
    $oscar_home = $0;
    my $cwd = `pwd`;
    chomp $cwd;
    $oscar_home = $cwd . '/' . $oscar_home
	if $oscar_home !~ /^\//;   # prepend current dir if not abs
    $oscar_home =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
    $oscar_home =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
    $oscar_home =~ s,/\./,/,g;                 # change /./       to /
    $oscar_home =~ s,/packages/[^/]+/scripts/,/,g;
    $oscar_home =~ s,/[^/]+$,,;  # Remove the name of the program
    die "Bad calculated oscar base directory <$oscar_home>"
	if ( ! -d "$oscar_home");
    $ENV{OSCAR_HOME} = $oscar_home;
}
print "$0: oscar_home=<$oscar_home>\n" if $options{debug};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("bundling");    # allow -a -b or -ab
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

# set default option values
my %options = ( 'debug'       => 0,
                'verbose'     => 0 );

# parse command line options
GetOptions( \%options,
            'debug!',
            'database|d=s',
            'help',
            'host|h=s',
            'password=s',
            'port|p=i',
            'type|t=s',
            'user|u=s',
            'verbose!',
            'version' )
    || usage(1);
print "$0: after GetOptions ARGV=<@ARGV>\n" if $options{debug};
oda::print_hash( "", "$0: options after GetOptions", \%options) if $options{debug};

# --help flag just prints out usage information and exits
if ( exists $options{help} ) {
    usage( 0 );
}

# any arguments left is an error
usage( 1 ) if @ARGV;

# start the mysql server
my $command="LC_ALL=EN;/etc/init.d/$mysql_service_name status";
#print $command;
my @command_output = `$command`;
chomp @command_output;
if ( ! grep( /is\ running/, @command_output ) ) {
    print "Starting the mysql database server ...\n";
    my $command = "LC_ALL=EN;/etc/init.d/$mysql_service_name start";
    print "$command\n";
    if ( system( $command ) ) {
	my @error_strings = ();
	oda::disconnect( \%options );
	warn shift @error_strings while @error_strings;
	die "Cannot start the mysql database server!";
    }
    sleep 2;
}
    
# create the database if not already there and leave us connected to it
my %databases = ();
oda::list_databases( \%options, \%databases );
if ( ! $databases{ oscar } ) {
    print "Creating the OSCAR database ...\n";
    my @error_strings = ();
    if ( ! oda::create_database( \%options,
				 \@error_strings ) ) {
	warn shift @error_strings while @error_strings;
	die "Cannot create the OSCAR database";
    }
    print "... OSCAR database successfully created.\n";
}
my @error_strings = ();
if ( ! oda::connect( \%options,
		     \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
    die "Cannot connect to the OSCAR database";
}

# slurp in all the package xml files
#
# The called function reads in all the packages/*PKG*/config.xml 
# files, and outputs a hash of the database fields and value.
# For instance if there are two package config.xml files, one
# named packages/packdir1/config.xml like this:
#
# <oscar>
#   <name>first package</name>
#   <version>
#     <major>17</major>
#     <minor>2</minor>
#   </version>
#   <package>
#     <oda>
#       <shortcut> abcde fgh ij </shortcut>
#       <shortcut> kl mnop qrst </shortcut>
#       <fieldnames> packages_rpmlist scope </fieldnames>
#     </oda>
#   </package>
# </oscar>
#
# and another one named packages/packdir2/config.xml like this:
#
# <oscar>
#   <name>second package</name>
#   <class>core</class>
#   <rpmlist>
#     <all>
#       <rpm>pack2-rpm-1</rpm>
#       <rpm>pack2-rpm-2</rpm>
#       <rpm>pack2-rpm-3</rpm>
#     </all>
#     <server>
#       <rpm>pack2-rpm-4</rpm>
#       <rpm>pack2-rpm-5</rpm>
#     </server>
#   </rpmlist>
#   <package>
#     <packdir1>
#       <tag>tag1</tag>
#       <name>long-tag-1</name>
#     </packdir1>
#   </package>
# </oscar>
#
# then the returned hash pointed to by $xml_ref will look like this:
#
# {
#   'packdir1' -> {
#                   'name' -> 'first package',
#                   'package' => {
#                                    'oda' => {
#                                               'fieldnames' => [
#                                                                 ' packages_rpmlist scope '
#                                                               ],
#                                               'shortcut' => [
#                                                               ' abcde fgh ij ',
#                                                               ' kl mnop qrst '
#                                                             ],
#                                             }
#                   'version' -> {
#                                  'major' -> '17',
#                                  'minor' -> '2',
#                                }
#                 }
#   'packdir2' -> {
#                   'class' -> 'core',
#                   'name' -> 'second package',
#                   'package' -> {
#                                  'packdir1' -> {
#                                                  'tag' -> 'tag1',
#                                                  'name' -> 'long-tag-1'
#                                                }
#                                }
#                   'rpmlist' -> {
#                                  'all' -> {
#                                             'rpm' -> [
#                                                        'pack2-rpm-1',
#                                                        'pack2-rpm-2',
#                                                        'pack2-rpm-3'
#                                                      ]
#                                           },
#                                  'server' -> {
#                                                'rpm' -> [
#                                                           'pack2-rpm-4',
#                                                           'pack2-rpm-5'
#                                                         ]
#                                              }
#                                }
#                 }
# }
#
# Note that the rpmlist ended up being a list at the end of the tree
# rather than a hash because these field names are hard-coded in
# other portions of the oscar wizard to do that:
#    (have to find list)

print "Reading and parsing package config.xml files ...";
my $xml_ref = pkg_config_xml();
#die "Cannot read package XML config files" if ! defined $xml_ref;
print " done\n";
if ( $options{debug} ) {
    print "$0: xml_ref:\n";
    print Dumper($xml_ref);
}

# Recursively loop through the xml config files hash, 
# finding all package->'package'->'oda'->'fieldnames' 
# and all package->'package'-> information, storing 
# it in oda_fieldnames and oda_shortcuts hashes, 
# swallowing it. The above example would end up
# with this in the oda_fieldnames hash:
#
# {
#   'packages_rpmlist' -> 'scope'
# }
#
# and this in the oda_shortcuts hash:
# {
#   'abcde' -> 'fgh ij',
#   'kl' -> 'mnop qrst'
# }
#
foreach my $package_name ( sort keys %$xml_ref ) {
    print "$0: looking for special oda data in xml for package <$package_name>\n" 
	if $options{debug};
    my $xml_package_ref = $$xml_ref{$package_name};
    # if there is a 'packages' key in that, ...
    if ( exists $$xml_package_ref{package} ) {
	my $xml_package_package_ref = $$xml_package_ref{package};
	# if there is an 'oda' key in that, ...
	if ( exists $$xml_package_package_ref{oda} ) {
	    print "$0: found oda package information in package <$package_name>\n"
		if $options{debug};
	    my $oda_stuff_ref =	$$xml_package_package_ref{oda};
	    # if there are shortcuts, store them
	    if ( exists $$oda_stuff_ref{shortcut} ) {
		my $shortcuts_ref =
		    $$oda_stuff_ref{shortcut};
		print( "$0: found oda shortcuts information\n" )
		    if $options{debug};
		foreach my $shortcut_line ( @$shortcuts_ref ) {
		    # parse out leading word and use it for the shortcut name
		    my @fields = grep( !/^$/, 
				       split( /\s+/, $shortcut_line ) );
		    my $shortcut = shift @fields;
		    my $expansion = join( ' ', @fields );
		    print "$0: found shortcut=<$shortcut> value=<$expansion>\n"
			if $options{debug};
		    # store the shortcut if not already stored
		    if ( ! exists $oda_shortcuts{$shortcut} ) {
			$oda_shortcuts{$shortcut} = $expansion;
		    } else {
			warn "$0: duplicated oda shortcut <$shortcut> specified,\n";
			warn "ignoring value <$expansion> specified by <$package_name>\n";
			warn "leaving value as previous value <$oda_shortcuts{$shortcut}>,\n";
		    }
		}
		# now swallow the data from the parsed xml
		delete $$oda_stuff_ref{shortcuts};
	    }
	    # if there are fieldname specifiers, store them
	    if ( exists $$oda_stuff_ref{fieldnames} ) {
		my $fieldnames_ref = $$oda_stuff_ref{fieldnames};
		print( "$0: found oda fieldnames information\n" )
		    if $options{debug};
		foreach my $fieldnames ( @$fieldnames_ref ) {
		    print "$0: processing fieldnames data <$fieldnames>\n"
			if $options{debug};
		    # parse out leading word and use it for the fieldnames table name
		    my @fieldnames_fields = grep( !/^$/, 
				      split( /\s+/, $fieldnames ) );
		    my $fieldnames_table = shift @fieldnames_fields;
		    # make sure someone else didn't alread define this one
		    if ( ! exists $oda_fieldnames{$fieldnames_table} ) {
			print "$0: storing fieldnames table=<$fieldnames_table> fields=<@fieldnames_fields>\n"
			    if $options{debug};
			$oda_fieldnames{$fieldnames_table} = \@fieldnames_fields;
		    } elsif ( $package_name eq "oda" ) {
			warn "$0: duplicated oda fieldnames <$fieldnames_table> specified,\n";
			warn "previous value was <$oda_fieldnames{$fieldnames_table}>,\n";
			warn "over-riding with oda value <@fieldnames_fields>\n";
			$oda_fieldnames{$fieldnames_table} = \@fieldnames_fields;
		    } else {
			warn "$0: duplicated oda fieldnames <$fieldnames_table> specified,\n";
			warn "ignoring value <@fieldnames_fields> specified by <$package_name>\n";
			warn "leaving value as previous value <$oda_fieldnames{$fieldnames_table}>,\n";
		    }
		}
		# now swallow the data from the parsed xml
		delete $$oda_stuff_ref{fieldnames};
	    }
	}
    }
} # end looping through xml package sections
if ( $options{debug} ) {
    print_hash( "", "$0: oda_shortcuts", \%oda_shortcuts );
    print_hash( "", "$0: oda_fieldnames", \%oda_fieldnames );
}

# Database tables and field names can be explictly 
# defined in package config.xml files, like this:
#
# <oscar>
#   ...
#   <tables>
#     <name1>
#       <fields>
#          <field11> </field11>
#          <field12> </field12>
#       </fields>
#     </name1>
#   </tables>
#   <package>
#     <tables>
#       <name2>
#         <fields>
#            <field13>
#              <attribute1> value1 </attribute1>
#            </field13>
#            <field14> </field14>
#            <field15> </field15>
#         </fields>
#       </name2>
#     </tables>
#   </package>
#   ...
# <oscar>
#
# Only the oda config.xml file can use the first form
# that has tables defined outside the <package> block.
# Table definitions inside the <package> block cause
# the package name to be prepended to the table name.
# For example, if the oda config.xml file looked like
# the above example, database tables with these fields
# would be created:
#
#    table               fields names ...
#
#    name1               field11 field12
#    package_oda_name2   field13 field14 field15
#
# Scan through the $xml_ref pointed to hash,
# storing explicit table/field definitions,
# removing them from the hash.

print "Looking for explicitly defined database tables and fields ...\n";
foreach my $package_name ( sort keys %$xml_ref ) {
    print "$0: looking for explicit table/field definitions in package <$package_name>\n" 
	if $options{debug};
    my $package_ref = $$xml_ref{$package_name};
    # if there is a 'tables' key in that, ...
    if ( exists $$package_ref{database_tables} ) {
	my $tables_ref = $$package_ref{database_tables};
	if ( $package_name ne 'oda' ) {
	    warn "The config.xml file for package $package_name cannot create\n"
		. "database tables using a <tables> </tables> block except inside\n"
		. "a <package> </package> block. Only the oda package\'s config.xml\n"
		. "can do this. These database tables will not be created:\n"
		. join(' ', sort keys %$tables_ref ) . "\n";
	} else {
	    foreach my $table_name ( sort keys %$tables_ref ) {
		print "$0: found explicit table <$table_name> definition in $package_name config.xml\n"
		    if $options{debug};
		my $table_ref = $$tables_ref{$table_name};
		# if there is a <fields> ... </fields> block
		# inside this <table> ... </table> block, ...
		if ( exists $$table_ref{fields} ) {
		    my $table_fields_ref = $$table_ref{fields};
		    print_hash( "", "$0: for table $table_name table_ref", $table_ref ) if $options{debug};
		    my %table_fields = ();
		    foreach my $field_name ( sort keys %$table_fields_ref ) {
			my $table_field_ref = $$table_fields_ref{$field_name};
			print "$0: found explicit field   <$field_name> definition in $package_name config.xml\n"
			    if $options{debug};
			$table_fields{$field_name} = 
			    ( ref($table_fields{$field_name}) eq "HASH" ) ?
			    "VARCHAR(250)" : $$table_fields_ref{$field_name};
		    }
		    my $table_parameters = 
			( exists $$table_ref{parameters} ) ?
			    $$table_ref{parameters} : undef;
		    make_fix_table_fields( \%options,
					   "$table_name",
					   $table_parameters,
					   \%table_fields );
		} else {
		    warn "The config.xml file for package $package_name is trying\n"
			. "to define a database table named $table_name using a\n"
			. "<tables> </tables> block without having any fields\n"
			. "defined inside that using <field> </field> blocks.\n"
			. "The database table $table_name will not be created.\n";
		}
	    }
	}
	delete $$package_ref{database_tables};
    }
    if ( exists $$package_ref{package} ) {
	my $package_package_ref = $$package_ref{package};
	if ( exists $$package_package_ref{database_tables} ) {
	    my $tables_ref = $$package_package_ref{database_tables};
	    foreach my $table_name ( sort keys %$tables_ref ) {
		my $full_table_name = "package" . $package_name . "_" . $table_name;
		print "$0: found explicit table <$full_table_name> definition in $package_name config.xml\n"
		    if $options{debug};
		my $table_ref = $$tables_ref{$table_name};
		# if there is a <fields> ... </fields> block 
		# inside this <table> ... </table> block, ...
		if ( exists $$table_ref{fields} ) {
		    my $table_fields_ref = $$table_ref{fields};
		    print_hash( "", "$0: for table $table_name table_ref", $table_ref ) if $options{debug};
		    my %table_fields = ();
		    foreach my $field_name ( sort keys %$table_fields_ref ) {
			my $table_field_ref = $$table_fields_ref{$field_name};
			print "$0: found explicit field   <$field_name> definition in $package_name config.xml\n"
			    if $options{debug};
			$table_fields{$field_name} = 
			    ( ref($table_fields{$field_name}) eq "HASH" ) ?
			    "VARCHAR(250)" : $$table_fields_ref{$field_name};
		    }
		    my $table_parameters = 
			( exists $$table_ref{parameters} ) ?
			    $$table_ref{parameters} : undef;
		    make_fix_table_fields( \%options,
					   "$full_table_name",
					   $table_parameters,
					   \%table_fields );
		} else {
		    warn "The config.xml file for package $package_name is trying\n"
			. "to define a database table named $full_table_name using a\n"
			. "<tables> </tables> block without having any fields\n"
			. "defined inside that using <field> </field> blocks.\n"
			. "The database table $full_table_name will not be created.\n";
		}
	    }
	}
	delete $$package_ref{database_tables};
    }
}

# Scan through the config files hash pointed to by
# $xml_ref, converting this kind of information:
#
# package1 ->
#    field1 ->
#        subname1 ->
#            subsubname1 -> value1
#            subsubname2 -> value2
#        subname3 -> value3
#        subname4 -> (value4,value5,value6)
#    field2 ->
#        subname5 ->
#            subsubname3 -> (value7,value8)
# package2 ->
#    field3 ->
#        subname6 -> value9
#    field4 -> (
#                [ subname7 -> value10
#                  subname8 -> value10 ]
#               ,
#                [ subname9 -> value11
#                  subname10 -> value12 ]
#              )
#
# into the %single_value_folded_fields hash as:
#
# package1 ->
#    field1_subname1_subsubname1 -> value1
#    field1_subname1_subsubname2 -> value2
#    field1_subname3 -> value3
# package2 ->
#    field3_subname6 -> value9
#
# and into %multiple_value_folded_fields hash as:
#
# package1 ->
#    field1_subname4 -> (value4,value5,value6)
#    field2_subname5_subsubname3 -> (value7,value8)
# package2 ->
#    field4 -> ( HASHsubnames7and8, HASHsubnames9and10 )
#
# and with a flag hash %list_of_multiple_value_folded_fields:
#
# field1_subname4 -> 1
# field2_subname5_subsubname3 -> 1

print "Looking for database table <packages> implictly defined fields ... \n";

# Go through the config go through all of the parsed package config xml files
# hash, for each package have another level of hashes,
# for each combined field id put it in either the single
# values table or the multiple values table
foreach my $package_name ( sort keys %$xml_ref ) {
    print "$0: folding fields in xml data for package <$package_name>\n" 
	if $options{debug};
    my @field_ids_list = ();
    my %package_single_value_folded_fields = ();
    $single_value_folded_fields{ $package_name } =
	\%package_single_value_folded_fields;
    my %package_multiple_value_folded_fields = ();
    $multiple_value_folded_fields{ $package_name } =
	\%package_multiple_value_folded_fields;
    recursive_fold_fields( \%options,
			   \%package_single_value_folded_fields,
			   \%package_multiple_value_folded_fields,
			   $$xml_ref{$package_name},
			   \@field_ids_list );
}

# go through all the single value fields, and if 
# another package had multiple values for the
# same field, move the single value field to the
# multiple value fields tables
foreach my $package_name ( sort keys %$xml_ref ) {
    my $package_folded_single_values_ref = 
	$single_value_folded_fields{ $package_name };
    my $package_folded_multiple_values_ref = 
	$multiple_value_folded_fields{ $package_name };
    foreach my $folded_field_id ( sort keys %$package_folded_single_values_ref ) {
	if ( $list_of_multiple_value_folded_fields{ $folded_field_id } ) {
	    print "$0: moving package <$package_name> folded field <$folded_field_id> to multiple values tables\n"
		if $options{debug};
	    my @folded_values_list = 
		$$package_folded_single_values_ref{ $folded_field_id };
	    $$package_folded_multiple_values_ref{ $folded_field_id } =
		\@folded_values_list;
	    delete $$package_folded_single_values_ref{ $folded_field_id };
	}
    }
}
if ( $options{debug} ) {
    print_hash( "", "$0: single_value_folded_fields",
		\%single_value_folded_fields );
    print_hash( "", "$0: list_of_multiple_value_folded_fields",
		\%list_of_multiple_value_folded_fields );
    print "$0: multiple_value_folded_fields:\n";
    print Dumper( \%multiple_value_folded_fields );
}

# store any found shortcuts in the database
print "Looking for database shortcut definitions ...\n";
my %shortcuts_fields = ();
$shortcuts_fields{ shortcut } = "VARCHAR(250)";
$shortcuts_fields{ expansion } = "VARCHAR(250)";
make_fix_table_fields( \%options,
		       "oda_shortcuts",
		       undef,
		       \%shortcuts_fields );
my $shortcuts_table_name = "oda_shortcuts";
foreach my $shortcut ( sort keys %oda_shortcuts ) {
    my @tables_fields = ( "$shortcuts_table_name", "shortcut", "expansion" );
    my @wheres = ( "$shortcuts_table_name.shortcut = \"$shortcut\"" );
    my @already_existing_records = ();
    my @error_strings = ();
    if ( ! oda::read_records( \%options,
			      \@tables_fields,
			      \@wheres,
			      \@already_existing_records,
			      1 ) ) {
	oda::disconnect( \%options,
			 \@error_strings );
	warn shift @error_strings while @error_strings;
	exit 1;
    }
    if ( @already_existing_records ) {
	my $hash_ref = shift @already_existing_records;
	if ( ! ( exists $$hash_ref{ expansion } &&
		 $$hash_ref{ expansion } eq $oda_shortcuts{ $shortcut } ) ) {
	    print "Updating shortcut $shortcut\n";
	    my @tables = ( "$shortcuts_table_name" );
	    my @assigns = ( "$shortcuts_table_name.expansion~$oda_shortcuts{$shortcut}" );
	    my @wheres = ( "$shortcuts_table_name.shortcut = \"$shortcut\"" );
	    my @error_strings = ();
	    if ( ! oda::modify_records( \%options,
					\@tables,
					\@assigns,
					\@wheres,
					\@error_strings ) ) {
		warn shift @error_strings while @error_strings;
	    }
	}
    } else {
	print "Creating shortcut $shortcut\n";
	my %assigns = ();
	$assigns{ shortcut } = "$shortcut";
	$assigns{ expansion } = $oda_shortcuts{$shortcut};
	my @error_strings = ();
	if ( ! oda::insert_record( \%options,
				   $shortcuts_table_name,
				   \%assigns,
				   undef,
				   \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	}
    }
}

# Database tables that are for a particular package
# were put into the package's config.xml file like this:
#
# config.xml file for mpich:
# <oscar>
#   <package>
#     <switcher>
#       <tag>mpi</tag>
#       <name>mpich-1.2.4</name>
#     </switcher>
#   </package>
# </oscar>
# config.xml file for lam:
# <oscar>
#   <package>
#     <switcher>
#       <tag>mpi</tag>
#       <name>lam-6.5.7</name>
#     </switcher>
#   </package>
# </oscar>
#
# This made single_value_folded_fields entries like this:
#
# mpich->
#    package_switcher_name -> <mpich-1.2.4>
#    package_switcher_tag -> <mpi>
# lam->
#    package_switcher_name -> <lam-6.5.7>
#    package_switcher_tag -> <mpi>
#
# These need to be deleted from single_value_folded_fields
# and produce database tables such as package_switcher in 
# this example which would have these fields and records:
#
# package  tag      name
#
#  mpich   mpi   mpich-1.2.4
#   lam    mpi    lam-6.5.7

# scan through the parsed config.xml files hash 
# and find the table names and fields for each
# table for the package specific database tables
print "Looking for package specific database tables and fields ...\n";
my %package_specific_tables_fields = ();
foreach my $package_name ( sort keys %single_value_folded_fields ) {
    my $package_folded_single_values_ref = 
	$single_value_folded_fields{ $package_name };
    foreach my $folded_field_id ( sort keys %$package_folded_single_values_ref ) {
	# if this is a "package_*_" type field, ...
	if ( $folded_field_id =~ /^package_[^\_]+_[^\_]/ ) {
	    # parse the database table name and field id
	    my @fields = split( '_', $folded_field_id );
	    shift @fields;
	    my $table_name = $package_tables_name_prefix . shift @fields;
	    my $field_name = join( '_', @fields );
	    my $field_value = 
		$$package_folded_single_values_ref{$folded_field_id};
	    print "$0: package=<$package_name> ffi=<$folded_field_id> table=<$table_name> field=<$field_name> value=<$field_value>\n"
		if $options{debug};
	    # put a package entry in if not there yet
	    if ( ! exists $package_specific_tables_fields{$table_name} ) {
		my %fields = ();
		$package_specific_tables_fields{$table_name} =\%fields;
	    }
	    # get a pointer to the fields hash for this package
	    my $tables_fields_ref =
		$package_specific_tables_fields{$table_name};
	    # if we haven't seen this field name yet,
	    # save the field id as a lowly INT type
	    $$tables_fields_ref{ $field_name } = "INT"
		if ! exists $$tables_fields_ref{ $field_name };
	    # figure out the type of this particular
	    # value of this field, and upgrade the
	    # type of this field if needed, INT is
	    # simplest type, VARCHAR supercedes INT,
	    # TEXT supercedes INT and VARCHAR
	    if ( length $field_value > 250 ) {
		$$tables_fields_ref{ $field_name } = "TEXT";
	    } elsif ( $field_value !~ /^[0-9]+$/ &&
		      $$tables_fields_ref{ $field_name } eq "INT" ) {
		$$tables_fields_ref{ $field_name } = "VARCHAR\(255\)";
	    }
	}
    }
}
print_hash( "", "$0: package_specific_tables_fields",
	    \%package_specific_tables_fields )
    if $options{debug};
# make the package specific database tables 
# that have been found along with their field
# names and types, adding the "package" field
# to each before making them
foreach my $table_name ( keys %package_specific_tables_fields ) {
    print "$0: making package specific table <$table_name>\n"
	if $options{debug};
    my $tables_fields_ref =
	$package_specific_tables_fields{$table_name};
    $$tables_fields_ref{ package } = "VARCHAR\(255\)";
    make_fix_table_fields( \%options,
			   $table_name,
			   undef,
			   $tables_fields_ref );
}
# scan through the parsed config.xml files hash and
# insert the data into the package specific tables
foreach my $package_name ( sort keys %single_value_folded_fields ) {
    my $package_folded_single_values_ref = 
	$single_value_folded_fields{ $package_name };
    my %tables_records = ();
    foreach my $folded_field_id ( keys %$package_folded_single_values_ref ) {
	# if this is a "package_*_" type field, ...
	if ( $folded_field_id =~ /^package_[^\_]+_[^\_]/ ) {
	    # parse the database table name and field id
	    my @fields = split( '_', $folded_field_id );
	    shift @fields;
	    my $table_name = $package_tables_name_prefix . shift @fields;
	    my $field_name = join( '_', @fields );
	    print "$0: package=<$package_name> ffi=<$folded_field_id> table=<$table_name> field=<$field_name>\n"
		if $options{debug};
	    if ( ! exists $tables_records{$table_name} ) {
		my %record = ();
		$tables_records{$table_name} =\%record;
		$record{package} = $package_name;
	    }
	    my $tables_records_ref = $tables_records{$table_name};
	    $$tables_records_ref{$field_name} =
		$$package_folded_single_values_ref{$folded_field_id};
	    # get rid of the single_value_folded_fields
	    # entry now that we have used it
	    delete $$package_folded_single_values_ref{$folded_field_id};
	}
    }
    foreach my $table_name ( keys %tables_records ) {
	my $record_ref = $tables_records{$table_name};
	my @tables_fields = ( "$table_name" );
	my @wheres = ();
	my @already_existing_records = ();
	foreach my $key ( keys %$record_ref ) {
	    push @tables_fields, $key;
	    push @wheres, "$table_name.$key = \"$$record_ref{$key}\"";
	}
	print_hash( "", "$0: tables_fields=(" . 
		    join(',', @tables_fields ) . ") wheres=(" .
		    join(',', @wheres ) . ") record",
		    $record_ref )
	    if $options{debug};
	my @error_strings = ();
	if ( ! oda::read_records( \%options,
				  \@tables_fields,
				  \@wheres,
				  \@already_existing_records,
				  1,
				  \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	} else {
	    print( "$0: returned already existing (" . 
		   join(',', @already_existing_records ) . ")\n" )
		if $options{debug};
	    if ( ! @already_existing_records ) {
		print_hash( "", "$0: inserting record in table <$table_name>",
			    $record_ref )
		    if $options{debug};
		my @error_strings = ();
	      oda::insert_record( \%options,
				  $table_name,
				  $record_ref,
				  undef,
				  \@error_strings );
		warn shift @error_strings while @error_strings;
	    }
	}
    }
}
#print_hash( "", "$0: package_field_types", \%package_field_types )
#    if $options{debug};

# Determine the field names and types for the
# packages database table which is a common 
# table for most package information. These
# are the single value fields parsed above.
# (except for ones that start with package_*_
# which make other tables and fields which 
# were already taken care of above).
# Each packages database table has a "name"
# field which is the longer name of the package.
# this will be substituted into the database as
# the "package" field value, and the package 
# directory tree location will be put into the
# "name" field. Since we figured out the size
# of what was listed as the "name" field we
# put that sizing type into the "package" field
# and leave the "name" field in our hash.

my %package_field_types = ();
foreach my $package_name ( sort keys %single_value_folded_fields ) {
    my $package_folded_single_values_ref = 
	$single_value_folded_fields{ $package_name };
    $$package_folded_single_values_ref{package} =
	$$package_folded_single_values_ref{name}
    if exists $$package_folded_single_values_ref{name};
    $$package_folded_single_values_ref{name} = $package_name;
    foreach my $folded_field_id ( sort keys %$package_folded_single_values_ref ) {
	# if we haven't seen this field name yet,
	# save the field id as a lowly INT type
	$package_field_types{ $folded_field_id } = "INT"
	    if ! exists $package_field_types{ $folded_field_id };
	# figure out the type of this particular
	# value of this field, and upgrade the
	# type of this field if needed, INT is
	# simplest type, VARCHAR superceded INT,
	# TEXT supercedes INT and VARCHAR
	my $value = 
	    $$package_folded_single_values_ref{ $folded_field_id };
	if ( length $value > 250 ) {
	    $package_field_types{ $folded_field_id } = "TEXT";
	} elsif ( $value !~ /^[0-9]+$/ &&
		  $package_field_types{ $folded_field_id } eq "INT" ) {
	    $package_field_types{ $folded_field_id } = "VARCHAR\(255\)";
	}
#	print "$0: folded_field_id=<$folded_field_id> value=<$value> type=<$package_field_types{ $folded_field_id }>\n"
#	    if $options{debug};
    }
}
print_hash( "", "$0: package_field_types", \%package_field_types )
    if $options{debug};

# create the packages database table with the
# proper field definitions if the table doesn't
# already exist, or add any missing fields
# if the table already exists
make_fix_table_fields( \%options,
		       $packages_table_name,
		       undef,
		       \%package_field_types );

# write out the records for the packages table
# if they aren't already there, modify them to 
# add any new fields if they are there, and
# don't forget we already moved the "name"
# field value from the config.xml files into 
# the "package" value and put the package 
# directory location into the "name" field
foreach my $package_name ( sort keys %single_value_folded_fields ) {
    my @table_fields = ( $packages_table_name );
    my @wheres = ( "packages.name = \"$package_name\"" );
    my @read_results = ();
    my @error_strings = ();
    if ( ! oda::read_records( \%options,
			      \@table_fields,
			      \@wheres,
			      \@read_results,
			      1,
			      \@error_strings ) ) {
	warn shift @error_strings while @error_strings;
    } else {
	if ( ! @read_results ) {
	    print "Writing database table <$packages_table_name> record for package <$package_name>\n";
	    @error_strings = ();
	    if ( ! oda::insert_record( \%options,
				       $packages_table_name,
				       $single_value_folded_fields{ $package_name },
				       undef,
				       \@error_strings ) ) {
		warn shift @error_strings while @error_strings;
	    }
	} else {
	    print "$0: very strange, there are more than 2 package records for <$package_name> in table <$packages_table_name>\n"
		if scalar @read_results > 1;
	}
    }
}
    
# any of the fields fields in the package xml that
# had multiple values such as rpmlist or conflicts
# or provides or requires, ended up being parsed 
# into the %multiple_value_folded_fields hash
# with arrays of hash references somewhere down
# the chain of references. we need to take
# the contents that look like this:
#
# package1 ->
#    provides -> ( 
#                  {
#                    type -> type1
#                    name -> name1
#                  }
#                )
#    requires -> ( 
#                  {
#                    type -> type2
#                    name -> name2
#                  }
#                )
#    rpmlist_all_rpm -> ( rpm1, rpm2 )
#               )
# package2 ->
#    rpmlist_all_rpm -> ( rpm3 )
#    rpmlist_server_rpm -> ( rpm4, rpm5 )
#
# This needs to create these 3 new database tables
# with these records of field=value filled in:
#
# package_provides
#    package=package1   type=type1   name=name1
# package_requires
#    package=package1   type=type2   name=name2
# package_rpmlist
#    package=package1   scope=all    rpm=rpm3
#    package=package2   scope=server rpm=rpm4
#    package=package2   scope=server rpm=rpm5

my %multiple_tables_fields = ();
my %multiple_tables_records = ();
print "$0: PMV processing multiple value fields ...\n"
    if $options{debug};
foreach my $package_name ( sort keys %multiple_value_folded_fields ) {
    print "$0: PMV package <$package_name> ...\n"
	if $options{debug};
    my $package_multiple_value_fields_ref = 
	$multiple_value_folded_fields{ $package_name };
    foreach my $folded_name ( sort keys %$package_multiple_value_fields_ref ) {
	# figure out what the _ seperated fields are
	my @folded_fields = split( '\_', $folded_name );
	my $first_field = shift @folded_fields;
	# figure out what database table this will go in
	my $table_name = $packages_table_name . "_" . $first_field;
	print "$0: PMV folded=<$folded_name> table=<$table_name> data=\n"
	    if $options{debug};
	# get a pointer to the data parsed from xml,
	# this could either be an array of scalar
	# values, or it could be an array of hash 
	# pointers
	my $data_ref = $$package_multiple_value_fields_ref{ $folded_name };
	print Dumper( $data_ref ) if $options{debug};
	# see if this is field will make a new database table
	if ( ! exists $multiple_tables_fields{ $table_name } ) {
	    print "$0: marking new multiple value database table <$table_name>\n"
		if $options{debug};
	    my %tables_fields = ();
	    $multiple_tables_fields{ $table_name } = \%tables_fields;
	    my @tables_records = ();
	    $multiple_tables_records{ $table_name } = \@tables_records;
	    print_hash( "", "$0: updated multiple_tables_fields",
			\%multiple_tables_fields )
		if $options{debug};
	}
	# get pointers to the stuff for this database table
	my $tables_fields_ref = $multiple_tables_fields{ $table_name };
	my $tables_records_ref = $multiple_tables_records{ $table_name };
	# see if there were any field names 
	# specified for this table elsewhere
	my @specified_fieldnames = ();
	if ( exists $oda_fieldnames{ $table_name } ) {
	    my $fieldnames_ref = $oda_fieldnames{ $table_name };
	    foreach my $fieldname ( @$fieldnames_ref ) {
		push @specified_fieldnames, $fieldname;
	    }
	    print "$0: multiple values specified_fieldnames=(" .
		join( ',', @specified_fieldnames ) . ")\n"
		if $options{debug};
	}
	# get the array of data values
	my @data_array = @$data_ref;
	# we always have a package name field in this database
	$$tables_fields_ref{ package } = "VARCHAR(250)";
	# if the array is filled with hash pointers,
	# that means that each key in the hash will 
	# be a database table field name,
	# with each value coming from that key, the only
	# other database table field name will be the package
	# which will have as data this package name
	if ( ! @data_array ) {
	    print "$0: PMV empty data array\n" if $options{debug};
	} elsif ( ref($data_array[0]) eq "HASH" ) {
	    foreach my $data_hash_ref ( @data_array ) {
		my %record = ();
		$record{ package } = $package_name;
		foreach my $field_name ( sort keys %$data_hash_ref ) {
		    # make sure this field name is going
		    # to be in the table
		    $$tables_fields_ref{ $field_name } = "VARCHAR(250)"
			if ! exists $$tables_fields_ref{ $field_name };
		    $record{ $field_name } = $$data_hash_ref{ $field_name };
		}
		push @$tables_records_ref, \%record;
	    }
	} else {
	    # all elements in the folded_fields array 
	    # database field value except for the last
	    # one which is the field name for the data
	    # that is in the data_array. the field names
	    # for the folded_fields array should be 
	    # specified in the specified_fieldnames
	    # array, make sure there are enough field
	    # names to go around and make some up
	    # if not enough
	    my $last_field_name = pop @folded_fields;
	    my @field_names = ( @specified_fieldnames, $last_field_name );
	    my @field_values_except_last = @folded_fields;
	    print "$0: specified_fieldnames=(" .
		join( ',', @specified_fieldnames ) .
		") folded_fields=(" .
		join( ',', @folded_fields ) .
		")\n"
		if $options{debug};
	    if ( scalar @specified_fieldnames <
		 scalar @folded_fields ) {
		warn "$0: package <$package_name> did not supply enough (or any)\n";
		warn "specified field names with a construct like this:\n";
		warn "<oscar>\n  <fieldnames> NAMES</fieldnames>\n</oscar>\n";
		warn "config.xml construct, not storing the data in the\n";
		warn join( '/', ($first_field, @folded_fields, $last_field_name) ) .
		    " having data (" . join( ',', @data_array ) . ")\n";
	    } elsif ( scalar @specified_fieldnames >
		      scalar @folded_fields ) {
		warn "$0: package <$package_name> supplied too many\n";
		warn "specified field names with a construct like this:\n";
		warn "<oscar>\n  <fieldnames> NAMES</fieldnames>\n</oscar>\n";
		warn "config.xml construct, not storing the data in the\n";
		warn join( '/', ($first_field, @folded_fields, $last_field_name) ) .
		    " having data (" . join( ',', @data_array ) . ")\n";
	    } else {
		foreach my $last_data ( @data_array ) {
		    my %record = ();
		    my @field_values = ( @field_values_except_last, $last_data );
		    $record{ package } = $package_name;
		    foreach my $field_name ( @field_names ) {
			$$tables_fields_ref{ $field_name } = "VARCHAR(250)"
			    if ! exists $$tables_fields_ref{ $field_name };
			$record{ $field_name } = shift @field_values;
		    }
		    push @$tables_records_ref, \%record;
#		    print_hash( "", "$0: inserting new updated multiple_tables_fields",
#				\%multiple_tables_fields )
#			if $options{debug};
		}
	    }
	}
    }
}
if ( $options{debug} ) {
    print_hash( "", "multiple_tables_fields", \%multiple_tables_fields );
    print "$0: multiple_tables_records:\n";
    print Dumper( \%multiple_tables_records );
}
# make and populate the database tables
foreach my $table_name ( sort keys %multiple_tables_fields ) {
    print "$0: making/updating database table <$table_name>\n" 
	if $options{debug};
    my $table_fields_ref = $multiple_tables_fields{ $table_name };
    if ( keys %$table_fields_ref ) {
	make_fix_table_fields( \%options,
			       $table_name, 
			       undef,
			       $table_fields_ref );
	# write out any records that aren't there already
	my $records_ref = $multiple_tables_records{ $table_name };
	foreach my $record_ref ( @$records_ref ) {
	    my @tables_fields = ( $table_name, "$table_name.package" );
	    my @wheres = ();
	    # put quotes around the record values so that 
	    # they won't be confused for field names by oda
	    foreach my $field_name ( sort keys %$record_ref ) {
		$$record_ref{$field_name} = "\"$$record_ref{$field_name}\"";
	    }
	    # build up a wheres condition list and see if this record
	    # is already in the database
	    foreach my $field_name ( sort keys %$record_ref ) {
		push @wheres, "$table_name.$field_name = $$record_ref{$field_name}";
	    }
	    my @already_existing_records = ();
	    my @error_strings = ();
	    if ( ! oda::read_records( \%options,
				      \@tables_fields,
				      \@wheres,
				      \@already_existing_records,
				      \@error_strings ) ) {
		oda::disconnect( \%options,
				 \@error_strings );
		warn shift @error_strings while @error_strings;
		exit 1;
	    }
	    if ( ! @already_existing_records ) {
		@error_strings = ();
		if ( ! oda::insert_record( \%options,
					   $table_name,
					   $record_ref,
					   undef,
					   \@error_strings ) ) {
		    oda::disconnect( \%options );
		    warn shift @error_strings while @error_strings;
		    exit 1;
		}  
	    }
	}
    } else {
	warn "$0: empty multiple values package table <$table_name> ignored";
    }
}

# write out one global oscar record, or modify an existing one
my @assigns = ();
my $oscar_version;
if ( -r "$ENV{OSCAR_HOME}/VERSION" ) {
    $oscar_version = `cat $ENV{OSCAR_HOME}/VERSION`;
    chomp $oscar_version;
} else {
    $oscar_version = "CVS";
}
push @assigns, "oscar.oscar_version~$oscar_version";
my @table_fields = ( "oscar" );
my @read_results = ();
my @error_strings = ();
if ( ! oda::read_records( \%options,
			  \@table_fields,
			  undef,
			  \@read_results,
			  1,
			  \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
} else {
    if ( ! @read_results ) {
	print "Creating the global oscar information record\n";
	if ( ! oda::insert_record( \%options,
				   "oscar",
				   \@assigns,
				   undef,
				   \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	}
    } else {
	print "$0: very strange, there are more than 2 package records for <oscar> in table <$packages_table_name>\n"
	    if scalar @read_results > 1;
	print "Modifying the global oscar information record\n";
	if ( ! oda::modify_records( \%options,
				    \@table_fields,
				    \@assigns,
				    undef,
				    \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	}
    }
}    

oda::disconnect( \%options );
exit 0;
