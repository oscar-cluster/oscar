#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Copyright ï¿½ 2003, The Board of Trustees of the University of Illinois. All rights reserved.
# Copyright 2003 NCSA
#                Neil Gorsuch <ngorsuch@ncsa.uiuc.edu>
# Copyright 2004 Revolution Linux
#           Benoit des Ligneris <bdesligneris@revolutionlinux.com>
# Copyright (c) 2005-2007 The Trustees of Indiana University.  
#                    All rights reserved.
# Copyright (c) 2005 Bernard Li <bli@bcgsc.ca>.
#                    All rights reserved.
# Copyright (c) 2006 Erich Focht <efocht@hpce.nec.com>
#                    All rights reserved.
# Copyright (c) 2007 Oak Ridge National Laboratory
#                    Geoffroy Vallee <valleegr@ornl.gov>
#                    All rights reserved.
#       
# $Id$

# This program creates the OSCAR database and then generates all the
# OSCAR database tables.  The tables are created using the sql
# statements which are already defined for "InnoDB" type at
# $ENV{OSCAR_HOME}/share/prereqs/oda/oscar_table.sql.  Creation of the
# tables only happens at the first time instllation and once all the
# tables are created, the data in the config.xml of all the OSCAR
# packages are stored to the database by parsing them to the sql
# strings.  Meanwhile, Population of packages data to the database is
# implemented everytime this script runs.

# This program requires to create/populate the tables in a specific order 
# because of the property of InnoDB table type.
# In sum,
# At the first time installation
# 1. Create a database (naming it "oscar") 
# 2. Create tables according to share/prereqs/oda/oscar_table.sql
# 3. Populate the OSCAR global data to the following tables:
#    - Clusters, Groups, Nodes, and Status
# 
# At the next implementation plus the first time installation
# 4. Populate the Packages table
# 5. Populate the Packages related tables:
#    - Packages
#    - Packages_rpmlists, Packages_servicelists, Packages_switcher
#    - Packages_requires, Packages_provides, Packages_conflicts
# The Packages and its related tables are updated from the second 
# installation.
#

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib","$ENV{OSCAR_HOME}/lib/OSCAR","../../../lib","../../../lib/OSCAR";
use OSCAR::Package;
use OSCAR::PackagePath;
use OSCAR::PackageSet qw (get_opkgs_path_from_package_set);
use OSCAR::Network;
use OSCAR::Utils qw ( print_hash );
use XML::Simple;
use OSCAR::Distro;
use OSCAR::Database;
use OSCAR::Database_generic;
use OSCAR::oda;
use OSCAR::OCA::OS_Detect;
use Data::Dumper;
use Carp;

my $folding_character = "_";
my %list_of_multiple_value_folded_fields = ();
my %multiple_value_folded_fields = ();
my %oda_fieldnames = ();
my %oda_shortcuts = ();
my $package_tables_name_prefix = "package_";
my $packages_table_name = "Packages";
my %single_value_folded_fields = ();
my $xml_file_name = "config.xml";

my @error_strings = ();
my %table_fields_hash = ();
my %oda_options = ( 'debug'        => 0,
                    'verbose'      => 0 );
my %options = (  'changes'      => 1,
                 'debug'        => 0,
                 'verbose'      => 0 );

if ( (exists $ENV{OSCAR_VERBOSE} && $ENV{OSCAR_VERBOSE} == 10) 
    || $ENV{OSCAR_DB_VERBOSE} ){
    $options{verbose} = 1;
    $oda_options{verbose} = 1;
}

if ($ENV{OSCAR_DB_DEBUG}) {
    $oda_options{debug} = 1;
    $options{debug} = 1;
}

my $DEFAULT = "Default";
# find the base directory of the oscar distribution,
my $oscar_home;
# first try the environmental variable
if ( exists $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
    die "DB_DEBUG>$0:\n====> bad OSCAR_HOME environmental variable value <$oscar_home>"
	if ( ! -d "$oscar_home");
} else {
    die "\nEnvironment variable \$OSCAR_HOME is not set!\n";
}

print "DB_DEBUG>$0:\n====> oscar_home=<$oscar_home>\n" if $options{debug};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("bundling");    # allow -a -b or -ab
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

# parse command line options
GetOptions( \%options,
        'changes!',
            'debug!',
            'help',
        'oda=s',
            'verbose!',
            'version' )
    || usage(1);
print "DB_DEBUG>$0:\n====> after GetOptions ARGV=<@ARGV>\n" if $options{debug};
oda::print_hash( "", "DB_DEBUG>$0:\n====> options after GetOptions", \%options)
    if $oda_options{debug};

# Parse the config.xml file for a specific OPKG
# Parameters: package directory, package_name, message.
# Return:     representation of the config.xml file (XMLSimple) is success, 
#             undef else
# Message is an extra string that is printed during debugging.
sub get_xml_ref{
    my ($package_directory,
        $package_name,
        $msg) = @_;
    # if a config.xml file does not exist for this package directory,
    # we'll fake a simple one, otherwise read it in
    my $config_file = "$package_directory/$xml_file_name";
    my $xml_ref = undef;
    if ( ! -f $config_file ) {
        print "Warning, no $config_file exists, supplying one for package $package_name\n";
    } else {
        print "Processing $config_file for package $package_name ...\n$msg" if $msg;
        my $xs = new XML::Simple();
        $xml_ref = eval { $xs->XMLin( $config_file ); };
        if ($@) {
            print "ERROR, $config_file is invalid, supplying one for package".
                  " $package_name\n";
            $xml_ref = undef;
            print "Trying to xmllint the $config_file to show problems:\n";
            system "xmllint $config_file";
        }
    }
    if ( ! defined $xml_ref ) {
        my %faked_xml;
        $faked_xml{class} = "third-party";
        $faked_xml{description} = "Not provided";
        $faked_xml{name} = $package_name;
        $faked_xml{summary} = "Not provided";
        $xml_ref = \%faked_xml;
    }
    if ( $oda_options{debug} ) {
        print "DB_DEBUG>$0:\n====> xml_ref:\n";
        print Dumper($xml_ref);
    }

    return $xml_ref;
}

sub is_installed {
    my ($package,
        $version) = @_;
    print "DB_DEBUG>$0:\n====> in is_installed Checking to see if Packages table has been already populated\n"
        if $options{debug} || $options{verbose};
    my $result_ref = get_package_info_with_name($package,
                        \%options,\@error_strings,$version);
    return ($result_ref?1:0);                    
}

sub delete_packages_related_table {
    my ($package,$options_ref,$error_ref,$package_version) = @_;
    my $where = "";
    my $package_ref = 
        get_package_info_with_name($package,
                                   $options_ref,
                                   $error_ref,
                                   $package_version);
    my $package_id = $$package_ref{id};

    my @list_of_tables = ("Packages_rpmlists", 
                          "Packages_conflicts", "Packages_provides",
                          "Packages_requires", "Packages_servicelists",
                          "Packages_switcher");
    foreach my $table_name (@list_of_tables){
        if ($table_name eq "Packages_conflicts" ||
            $table_name eq "Packages_provides" ||
            $table_name eq "Packages_requires"){
            $where = "WHERE p1_id='$package_id'";
        }else{
            $where = "WHERE package_id='$package_id'";
        }
        delete_table($options_ref,$table_name, $where ,$error_ref);
    }
    return $package_id;
}

sub usage {
    my ( $exit_status, @error_strings ) = @_;
    my $progname = $0;
    print <<USAGE;

$progname [options] [directory [ package_name [ package_version ] ] ]

1. NO Argument
$progname creates the OSCAR tables if they don't exist.
And then, it goes through all the packages on the OSCAR 
package directory($ENV{OSCAR_HOME}/packages) and look 
into each package to parse a $xml_file_name file.
The parsed information is stored to the OSCAR database.
This program mainly does three things without argument:
1) Create all the OSCAR tables from the SQL which is already
   defined (ODA tables are created with InnoDB type)
2) Inserts the package records parsed from $xml_file_name into
   the following tables:
- Packages
- Packages_rpmlists
- Packages_servicelists
- Packages_switcher
- Packages_conflict
- Packages_requiers
- Packages_provides
3) Call set_global_oscar_values to set the global oscar values
   to the following tables
- Clusters   
- Groups
- Status

2. With one or two arguments
$progname reads a $xml_file_name file for a single package
from a specified directory.  It parses database information
from that file, and stores it into the OSCAR database.
Any previously existing database information for that
version of that package is removed from the database before 
inserting information from the $xml_file_name file.
This implements the only section #2 of the "NO Argument" case.

Options:
  --[no]changes     turns on[off] database changes, default is on
  --[no]debug       turns on[off] debug output, default is off
  --help            prints out usage information then exits
  --oda=OPTION(S)   specifies options to be passed to ODA
  --[no]verbose     turns on[off] verbose output, default is off

Usage:
$progname [options] [directory [ package_name [ package_version ] ] ]

USAGE
    if ( @error_strings ) {
	print "\n";
	warn shift @error_strings while @error_strings;
    }
    exit $exit_status;
}

# --help flag just prints out usage information and exits
if ( exists $options{help} ) {
    usage( 0 );
}

my $directory_argument;
my $package_directory;
my $package_name;
my $package_version = "";
if( @ARGV ){
    $directory_argument = shift @ARGV if @ARGV;
    $package_directory = $directory_argument;
    $package_directory = `pwd` . "/$package_directory" 
        if $package_directory !~ /^\//;
    $package_directory =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
    $package_directory =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
    $package_directory =~ s,/\./,/,g;                 # change /./       to /
    $package_directory =~ s,/$,,;       # take / off the end
    print "DB_DEBUG>$0:\n====> package_directory=<$package_directory>\n" 
        if $options{debug};

    # there might be a package short name argument, if not,
    # take the last portion of the directory path,
    if ( @ARGV ) {
        $package_name = shift @ARGV;
    } else {
        $package_name = $package_directory;
        $package_name = $package_name . "/" if $package_name !~ /\/$/;
        $package_name =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
        $package_name =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
        $package_name =~ s,/\./,/,g;                 # change /./       to /
        $package_name =~ s,/$,,;       # take / off the end
        $package_name =~ s,^.*/,,;     # take */ off the beginning
    }
    print "DB_DEBUG>$0:\n====> package_name=<$package_name>\n" 
        if $options{debug};
    usage(1,
          "Package name $package_name from directory $package_directory has ".
          "to start with a letter" )
        if $package_name !~ /^[a-zA-Z]/;
    usage(1,
          "Package name $package_name from directory $package_directory has ".
          "illegal characters" )
        if $package_name !~ /^[a-zA-Z0-9][a-zA-Z0-9\.\_\-]*$/;

    # and if there is another argument, there
    # might be a package version argument
    if ( @ARGV ) {
        $package_version = shift @ARGV;
    }

    # any arguments left is an error
    usage( 1, "unknown argument(s) " . join( ' ', @ARGV ) ) if @ARGV;
}

my @base_directories = @OSCAR::PackagePath::PKG_SOURCE_LOCATIONS;
if ( !($directory_argument && $package_name) ){

    OSCAR::Database::start_database_service ();

    # create the database if not already there and leave us connected to it
    OSCAR::Database::create_database(\%options, \@error_strings);

    print "Searching these directories for packages:\n";
    foreach my $base_directory ( @base_directories ) {
        print "    $base_directory\n";
    }
}

if ( ! oda::oda_connect( \%options, \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
    die "DB_DEBUG>$0:\n====> cannot connect to the OSCAR database";
}

# Initialize the oscar packages related database information by
# slurping in (or supplying default) package config.xml files
# for all packages that were supplied in the oscar tarball/rpm
# and that have been downloaded through opd before this.
my @directories = ();
my @oda_directories = ();
my $msg = "";
my $xml_ref = undef;

# We build first the list of packages that have to be excluded
# With the notion of package set, we do not need to exclude packages
my @excluded_packages = ();

if( $directory_argument ){
    push @directories, $package_directory;
} else {
    my $package_set_id = "Default";

    # We first parse the Default package set the know what are the installable 
    # OPKGs.
    # Note that the list of installable OPKGs depends directly on the list of 
    # OPKGs for the distro on the headnode. This is normal, we must support all
    # services related to OPKGs on the headnode.
    my @opkgs = get_opkgs_path_from_package_set ($package_set_id);
    @directories = (@directories, @opkgs);

    # We add then packages from OPD
    @base_directories = ("/var/lib/oscar/packages");
    foreach my $packages_base_directory ( @base_directories ) {
        opendir(PACKAGES, $packages_base_directory)
        || next;
        while ( my $package = readdir(PACKAGES) ) {
            my $package_excluded = 0;
            chomp $package;
            # Is the package excluded for my distro?
            foreach (@excluded_packages) {
                if ($_ eq $package) {
                    $package_excluded = 1;
                    print ("we exclude package $package\n");
                    last;
                }
            }
            if (!$package_excluded) {
                if ( $package eq "oda" ) {
                    push @oda_directories,
                    "$packages_base_directory/$package";
                } 
                push @directories,
                "$packages_base_directory/$package";
            }
        }
    }
    my @valid_oda_directories = ();
    foreach my $oda_directory ( @oda_directories ) {
        if ( ! -f "$oda_directory/$xml_file_name" ) {
        warn "DB_DEBUG>$0:\n====> ignoring the invalid oda package directory $oda_directory" .
            " that does not contain a $xml_file_name file";
        } else {
            push @valid_oda_directories, $oda_directory;
        }
    }
    die "DB_DEBUG>$0:\n====> cannot find any valid oda packages in these directories: @base_directories"
        if ! (@valid_oda_directories || @directories);
    my $oda_directory = pop @valid_oda_directories;
    foreach my $skipped_oda_directory ( @valid_oda_directories ) {
        warn "DB_DEBUG>$0:\n====> ignoring oda package directory $skipped_oda_directory";
    }

    OSCAR::Database::create_database_tables (\%options, \@error_strings);

    # The env variable $ENV{OSCAR_HEAD_INTERNAL_INTERFACE} should be defined
    # at wizard_prep. If not, we setup by default (to be eth0).
    # This is necessary for the embeded script "set_global_oscar_values"
    $ENV{OSCAR_HEAD_INTERNAL_INTERFACE} = "eth0"    
        if ! exists $ENV{OSCAR_HEAD_INTERNAL_INTERFACE};

    # The "set_global_oscar_values" scripts populates the following
    # tables: Clusters, Groups, and Status
    my $exit_status = system("$ENV{OSCAR_HOME}/scripts/set_global_oscar_values "
                ."--interface $ENV{OSCAR_HEAD_INTERNAL_INTERFACE}".
                ($options{debug}?" --debug":"") )/256;
    croak("Couldn't initialize the global database values table")
        if $exit_status;
    print "\nDB_DEBUG>$0:\n===========================((( All the OSCAR global values are set )))===========================\n"
        if $options{debug} || $options{verbose};

    # "create_and_populate_basic_node_info" is another embeded script
    # to populate the "Nodes" table.
    my $exit_status =
        system("$ENV{OSCAR_HOME}/scripts/create_and_populate_basic_node_info".
               ($options{debug}?" --debug":"") )/256;
    croak("Couldn't set up a default package set") if $exit_status;
    print "\nDB_DEBUG>$0:\n===========================((( All the basic node infos are set  )))===========================\n"
        if $options{debug} || $options{verbose};

    # The above two embeded scripts need to run before all the 
    # data for Packages and Packages related table are populated
    # because the above tables contain the primary keys which
    # will be used at the Packages and its related tables.
    # (i.e., The Packages table and Packages related tables are
    # dependent on the above tables(Clusters, Groups, Status, and
    # Nodes) and they can not really insert any data before the 
    # above tables populate data and generate the primary key
    # used by the Packages and its sub-tables.
}

my %fields = ();
if ( (scalar keys %table_fields_hash) == 0 ){
    oda::list_fields(\%options,"Packages",\%fields,\@error_strings);
    my %packages_hash = %fields;
    foreach my $field (keys %packages_hash){
        if($field == "__group"){ $field = "group"; }
        if($field == "__class"){ $field = "class"; }
        $packages_hash{$field} = 1;
    }
    $table_fields_hash{"Packages"} = \%packages_hash;
}


my @packages_in_db = ();
my @opkgs = ();
get_packages(\@opkgs,\%options,\@error_strings);
foreach my $opkg_ref (@opkgs){
    push @packages_in_db, $$opkg_ref{package};
}

my %opkg_to_be_deleted = ();
foreach my $key_package (@packages_in_db){
    $opkg_to_be_deleted{$key_package} = 1;
}

print "\nDB_DEBUG>$0:\n<<<<<=========================== Populating the Packages records starts\n"
    if $options{debug} || $options{verbose};
foreach my $directory ( @directories ) {
    my $package = $directory;
    $package =~ s,^.*/,,;
    print "Analyzing $package, $directory\n" if $options{debug};
    if ( -d $directory &&
         $package ne "." &&
         $package ne ".." &&
         $package ne "CVS" &&
         $package ne ".svn" &&
         ! -e "$directory/.oscar_ignore" ) {

        # Assign 1 to %opkg_to_be_deleted if $package is already in the DB,
        # which means it($package) should be kept.
        # The rest of packages with 1 in %opkg_to_be_deleted will be removed
        $opkg_to_be_deleted{$package} = 0 if $opkg_to_be_deleted{$package};

        print "\nDB_DEBUG>$0:\nPACKAGE : <<<<<<<<<<<<< $package >>>>>>>>>>>>> : Packages Table\n"
            if $options{debug};
        $msg = "";
        $xml_ref = get_xml_ref($directory, $package,$msg);
        if( is_installed($package,$package_version) ){
            my $package_id = delete_packages_related_table($package,
                                                           \%options,
                                                           \@error_strings,
                                                           $package_version);
            update_packages($xml_ref,
                            "Packages",
                            $package_id,
                            $package,
                            $directory,
                            \%table_fields_hash,
                            \%options,
                            \@error_strings);
            $msg = "Modifying existing $packages_table_name record for package";
        }else{
            $msg = "Writing a new $packages_table_name record for package";

            print Dumper(\%table_fields_hash) if $oda_options{debug};
            print_hash("",
                       "Print the package $package/$xml_file_name",
                       $xml_ref)
                if $oda_options{debug};

            # Insert into "Packages" table
            if (!insert_packages($xml_ref, "Packages", $package, $directory,
                                 \%table_fields_hash, \%options,
                                 \@error_strings) {
                print "ERROR: Impossible to insert package $packages\n";
                exit -1;
            }
        }
    }
}

print "\nDB_DEBUG>$0:\n===========================>>>>> Populating the Packages records is finished\n"
    if $options{debug} || $options{verbose};
my @nics_results = ();
my $server_node = "oscar_server";

# Determine if it is the first time installation or not.
# If nics table is already filled in, this is not first time installation
# and skip the process of inserting into the Group_Packages table.
get_nics_info_with_node($server_node,\@nics_results,\%options,\@error_strings);
print "DB_DEBUG>$0:\n====> If get_nics_info_with_node returns nothing, just ".
      "go to next step: handling Packages related tables.\n". 
      "Otherwise, initialize the Packages related tables\n"
    if $options{debug} || $options{verbose};

# Delete the packages to be deleted when there is no $directory_argument,
# which means it is a call from normal installation but not from OPD.
# This needs to clean the tables related to Packages too.
if(!$directory_argument){
    foreach my $pkg (keys %opkg_to_be_deleted){
        if($opkg_to_be_deleted{$pkg} == 1){
            delete_packages_related_table($pkg,
                                          \%options,
                                          \@error_strings,
                                          $package_version);
            delete_package($pkg,\%options,\@error_strings);
        }
    }
}

print "\nDB_DEBUG>$0:\n<<<<<=========================== Adding/Modifying entries of Packages related tables is beginning\n"
    if $options{debug} || $options{verbose};
foreach my $directory ( @directories ) {
    my $package = $directory;
    $package =~ s,^.*/,,;
    if ( -d $directory &&
         $package ne "." &&
         $package ne ".." &&
         $package ne "CVS" &&
         $package ne ".svn" &&
         ! -e "$directory/.oscar_ignore" ) {
        print "\nDB_DEBUG>$0:\nPACKAGE : <<<<<<<<<<<<< $package >>>>>>>>>>>>> : Packages_related Table\n"
            if $options{debug};
        my $each_msg = $msg . " $package ".
                       ($package_version?"$package_version\n":"\n");
        $xml_ref = get_xml_ref($directory, $package,$each_msg);
        print_hash("", "Print the package $package/$xml_file_name", $xml_ref)
            if $oda_options{debug};

        my $package_ref = 
            get_package_info_with_name($package,
                                       \%options,
                                       \@error_strings,
                                       $package_version);
        my $package_id = $$package_ref{id};

        # Insert into "Packages_rpmlists" table
        insert_pkg_rpmlist($xml_ref->{"binary-package-list"},
                            "Packages_rpmlists",
                            $package_id,
                            \%options,\@error_strings)
            if $xml_ref->{"binary-package-list"};

        # Insert into "Group_Packages" table at the initial process.
        # If a packaged is added with the arguments to this script, 
        # then initial process of oscar database is finished.
        # The newly downloaded packages is not determined to
        # add to the selected "Group" (i.e., Default).
        my %field_value_hash = ();
        if ( ! $directory_argument && !@nics_results ){
            %field_value_hash = ( "group_name"=>$DEFAULT,
                                  "package_id"=>"$package_id",
                                  "selected" => 1);
            push  @error_strings,
                 "Inserting $package with package_id ($package_id), group_name ($DEFAULT)"
                 . " and selected flag (1) into Group_Packages table";
            insert_into_table (\%options,"Group_Packages",\%field_value_hash,\@error_strings);
            @error_strings = ();
        }

        # Insert into "Packages_[conflicts|provides|requires]" table
        foreach my $tag ("conflicts", "provides", "requires"){
            if ( $xml_ref->{$tag} ){ 
                my $tag_ref = $xml_ref->{$tag};
                foreach my $each_tag (keys %$tag_ref){
                    if( $each_tag eq "name" || $each_tag eq "type" ){
                        %field_value_hash = ( "p1_id"=>"$package_id",
                                              "p2_name"=>$tag_ref->{name},
                                              "type"=>$tag_ref->{type} );
                        insert_into_table (\%options,
                                           "Packages_$tag",
                                           \%field_value_hash,
                                           \@error_strings);
                        last;
                    } else {
                        # Handling a case when the conflicts tag is used more 
                        # than one time.
                        %field_value_hash = ( "p1_id"=>"$package_id",
                                              "p2_name"=>$each_tag,
                                              "type"=>$tag_ref->{$each_tag}->{type} );
                        insert_into_table (\%options,
                                           "Packages_$tag",
                                           \%field_value_hash,
                                           \@error_strings);
                    }
                }
            }
        }

        # Insert into "Packages_servicelists" table
        if( $xml_ref->{servicelist} ){
            my $service_ref = $xml_ref->{servicelist};
            if( ref($service_ref) eq "ARRAY") {
                foreach my $ref (@$service_ref){
                    my $value = $ref->{service};
                    my $group = ($ref->{filter}->{group}?$ref->{filter}->{group}:"all");
                    %field_value_hash = ( "package_id"=>"$package_id",
                                          "group_name"=>$group,
                                          "service"=>$value);
                    insert_into_table (\%options,"Packages_servicelists",\%field_value_hash,\@error_strings);
                }
            } else {
                my $value = $service_ref->{service}; 
                my $group = ($service_ref->{filter}->{group}?$service_ref->{filter}->{group}:"all");
                %field_value_hash = ( "package_id"=>"$package_id",
                                      "group_name"=>$group,
                                      "service"=>$value);
                insert_into_table (\%options,
                                   "Packages_servicelists",
                                   \%field_value_hash,
                                   \@error_strings);
            }
        }

        # Insert into "Packages_switcher" table
        if ($xml_ref->{"package-specific-attributes"}->{switcher}){
            my $switcher_name = $xml_ref->{"package-specific-attributes"}->{switcher}->{name};
            my $switcher_tag = $xml_ref->{"package-specific-attributes"}->{switcher}->{tag};
                %field_value_hash = ( "package_id"=>"$package_id",
                                      "switcher_name"=>$switcher_name,
                                      "switcher_tag"=>$switcher_tag );
            insert_into_table (\%options,
                               "Packages_switcher",
                               \%field_value_hash,
                               \@error_strings);
        }
    }
}
print "\nDB_DEBUG>$0:\n===========================>>>>> Adding/Modifying entries of Packages related tables is finished\n"
    if $options{debug} || $options{verbose};

oda::oda_disconnect( \%options );
exit 0;

