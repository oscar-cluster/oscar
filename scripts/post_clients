#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#   This script is designed to be run after clients are defined for an image.
#   It will do all the fixups required.
#
#   Copyright (c) 2005 The Trustees of Indiana University.  
#                      All rights reserved.
#   Copyright (c) 2005, 2007 Bernard Li <bernard@vanhpc.org>
#                            All rights reserved.

# $Id$

use strict;
use lib "$ENV{OSCAR_HOME}/lib",'/usr/lib/systeminstaller';
use Carp;
use File::Copy;
use File::Path;
use File::Basename;
use SIS::Image;
use SIS::DB;
use OSCAR::Package;
use OSCAR::Database;
use OSCAR::MAC qw(sortclients);
use Data::Dumper;

# [BL] 02.06.07 No system should need this - every distro we support should use
# iptables (not ipchains)
#!system("./allow_client_access") or croak("Couldn't run client access program");

push_hosts() or croak("Couldn't push hosts file to images");
populate_known_hosts() or croak ("Could not populate known_hosts file");

# This guarantees that post_clients is run for core packages first
# Eg. SIS post_clients need to be executed before SGE or else compute node's hostnames
# will not be entered into /etc/hosts in time
my @core_pkgs = list_selected_packages("core");
my @noncore_pkgs = list_selected_packages("noncore");
my @pkgs = (@core_pkgs, @noncore_pkgs);

my $return = 0;

foreach my $pkg_ref (@pkgs) {
    my $pkg = $$pkg_ref{package};
    if(!OSCAR::Package::run_pkg_script($pkg, "post_clients", 1, undef)) {
        carp("Couldn't run post_clients script for $pkg");
        $return++;
    }
}

if($return) {
    carp("There were issues running post_clients.  Please check your logs");
}

exit($return);

################################################################################
# Copy the /etc/hosts file into _all_ images. Note that we check if the image  #
# is actually valid.
# Input: None.                                                                 #
# Ouput: 1 if success, undef else.                                             #
################################################################################
sub push_hosts {
    my @images = list_image();
    foreach my $image (@images) {
        my $dir = $image->location;
        if (! -d $dir) {
            carp ("WARNING!! It seems that the image directory does not exist.".
                  "The SIS database and the file system may be desynchronized.".
                  "We may run the Sanity Check framework for more details.\n");
        } else {
            copy("/etc/hosts","$dir/etc/hosts") 
                or (carp "Can't copy /etc/hosts to $dir", return undef);
        }
    }
    return 1;
}

# Populate root's known_hosts file with client entries - each client should have the
# same host_key as the headnode.
# This will be handy if we would like to enhance security for the cluster by not
# enabling StrictHostKeyChecking for ssh client.
sub populate_known_hosts {
    my $known_hosts_path = "/root/.ssh";
    my $known_hosts = "$known_hosts_path/known_hosts";
    my $host_key = "/etc/ssh/ssh_host_rsa_key.pub";
    my @sis_clients = sortclients list_client();
    my $iface = "eth0";
  
    if ( ! -d $known_hosts_path ) {
        mkdir ($known_hosts_path);
    }

    if ( ! -f $known_hosts ) {
        !system("touch $known_hosts") or carp "Could not touch $known_hosts";
    }

    print "Populating $known_hosts with defined clients' host keys\n"; 
    foreach my $client ( @sis_clients ) {
        my $nodename = $client->name();
        my $adapter = list_adapter(client=>$nodename, devname=>"$iface");
        my $ip = $adapter->ip;
        `grep $nodename $known_hosts`;
        if ( $? ) {
            my $entry = "$nodename,$ip ";
            `echo -n "$entry" >> $known_hosts`;
            `cat $host_key >> $known_hosts`;
        }
    }
    return 1;
} # populate_known_hosts

