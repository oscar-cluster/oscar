#!/usr/bin/perl

# Copyright (c) 2003, The Board of Trustees of the University of Illinois.
#                     All rights reserved.
# Copyright 2002 International Business Machines
#                Sean Dague <japh@us.ibm.com>
# Copyright (c) 2002-2005 The Trustees of Indiana University.  
#                         All rights reserved.
# Copyright (c) 2006 Erich Focht <efocht@hpce.nec.com>
#                    All rights reserved.
#
# $Id$
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#   This is a script which does everything that needs to be done for
#   the server to work for oscar.  It is long, but hopefully well structured.

use strict;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::Logger;
use OSCAR::Database;
use OSCAR::PackagePath;
use POSIX; # gives us uname function
use File::Path;
use File::Copy;
use File::Basename;
use Data::Dumper;
use vars qw($RPMTABLE);
use Carp;

my $OSCAR_SERVER_NODE = "oscar_server";
my $OSCAR_SERVER_GROUP = "oscar_server";
my $ohome = $ENV{OSCAR_HOME};

my $verbose;
$verbose="--verbose" if ($ENV{OSCAR_WIZARD_VERBOSE});

#
# #####
#

oscar_log_section("Running OSCAR wizard_prep script");

#
# Locate package pools and create the directories if they don't exist, yet.
#
# Fails HERE if distro is not supported!
#
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_path();
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url();

my $ARCH = `uname -i`;
chomp($ARCH);

# check if distro_pkg_pool contains packages or not
if ($distro_pkg_pool =~ /^\//) {   # is local path, no remote URL
    my @pkgs = glob("$distro_pkg_pool/bash* $distro_pkg_pool/gcc*");
    if (scalar(@pkgs) < 2) {
	print "ERROR: The distribution repository $distro_pkg_pool looks empty!\n";
	print "!!!! Copy all your distro package files (rpms) to it and retry.\n";
	exit 1;
    }
}

my $ipcmd = "$ohome/scripts/install_prereq $verbose";

# Run the prerequisites.  Observe the order set in
# share/prereqs/order.txt, and then run any that are not explicitly
# listed in there.

oscar_log_subsection("Bootstrapping OSCAR smart package manager");

# need to add ifdef for other type of smart package manager
my $cmd = "$ipcmd --dumb packages/yume share/prereqs/perl-IO-Tty share/prereqs/packman";
!system($cmd) or
    die "Could not bootstrap smart package manager!\n";


oscar_log_subsection("Installing OSCAR wizard prerequisites");

my $orderfile = "$ohome/share/prereqs/prereqs.order";

# Read in the share/prereqs/prereqs.order file
# It should contain prerequisite paths relative to $OSCAR_HOME, one per line.

my @ordered_prereqs;
if (-f "$orderfile") {
    local *ORDER;
    open ORDER, "$orderfile" or
        croak("Could't open $orderfile for reading");
    @ordered_prereqs = <ORDER>;
    chomp @ordered_prereqs;
    close(ORDER);
}

# Traverse the @ordered_prereqs list and install them
# This list must contain ALL prerequisites! This is little effort and
# avoids running twice through the prereqs.

# skip comments and empty lines
@ordered_prereqs = grep !/^\s*(\#.*|\s*)$/, @ordered_prereqs;


$cmd = "$ipcmd --smart " . join(" ",@ordered_prereqs);
print "\texecuting: $cmd\n" if ($verbose);
!system($cmd) or die "ERROR: Prerequisites install failure!";

# Install the prerequisites and
# run setup for the prereqs which still need it
foreach my $prereq (@ordered_prereqs) {
    oscar_log_subsection("Installing wizard prereq $prereq");
    # there is no need for a prereq setup script any more,
    # this should really be an exception!
    # 
    # !! All setup scripts are run _before_ installation of prereqs !!
    if (-x "$ohome/$prereq/scripts/setup") {
	oscar_log_subsection("Running prereq setup script for $prereq");
	!system("$ohome/$prereq/scripts/setup")
	    or croak("ERROR: Prerequisite setup failure!");
    }
    oscar_log_subsection("Successfully installed prereq $prereq");
}



# This must be done after the prerequisites, because the prerequisites
# may have installed some Perl modules that OSCAR requires.

require OSCAR::Package;

my $topdir;
chomp($topdir = `pwd`);

# Make a list of all available packages.  Do not use 
# list_installable_package_dirs() here, because that will read 
# in all the per-package config.xml files. This is in preparation 
# of running all the package setup scripts, and the setup scripts 
# must be run *before* reading the XML files in.

my @PKG_SOURCE_LOCATIONS = @OSCAR::PackagePath::PKG_SOURCE_LOCATIONS;


# Now that we have a good list of packages, run all the setup scripts.

oscar_log_subsection("Locating _all_ OSCAR packages");
my %pkgdirs;
foreach my $d (@PKG_SOURCE_LOCATIONS) {
    # EF: a package is a package if it has a config.xml file
    for my $cfg (glob("$d/*/config.xml")) {
	my $dir = dirname($cfg);
	my $pkg = basename($dir);

	# [EF] When package exists in multiple placese we use the last occurence
	#      (usually /var/lib/oscar/packages).
	#      This makes it easier to override OSCAR builtin packages with
	#      downloaded ones.
	if (exists($pkgdirs{$pkg})) {
	    print "WARNING: Package $pkg found in multiple places. Using $dir!\n";
	}
	$pkgdirs{$pkg} = $dir;
    }
}

oscar_log_subsection("Running package setup scripts for ALL packages");
for my $pkg (sort keys(%pkgdirs)) {
    my $dir = $pkgdirs{$pkg};
    next if (! -x "$dir/scripts/setup");

    # If it's a good package, run its setup script (if it has one) in
    # the scripts directory.
    chdir("$dir/scripts");
    #
    # EF: this needs to be eval'd because the OSCAR::Package namespace
    # does not exist at perl compile time.
    #
    eval("OSCAR::Package::run_pkg_script(\$pkg, \"setup\", 1)") 
	or croak("Failed running setup script for $pkg");
    chdir($topdir);
}
oscar_log_subsection("Successfully ran package setup scripts");



oscar_log_subsection("Copying package files to $oscar_pkg_pool");
my $gscmd = "$ohome/scripts/generic-setup $verbose";
my $err = 0;
for my $pkg (sort keys(%pkgdirs)) {
    my $dir = $pkgdirs{$pkg};

    oscar_log_subsection("Running generic-setup for opkg $pkg");
    $cmd = "env OSCAR_PACKAGE_HOME=$dir $gscmd --pool $oscar_pkg_pool";
    print "\texecuting: $cmd\n" if ($verbose);
    my $ret = system($cmd);
    if ($ret) {
	oscar_log_subsection("Error $ret was returned for opkg $pkg");
	if (!$err) {
	    $err = $ret;
	}
    } else {
	oscar_log_subsection("Successfully ran generic-setup for opkg $pkg");
    }
}



# Make sure there is a database password

oscar_log_subsection("Making sure there is an ODA database password");
system( "$ENV{OSCAR_HOME}/scripts/make_database_password" );

# Start the database and copy the package xml files into the database

oscar_log_subsection("Initializing ODA database from package config.xml files");
my $exit_status =
  system( "$ENV{OSCAR_HOME}/scripts/package_config_xmls_to_database" ) / 256;
croak("Couldn't set up oda database") if $exit_status;

# More ODA setup

my $exit_status = system("$ENV{OSCAR_HOME}/scripts/set_global_oscar_values "
			 ."--interface $ENV{OSCAR_HEAD_INTERNAL_INTERFACE}")/256;
croak("Couldn't initialize the global database values table") if $exit_status;

my $exit_status =
    system("$ENV{OSCAR_HOME}/scripts/create_and_populate_basic_node_info")/256;
croak("Couldn't set up a default package set") if $exit_status;

my $exit_status =
  system("$ENV{OSCAR_HOME}/scripts/populate_default_package_set")/256;
croak("Couldn't set up a default package set") if $exit_status;

my $exit_status =
  system("$ENV{OSCAR_HOME}/scripts/set_node_nics --network")/256;
croak("Couldn't initialize the nics and networks for the oscar server") if $exit_status;



# Get the list of just core packages

my (@results, %options, @errors);
get_packages_with_class("core",\@results,\%options,\@errors) or
    die "$0:Failed to get core packages list";
my @packages = map { $_->{package} } @results;

oscar_log_subsection("Identified core packages: " . join(' ', @packages));


# Get list of RPMs from the core packages
my @rpms = ();
foreach my $package (@packages) {
    push @rpms, database_rpmlist_for_package_and_group($package,undef,
						       $OSCAR_SERVER_GROUP,
						       \@errors);
}


oscar_log_subsection("Installing server core packages");

print "Packages: ".join(" ",@rpms) . "\n" if ($verbose);
#
# The code below should migrate into a package. It is used in install_prereq
# in exactly the same way. Maybe to OSCAR::PackageSmart...? [EF]
#

eval("require OSCAR::PackMan");
eval("require OSCAR::PackageSmart");
my $pm = OSCAR::PackageSmart::prepare_pools(($verbose?1:0),
					    $oscar_pkg_pool,$distro_pkg_pool);
if (!$pm) {
    croak "\nERROR: Could not create PackMan instance!\n";
}

my ($err, @out) = $pm->smart_install(@rpms);
if (!$err) {
    print "Error occured during smart_install:\n";
    print join("\n",@out)."\n";
    exit 1;
}

oscar_log_subsection("Successfully installed server core RPMs");

#
# NEST
#
# Unless node_config_revs already has the record of node_id and configurations_id,
# do the following two steps. Otherwise, skip them.
# 1. Insert node_config data for oscar_server.
#    add_node_config_revs is a shortcut to insert a record of node_id, configurations_id, and version
#    e.g) add_node_config_revs [$node_id] [$configurations_id] [$version]
#         Where $version is optional (The default value of $version is 0).
# 2. Insert core packages into config_opkgs table for oscar_server.
#    add_config_opkgs is a shortcut to insert a record of configurations_id and package_id
#    e.g) add_config_opkgs [$configurations_id] [$package_id]
#

# START LOCKING FOR NEST && open the database
my @tables = ("Nodes","Groups","Group_Nodes", "Packages", "Group_Packages", "Node_Package_Status", "Node_Packages");
my %options = ();
my @errors = ();
locking("write", \%options, \@tables, \@errors);

# Update Group_Nodes table with oscar_server group.
my @nodes = ($OSCAR_SERVER_NODE);
set_group_nodes($OSCAR_SERVER_GROUP,\@nodes,\%options,\@errors);

# Have installed Core Server Pkgs & did not croak, so mark 
# packages.<pkg>installed true.  (best effort for now)

print "Updating the status of core packages from installable to installed\n";
my @package_results = ();
my $requested = 7;
my $group = "core";
if ( get_packages_with_class($group,\@package_results,\%options,\@errors)){
    die "$0:Failed to update the table Node_Package_Status"
        if(!update_node_package_status(\%options,"oscar_server",\@package_results,$requested,\@errors));
}

# UNLOCKING FOR NEST
unlock(\%options, \@errors);

oscar_log_subsection("Done marking installed bits in ODA");



# Run the post_server_rpm_install scripts

oscar_log_subsection("Running post_server_install scripts for " .
                     "server core packages");
foreach my $package (@packages) 
  {
    OSCAR::Package::run_pkg_script($package,"post_server_install") or 
      croak("Failed running post_server_install for $package");
  }
oscar_log_subsection("Successfully ran server core package " .
                     "post_server_install scripts");

oscar_log_subsection("Successfully ran OSCAR wizard_prep script");



sub print_output {
    my ($line) = @_;
    print "$line\n";
}
