#!/usr/bin/perl

# Copyright (c) 2003, The Board of Trustees of the University of Illinois.
#                     All rights reserved.
# Copyright 2002 International Business Machines
#                Sean Dague <japh@us.ibm.com>
# Copyright (c) 2002-2005 The Trustees of Indiana University.  
#                         All rights reserved.
# Copyright (c) 2006 Erich Focht <efocht@hpce.nec.com>
#                    All rights reserved.
#
# $Id$
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#   This is a script which does everything that needs to be done for
#   the server to work for oscar.  It is long, but hopefully well structured.

use strict;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::Logger;
use OSCAR::PackagePath;
use POSIX; # gives us uname function
use File::Path;
use File::Copy;
use File::Basename;
use Data::Dumper;
use vars qw($RPMTABLE);
use Carp;

my $OSCAR_SERVER_NODE = "oscar_server";
my $OSCAR_SERVER_GROUP = "oscar_server";
my $ohome = $ENV{OSCAR_HOME};

my $verbose;
if ($ENV{OSCAR_VERBOSE}) {
    $verbose="--verbose";
    if (!$ENV{YUME_VERBOSE}) {
	$ENV{YUME_VERBOSE} = $ENV{OSCAR_VERBOSE};
    }
}

my $md5;

#
# #####
#

oscar_log_section("Running OSCAR wizard_prep script");

#
# Detect OS of master node.
#
# Fails HERE if distro is not supported!
#
my $os = &OSCAR::PackagePath::distro_detect_or_die();

#
# Locate package pools and create the directories if they don't exist, yet.
#
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_path(os=>$os);
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url(os=>$os);

my $ARCH = `uname -i`;
chomp($ARCH);

# check if distro_pkg_pool contains packages or not
if ($distro_pkg_pool =~ /^\//) {   # is local path, no remote URL
    my @pkgs = glob("$distro_pkg_pool/bash* $distro_pkg_pool/gcc*");
    if (scalar(@pkgs) < 2) {
	print "ERROR: The distribution repository $distro_pkg_pool looks empty!\n";
	print "!!!! Copy all your distro package files (rpms) to it and retry.\n";
	exit 1;
    }
}

#
# locate _all_ available distro pools, prepare for heterogeneous setup
#
my %distro_pools = &OSCAR::PackagePath::list_distro_pools();
print "Available Distro Pools:\n".Dumper(%distro_pools) if ($verbose);

my $ipcmd = "$ohome/scripts/install_prereq $verbose";

# Run the prerequisites.  Observe the order set in
# share/prereqs/order.txt, and then run any that are not explicitly
# listed in there.

oscar_log_subsection("Bootstrapping OSCAR smart package manager");


# install_prereq is a very powerfull tool. It can install and remove
# packages based on a simple configuration file which distinguishes
# between distributions, thus making the addition of distributions
# a piece of cake.
#
# install_prereq --dumb uses only the basic package manager which is
# allways available on a system. The packages installed in this mode
# need to contain all dependencies in the configuration file, as the
# dumb package managers (rpm, dpkg) don't know how to resolve
# dependencies.
#
# install_prereq --smart uses a packman instance specific to the current
# distro and expects that to return "true" when the ->is_smart() method
# is invoked. It is able to resolve dependencies automatically from the
# repositories.

my $cmd;
if ($os->{pkg} eq "rpm") {
    # rpm based distros use yume
    $cmd = "$ipcmd --dumb share/prereqs/base packages/yume".
	" share/prereqs/packman";
} elsif($os->{pkg} eq "deb") {
    # debian based distros already have apt...
    $cmd = "$ipcmd --dumb share/prereqs/base share/prereqs/packman";
} else {
    die "Unsupported package manager: ".$os->{pkg};
}
!system($cmd) or
    die "Could not bootstrap smart package manager!\n";

# this is needed for the checksum computations which shorten startup times
eval("require OSCAR::PackageSmart");
my $md5dir = $ENV{OSCAR_HOME}."/tmp";
if (! -d $md5dir) {
    mkdir $md5dir or croak "Could not make directory $md5dir: $!";
}


# hack... needs to be done yum independent
system("yum clean all");

oscar_log_subsection("Installing OSCAR wizard prerequisites");

my $orderfile = "$ohome/share/prereqs/prereqs.order";

# Read in the share/prereqs/prereqs.order file
# It should contain prerequisite paths relative to $OSCAR_HOME, one per line.

my @ordered_prereqs;
if (-f "$orderfile") {
    local *ORDER;
    open ORDER, "$orderfile" or
        croak("Could't open $orderfile for reading");
    @ordered_prereqs = <ORDER>;
    chomp @ordered_prereqs;
    close(ORDER);
}

# Traverse the @ordered_prereqs list and install them
# This list must contain ALL prerequisites! This is little effort and
# avoids running twice through the prereqs.

# skip comments and empty lines
@ordered_prereqs = grep !/^\s*(\#.*|\s*)$/, @ordered_prereqs;


# compute checksums for each ordered prereq
my $indx=0;
my $do_prereqs=0;
for my $prereq (@ordered_prereqs) {
    my $cfile = "$md5dir/prereq_$indx.md5";
    $md5 = OSCAR::PackageSmart::checksum_needed("$ENV{OSCAR_HOME}/$prereq",
						"$cfile","*");
    $do_prereqs = 1 if ($md5);
    $indx++;
}
goto PREREQS_DONE if (!$do_prereqs);

$cmd = "$ipcmd --smart " . join(" ",@ordered_prereqs);
print "\texecuting: $cmd\n" if ($verbose);
!system($cmd) or die "ERROR: Prerequisites install failure!";

# Install the prerequisites and
# run setup for the prereqs which still need it
foreach my $prereq (@ordered_prereqs) {
    oscar_log_subsection("Installing wizard prereq $prereq");
    # there is no need for a prereq setup script any more,
    # this should really be an exception!
    # 
    # !! All setup scripts are run _before_ installation of prereqs !!
    if (-x "$ohome/$prereq/scripts/setup") {
	oscar_log_subsection("Running prereq setup script for $prereq");
	!system("$ohome/$prereq/scripts/setup")
	    or croak("ERROR: Prerequisite setup failure!");
    }
    oscar_log_subsection("Successfully installed prereq $prereq");
}
$indx=0;
for my $prereq (@ordered_prereqs) {
    my $cfile = "$md5dir/prereq_$indx.md5";
    $md5 = OSCAR::PackageSmart::checksum_needed("$ENV{OSCAR_HOME}/$prereq",
						"$cfile","*");
    OSCAR::PackageSmart::checksum_write($cfile,$md5);
    $indx++;
}
 PREREQS_DONE:

# This must be done after the prerequisites, because the prerequisites
# may have installed some Perl modules that OSCAR requires.

require OSCAR::Package;

my $topdir;
chomp($topdir = `pwd`);

# Make a list of all available packages.  Do not use 
# list_installable_package_dirs() here, because that will read 
# in all the per-package config.xml files. This is in preparation 
# of running all the package setup scripts, and the setup scripts 
# must be run *before* reading the XML files in.

my @PKG_SOURCE_LOCATIONS = @OSCAR::PackagePath::PKG_SOURCE_LOCATIONS;


# Now that we have a good list of packages, run all the setup scripts.

oscar_log_subsection("Locating _all_ OSCAR packages");
my %pkgdirs;
foreach my $d (@PKG_SOURCE_LOCATIONS) {
    # EF: a package is a package if it has a config.xml file
    for my $cfg (glob("$d/*/config.xml")) {
	my $dir = dirname($cfg);
	my $pkg = basename($dir);

	# [EF] When package exists in multiple placese we use the last occurence
	#      (usually /var/lib/oscar/packages).
	#      This makes it easier to override OSCAR builtin packages with
	#      downloaded ones.
	if (exists($pkgdirs{$pkg})) {
	    print "WARNING: Package $pkg found in multiple places. Using $dir!\n";
	}
	$pkgdirs{$pkg} = $dir;
    }
}

# checksum for package files
$md5 = OSCAR::PackageSmart::checksum_needed("$ENV{OSCAR_HOME}/packages",
					    "$md5dir/packages.md5",
					    "*");
goto PREP_DB if (!$md5);

oscar_log_subsection("Running package setup scripts for ALL packages");
for my $pkg (sort keys(%pkgdirs)) {
    my $dir = $pkgdirs{$pkg};
    next if (! -x "$dir/scripts/setup");

    # If it's a good package, run its setup script (if it has one) in
    # the scripts directory.
    chdir("$dir/scripts");
    #
    # EF: this needs to be eval'd because the OSCAR::Package namespace
    # does not exist at perl compile time.
    #
    eval("OSCAR::Package::run_pkg_script(\$pkg, \"setup\", 1)") 
	or croak("Failed running setup script for $pkg");
    chdir($topdir);
}
oscar_log_subsection("Successfully ran package setup scripts");



my %orepo_done;
my $err = 0;
for my $dist (keys %distro_pools) {
    my %d = %{$distro_pools{$dist}};
    my $oscar_repo = $d{oscar_repo};
    next if (exists $orepo_done{"$oscar_repo"});
    my $gs_distro = $d{os}->{compat_distro}."-".$d{os}->{compat_distrover};
    my $gs_arch = $d{os}->{arch};
    # 
    oscar_log_subsection("Running opkg-copy for $gs_distro $gs_arch");
    my $cmd = "$ohome/scripts/opkg-copy --distro=$gs_distro --arch=$gs_arch".
	" --pool=$oscar_repo $verbose --all";
    
    print "\texecuting: $cmd\n" if ($verbose);
    my $ret = system($cmd);
    if ($ret) {
	oscar_log_subsection("Error $ret was returned for opkg-copy");
	if (!$err) {
	    $err = $ret;
	}
    } else {
	oscar_log_subsection("Successfully ran opkg-copy for $gs_distro $gs_arch");
    }
}
if ($err) {
    croak("Failure during opkg-copy!");
}

# recalculate checksum because "setup" might have changed something
$md5 = OSCAR::PackageSmart::checksum_files("$ENV{OSCAR_HOME}/packages","*");
OSCAR::PackageSmart::checksum_write("$md5dir/packages.md5",$md5);



 PREP_DB:
# Make sure there is a database password

oscar_log_subsection("Making sure there is an ODA database password");
system( "$ENV{OSCAR_HOME}/scripts/make_database_password" );

# Now we're ready to use the database
eval "use OSCAR::Database";


 PREP_CONFIG_XML:
$md5 = OSCAR::PackageSmart::checksum_needed("$ENV{OSCAR_HOME}/packages",
					    "$md5dir/config_xml.md5",
					    "config.xml");
#goto PREP_MORE_ODA if (!$md5);


# Start the database and copy the package xml files into the database
oscar_log_subsection("Initializing ODA database from package config.xml files");
my $exit_status =
  system( "$ENV{OSCAR_HOME}/scripts/package_config_xmls_to_database" ) / 256;
croak("Couldn't set up oda database") if $exit_status;

OSCAR::PackageSmart::checksum_write("$md5dir/config_xml.md5",$md5);


 PREP_MORE_ODA:
# More ODA setup
#my $exit_status = system("$ENV{OSCAR_HOME}/scripts/set_global_oscar_values "
#			 ."--interface $ENV{OSCAR_HEAD_INTERNAL_INTERFACE}")/256;
#croak("Couldn't initialize the global database values table") if $exit_status;

#my $exit_status =
#    system("$ENV{OSCAR_HOME}/scripts/create_and_populate_basic_node_info")/256;
#croak("Couldn't set up a default package set") if $exit_status;

my $exit_status =
  system("$ENV{OSCAR_HOME}/scripts/populate_default_package_set")/256;
croak("Couldn't set up a default package set") if $exit_status;

my $exit_status =
  system("$ENV{OSCAR_HOME}/scripts/set_node_nics --network")/256;
croak("Couldn't initialize the nics and networks for the oscar server") if $exit_status;



 PREP_INSTALL_CORE:
$md5 = OSCAR::PackageSmart::checksum_needed("$ENV{OSCAR_HOME}/packages",
					    "$md5dir/packages_core.md5",
					    "*");
goto PREP_DONE if (!$md5);

# Get the list of just core packages

my (@results, %options, @errors);
get_packages_with_class("core",\@results,\%options,\@errors) or
    die "$0:Failed to get core packages list";
my @packages = map { $_->{package} } @results;

oscar_log_subsection("Identified core packages: " . join(' ', @packages));


# Get list of RPMs from the core packages
my @rpms = ();
foreach my $package (@packages) {
    push @rpms, database_rpmlist_for_package_and_group($package,undef,
						       $OSCAR_SERVER_GROUP,
						       \@errors);
}


oscar_log_subsection("Installing server core packages");

print "Packages: ".join(" ",@rpms) . "\n" if ($verbose);
#
# The code below should migrate into a package. It is used in install_prereq
# in exactly the same way. Maybe to OSCAR::PackageSmart...? [EF]
#

eval("require OSCAR::PackMan");
my $pm = OSCAR::PackageSmart::prepare_pools(($verbose?1:0),
					    $oscar_pkg_pool,$distro_pkg_pool);
if (!$pm) {
    croak "\nERROR: Could not create PackMan instance!\n";
}

my ($err, @out) = $pm->smart_install(@rpms);
if (!$err) {
    print "Error occured during smart_install:\n";
    print join("\n",@out)."\n";
    exit 1;
}

oscar_log_subsection("Successfully installed server core RPMs");

 PREP_CORE_NEST:
#
# NEST
#
# Unless node_config_revs already has the record of node_id and configurations_id,
# do the following two steps. Otherwise, skip them.
# 1. Insert node_config data for oscar_server.
#    add_node_config_revs is a shortcut to insert a record of node_id, configurations_id, and version
#    e.g) add_node_config_revs [$node_id] [$configurations_id] [$version]
#         Where $version is optional (The default value of $version is 0).
# 2. Insert core packages into config_opkgs table for oscar_server.
#    add_config_opkgs is a shortcut to insert a record of configurations_id and package_id
#    e.g) add_config_opkgs [$configurations_id] [$package_id]
#

# START LOCKING FOR NEST && open the database
my @tables = ("Nodes","Groups","Group_Nodes", "Packages", "Group_Packages", "Node_Package_Status", "Node_Packages");
my %options = ();
my @errors = ();
locking("write", \%options, \@tables, \@errors);

# Update Group_Nodes table with oscar_server group.
my @nodes = ($OSCAR_SERVER_NODE);
set_group_nodes($OSCAR_SERVER_GROUP,\@nodes,\%options,\@errors);

# Have installed Core Server Pkgs & did not croak, so mark 
# packages.<pkg>installed true.  (best effort for now)

print "Updating the status of core packages from installable to installed\n";
my @package_results = ();
my $requested = 7;
my $group = "core";
if ( get_packages_with_class($group,\@package_results,\%options,\@errors)){
    die "$0:Failed to update the table Node_Package_Status"
        if(!update_node_package_status(\%options,"oscar_server",\@package_results,$requested,\@errors));
}

# UNLOCKING FOR NEST
unlock(\%options, \@errors);

oscar_log_subsection("Done marking installed bits in ODA");


 PREP_POST_SERVER_CORE:
# Run the post_server_rpm_install scripts

oscar_log_subsection("Running post_server_install scripts for " .
                     "server core packages");
foreach my $package (@packages) 
  {
    OSCAR::Package::run_pkg_script($package,"post_server_install") or 
      croak("Failed running post_server_install for $package");
  }
oscar_log_subsection("Successfully ran server core package " .
                     "post_server_install scripts");
OSCAR::PackageSmart::checksum_write("$md5dir/packages_core.md5",$md5);

#
# Prepare and export all repositories
#
for my $dist (keys %distro_pools) {
    my %d = %{$distro_pools{$dist}};
    my $oscar_repo = $d{oscar_repo};
    my $distro_repo = $d{distro_repo};
    # 
    oscar_log_subsection("Preparing for httpd export: $distro_repo $oscar_repo");
    my $pm = &OSCAR::PackageSmart::prepare_pools($verbose,
						 $distro_repo,
						 $oscar_repo);
    if ($pm) {
	$pm->repo_export();
	undef $pm;
    }
}


 PREP_DONE:

oscar_log_subsection("Successfully ran OSCAR wizard_prep script");



sub print_output {
    my ($line) = @_;
    print "$line\n";
}
