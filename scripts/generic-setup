#!/usr/bin/env perl
#
# Copyright (c) 2002-2005 The Trustees of Indiana University.  
#                         All rights reserved.
# Copyright (c) 2005 Bernard Li <bli@bcgsc.ca>
# 
# This file is part of the OSCAR software package.  For license
# information, see the COPYING file in the top level directory of the
# OSCAR source distribution.
#
# Generic setup script for copying distro and arch specific RPMs/packages
# from distro/*/ to /tftpboot/oscar/.... Can also be used for deleting
# packages from the /tftpboot/oscar/... package pool.
#
# This program is executed before the packman abstraction for package
# managers is installed and available.
#
# $Id$
#
# Originally written by:
# Copyright (c) 2005 Erich Focht <efocht@hpce.nec.com>

use strict;
use lib "$ENV{OSCAR_HOME}/lib";
use POSIX;
use Carp;
use OSCAR::OCA::OS_Detect;
use OSCAR::PackagePath;
use Getopt::Long;
use File::Basename;

sub vprint;

# One must always protect oneself.
#
die "\$OSCAR_HOME: not defined.\n" unless exists $ENV{OSCAR_HOME};
die "$ENV{OSCAR_HOME}: not a directory.\n" unless -d $ENV{OSCAR_HOME};
die "$ENV{OSCAR_HOME}: not accessible.\n" unless -x $ENV{OSCAR_HOME};
die "\$OSCAR_PACKAGE_HOME: not defined.\n" unless exists $ENV{OSCAR_PACKAGE_HOME};
die "$ENV{OSCAR_PACKAGE_HOME}: not a directory.\n" unless -d $ENV{OSCAR_PACKAGE_HOME};
die "$ENV{OSCAR_PACKAGE_HOME}: not accessible.\n" unless -x $ENV{OSCAR_PACKAGE_HOME};

# Different distros require different RPMs. Different architectures, too.

my $base_dir= $ENV{OSCAR_PACKAGE_HOME};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

my %options;
GetOptions( \%options,
	    'arch|a=s',
	    'distro|d=s',
	    'image|i=s',
	    'help|h',
	    'pool|p=s',
            'test|t',
            'verbose|v!'
            ) || usage();

# Query distro/version of the master node
my $os = OSCAR::OCA::OS_Detect::open($options{image});
die "Unable to determine operating system" if (!$os);

my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_url($options{image});

# set package name
$ENV{OSCAR_PACKAGE_HOME} =~ s:/$::;
my $pkg_name = basename($ENV{OSCAR_PACKAGE_HOME});

# force verbose output if --test was selected
$options{verbose} = 1 if exists $ENV{DEBUG_OSCAR_SETUP} || $options{test};

if ($options{pool}) {
    $oscar_pkg_pool = $options{pool};
}

usage() if ($options{help});

# Quick sanity check
if (! -d $oscar_pkg_pool) {
    croak("Directory $oscar_pkg_pool does not exist");
}

print "Copying to OSCAR package pool: $oscar_pkg_pool\n";

# image option has priority over arch and distro options
if ($options{image}) {
    delete $options{arch};
    delete $options{distro};
}

# Which architecture are we dealing with?
my $march;
if ($options{arch}) {
    $march = $options{arch};
} else {
    $march = $os->{arch};
}
$march = "i386" if $march =~ /^i[3456]86$/;

#
# Packages to which command applies. If empty, use all packages!
#
my @argpkgs = @ARGV;

################################
## Do the job
################################

# List of package files found in the distro-specific directories
my @pkgfiles;

# Find first compatible subdirectory
# Note ordering, later occurrence of identical filenames overwrite earlier.
# packages, common-arch, and distro-compat dir.
#
my @src_dirs;
# EF: packages directory should go away and be replaced by common-rpms
#     Still need to make this distro-dependent
if ($os->{pkg} eq "rpm") {
    push @src_dirs, "RPMS" if (-d "$base_dir/RPMS");
    push @src_dirs, "distro/common-rpms" if (-d "$base_dir/distro/common-rpms");
} elsif ($os->{pkg} eq "deb") {
    push @src_dirs, "DEBS" if (-d "$base_dir/DEBS");
    push @src_dirs, "distro/common-debs" if (-d "$base_dir/distro/common-debs");
}
my ($non_common, $have_pkgs);
my ($name, $ver) = distroname();
my $dir = $name. $ver . "-" . $march;
if (-d "$base_dir/distro/$dir") {
    push @src_dirs, "distro/$dir";
    $non_common = 1;
    # check for empty directories
    my @my_pkgs = glob("$base_dir/distro/$dir/*");
    $have_pkgs = 1 if (scalar(@my_pkgs) > 0);
}

# Are there any other package directories around?
# This test makes no sense once we'll have distro-specific OSCAR tarballs
my @any_dirs = glob("$base_dir/distro/{rhel,fc,mdk,mdv,debian}*");
# do we have any non-common dir in distro?
if ((scalar(@any_dirs) > 0) && !$non_common) {
    print "WARNING: No distro-specific dir found for package $pkg_name!\n";
    print "   Continuing but distro-specific packages could be missing...\n";
}
my @any_pkgs = glob("$base_dir/distro/{rhel,fc,mdk,mdv,debian}*/*");
# is the directory empty while others have packages?
# this test makes no sense once we'll have distro-specific OSCAR tarballs
if ($non_common && (scalar(@any_pkgs) > 0) && !$have_pkgs) {
    print "WARNING: Distro specific directory of package $pkg_name looks empty!\n";
    print "   Continuing but distro-specific packages could be missing...\n";
}
if (@src_dirs) {
    vprint("Distro specific packages come from\n\t$base_dir/"
	   . join("\n\t$base_dir/",@src_dirs)."\n");
}

# List packages.
#
# EF: reduce inherent perl obfuscation factor
#my %pkglist = map { /([^\/]+)$/, $_ } map { glob("$base_dir/$_/*") } @src_dirs;
my %pkglist;
for my $d (@src_dirs) {
    for my $f (glob("$base_dir/$d/*")) {
	my $k = basename($f);
	$pkglist{$k} = $f;
    }
}
vprint("Available Packages:\n\t" 
       . join( "\n\t", map {"$pkglist{$_}"} keys %pkglist )."\n");

#
# No packages on the argument line? Then take all packages.
#
@argpkgs = keys %pkglist unless @argpkgs;

###
# Copy packages to the package pool.
###
for my $pkg (@argpkgs) {
    my $basename;

    my @possibles = grep /^\Q$pkg\E[-\.]/, keys %pkglist;
    if (exists $pkglist{$pkg}) {
	push @possibles, ($pkg);
    }
    vprint "Matching packages:\n\t".join("\n\t",@possibles)."\n" if @possibles > 1;
    unless ( @possibles ) {
	print STDERR "Package $pkg not found\n";
	next;
    }
    if( @possibles == 1 ) {
	$basename = $possibles[0];
    } else {
    	$basename = (sort {length($a) <=> length($b)} @possibles)[0];
    }
    my $filename = $pkglist{$basename};
    my $msg = dirname($filename)."/${pkg}.txt";
    if (-f $msg) {
	print STDOUT "\n::::::::::::::-------------------------\n";
	open IN, "< $msg" or croak("Couldn't open $msg");
	my @lines = <IN>;
	close IN;
	print STDOUT map {": $_"} @lines;
	print STDOUT "::::::::::::::-------------------------\n";
    }
    print "  * copying $filename\n";
    if (!defined $options{test}) {
	!system("cp -p $filename $oscar_pkg_pool") ||
	    croak("Error occured while copying: $!");
    }
}

exit 0;

############################################################################
######## only subroutines below
############################################################################

sub vprint {
    print @_ if ($options{verbose});
}

#
# Standardized distribution subdirectory name.
# Uses the OSCAR::OCA::OS_Detect framework.
#
sub distroname {
    my ($name, $ver);

    # override distro detection
    if ($options{distro}) {
	($name, $ver) = split /-/, $options{distro};
    } else {
        $name = $os->{compat_distro};
        $ver = $os->{compat_distrover};
    }
    return ($name,$ver);
}


sub usage {
    print <<END_USAGE;
Usage: generic-setup [options] [pkg1 pkg2 ...]

  Scan the distribution specific directories distro/\$distro\$version-\$arch
  and the common directory (distro/common-rpms) for best packages for
  current or specified architecture (or noarch). Either copy the package
  files to the OSCAR package repository or delete them from there.

  If package names are passed as arguments, actions are limited to these
  packages.

  When copying in packages, if a file named \$pkg.txt exists, it will be
  displayed in the STDOUT of the command as comment.

 Options:
   --arch|-a      : override locally detected architecture
   --distro  D-V  : translated distro string (for testing only!)
   --help|-h      : display this help text
   --pool|-p path : override setting of pool path
   --test|-t      : just test without copying or erasing files
   --verbose|-v   : verbose printout
END_USAGE
   exit(1);
}

