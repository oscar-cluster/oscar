#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Copyright © 2003, The Board of Trustees of the University of Illinois. All rights reserved.
# Copyright 2003 NCSA
#                Neil Gorsuch <ngorsuch@ncsa.uiuc.edu>

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib","$ENV{OSCAR_HOME}/lib/OSCAR","../../../lib","../../../lib/OSCAR";
use OSCAR::Package;
use OSCAR::Network;
use oda;
use Data::Dumper;
use OSCAR::Distro;
use OSCAR::Database;

################################################################
#                                                              #
#  Set the multiple_package_versions variable to any non-zero  #
#  value to allow multiple packages records for the same       #
#  package with different package versions to be stored in     #
#  database. The Oscar package selector will only allow one    #
#  version of any package to be selected in each package set   #
#  in any event. Setting the variable to zero will allow only  #
#  one version of each package to be stored in the database.   #
#                                                              #
my $multiple_package_versions = 0;                             #
#                                                              #
################################################################

my $folding_character = "_";
my %list_of_multiple_value_folded_fields = ();
#my %multiple_value_folded_fields = ();
my %oda_fieldnames = ();
my %oda_shortcuts = ();
my %options = ();
my $package_tables_name_prefix = "package_";
my $packages_table_name = "packages";
#my %single_value_folded_fields = ();

# function to insert a particular database table record 
# if it doesn't exist already
# inputs:  options_ref       pointer to command option parameters
#                            hash to pass to oda functions
#          table_name        string 
#          match_record_ref  pointer to a hash of the record
#                            with field names being the keys
#                            and field values being the values
#                            that will be matched
#          write_record_ref  optional pointer to a hash of 
#                            the record that will be written
#                            with field names being the keys
#                            and field values being the values,
#                            if not specified, the match record
#                            values will be written

sub insert_or_verify_record {
    my( $options_ref, 
	$table_name,
	$match_record_ref,
	$write_record_ref ) = @_;

    if ( $$options_ref{debug} ) {
	print_hash( "",
		    "$0: in insert_or_verify_record table_name=<$table_name> match_record_ref=",
		    $match_record_ref );
	print_hash( "",
		    "$0: write_record_ref=",
		    $write_record_ref ) 
	    if defined $write_record_ref;
    }

    # see if there are any matching records
    my @tables_fields = ( "$table_name" );
    my @wheres = ();
    foreach my $key ( keys %$match_record_ref ) {
	push @tables_fields, $key;
	push @wheres, "$table_name.$key = \"$$match_record_ref{$key}\"";
    }
    my @already_existing_records = ();
    my @error_strings = ();
    if ( ! oda::read_records( $options_ref,
			      \@tables_fields,
			      \@wheres,
			      \@already_existing_records,
			      1 ) ) {
	oda::disconnect( \%options,
			 \@error_strings );
	warn shift @error_strings while @error_strings;
	exit 1;
    }

    # if there are already existing matching records, ...
    if ( @already_existing_records ) {

	# ... and there was no specified write record 
	# we can just assume it's all right to leave
	# the already existing record(s) alone and we're
	# done with this function
	return if ! defined $write_record_ref;

	# Since there were already existing matching
	# records, and there was a specified write record 
	# (which is presumed to be different than the
	# matching record), we need to get rid of all
	# previously existing matching records
	my @error_strings = ();
	my @tables = ( "$table_name" );
	if ( ! oda::delete_records( $options_ref,
				    \@tables,
				    \@wheres,
				    \@error_strings ) ) {
	    oda::disconnect( \%options,
			     \@error_strings );
	    warn shift @error_strings while @error_strings;
	    exit 1;
	}

    }

    # at this point we need to write out the new record
    my $record_ref = ( defined $write_record_ref ) ?
	$write_record_ref : $match_record_ref;
    my @assigns = ();
    foreach my $key ( keys %$record_ref ) {
	push @assigns, "$table_name.$key = \'$$record_ref{$key}\'";
    }
    if ( ! oda::insert_record( $options_ref,
			       $table_name,
			       \@assigns,
#			       ( defined $write_record_ref ) ?
#			       $write_record_ref : $match_record_ref,
			       undef,
			       \@error_strings ) ) {
	oda::disconnect( \%options,
			 \@error_strings );
	warn shift @error_strings while @error_strings;
	exit 1;
    }
}

# function to create a database table with the
# proper field definitions if the table doesn't
# already exist, or add any missing fields
# if the table already exists.
#
# inputs:  options_ref       pointer to command option parameters
#                            hash to pass to oda functions
#          table_name        string 
#          fields_params_ref pointer to a hash of the
#                            wanted field names and parameters

sub make_fix_table_fields{
    my ( $options_ref,
	 $table_name, 
	 $table_parameters,
	 $fields_params_ref ) = @_;

    print_hash( "", "$0: in make_fix_table_fields table_name=<$table_name> fields_params=",
		$fields_params_ref )
	if $$options_ref{debug};

    # get a list of the tables and fields
    # that are already in the database
    my @error_strings = ();
    my $existing_tables_fields_ref = 
      oda::list_tables_fields( $options_ref,
			       \@error_strings );
    warn shift @error_strings while @error_strings;

    # check if the table in question exists
    if ( ! exists $$existing_tables_fields_ref{ $table_name } ) {
	print "Creating database table $table_name\n";
	print_hash( "", "in make_fix_table_fields adding table <$table_name> fields=",
		    $fields_params_ref ) if $$options_ref{debug};
	@error_strings = ();
	if ( ! oda::create_table( $options_ref,
				  $table_name,
				  $table_parameters,
				  $fields_params_ref,
				  \@error_strings ) ) {
	    oda::disconnect( $options_ref,
			     \@error_strings );
	    warn shift @error_strings while @error_strings;
	    exit 1;
	  }
#	$existing_tables_fields_ref = 
#	  oda::list_tables_fields( $options_ref,
#				   \@error_strings );
#	my %table_hash = ();
#	$$existing_tables_fields{ $table_name } = \%table_hash;
    } else {
	my $table_hash_ref = $$existing_tables_fields_ref{ $table_name };
	foreach my $field_name ( sort keys %$fields_params_ref ) {
	    if ( ! exists $$table_hash_ref{ $field_name } ) {
		print "Adding to database table $table_name field $field_name" .
		    (( exists $$fields_params_ref{$field_name} &&
		       $$fields_params_ref{$field_name} ne "" ) ?
		     " with parameters $$fields_params_ref{$field_name}" : "" ) .
		     "\n";
		my %new_field;
		$new_field{ $field_name } =
		    $$fields_params_ref{ $field_name };
		my @error_strings = ();
		if ( ! oda::add_fields( $options_ref,
					$table_name,
					\%new_field,
					\@error_strings ) ) {
		    oda::disconnect( $options_ref,
				     \@error_strings );
		    warn shift @error_strings while @error_strings;
		    exit 1;
	        }
	    }
	}
    }
}

# function to do a debug print of a hash
# inputs: leading_spaces  string to put in front of lines
#         name            string to print as the hash name
#         hash_ref        pointer to the hash to print       

sub print_hash {
    my( $leading_spaces, $name, $hashref ) = @_;
    print "$0: $leading_spaces$name ->\n";
    foreach my $key ( sort keys %$hashref ) {
	my $value = $$hashref{$key};
	if (ref($value) eq "HASH") {
	    print_hash(  "$leading_spaces    ", $key, $value );
	} elsif (ref($value) eq "ARRAY") {
	    my $string = join(',', @$value);
	    print "$0: $leading_spaces    $key => ($string)\n";
	} elsif (ref($value) eq "SCALAR") {
	    print "$0: $leading_spaces    $key is a scalar ref\n";
	    print "$0: $leading_spaces    $key => $$value\n";
	} else {
	    $value = "undef" unless defined $value;
	    print "$0: $leading_spaces    $key => <$value>\n";
	}
    }
}

# note that this will leave arrays of hash references
# in the output tree unchanged (without unfolding)

sub recursive_fold_fields{
    my ( $options_ref,
	 $single_values_ref, 
	 $multiple_values_ref,
	 $level_ref, 
	 $input_ids_list_ref ) = @_;
    foreach my $level_key ( sort keys %$level_ref ) {
	my $level_value = $$level_ref{$level_key};
	my $folded_fields_id = join( '_', 
				     @$input_ids_list_ref,
				     $level_key );
	if ( ref( $level_value ) eq "HASH" ) {
	    my @ids_list = ( @$input_ids_list_ref,
			     $level_key );
	    recursive_fold_fields( $options_ref,
				   $single_values_ref,
				   $multiple_values_ref,
				   $level_value, 
				   \@ids_list );
	} elsif ( ref( $level_value ) eq "ARRAY" ) {
	    print "$0: adding folded field <$folded_fields_id> value <$level_value> to multiple values tables\n"
		if $$options_ref{debug};
	    $$multiple_values_ref{ $folded_fields_id } =
		$level_value;
	    $list_of_multiple_value_folded_fields
	    { $folded_fields_id } = 1;
	} else {
	    $$single_values_ref{ $folded_fields_id } =
		$level_value;
	}
	delete $$level_ref{$level_key};
    }
}

sub usage {
    my ( $exit_status, @error_strings ) = @_;
    my $progname = $0;
    print <<USAGE;

$progname directory [ package_name [ package_version ] ]

$progname reads a config.xml file for a single package
from a specified directory.  It parses database information
from that file, and stores it into the Oscar database.
Any previously existing database information for that
version of that package is removed from the database before 
inserting information from the config.xml file.
The only database fields in the package records that are
preserved are: installable.

Options:
  --debug             turns on debug output
  --database=DATABASE database name, default is oscar
  --help              prints out usage information then exits
  --host=HOST         database host, default localhost
  --nodebug           turns off debug output
  --password=PASSWORD database password, default allows access
  --port=PORT         database port number, default 3306
  --noverbose         turns off verbose output
  --type=DATABASETYPE set the database type, default is mysql
  --user USER         database user id, default anonymous if non-root
  --verbose           turns on verbose output

Usage:
$progname [options]

USAGE
    if ( @error_strings ) {
	print "\n";
	warn shift @error_strings while @error_strings;
    }
    exit $exit_status;
}

# find the base directory of the oscar distribution,
my $oscar_home;
# first try the environmental variable
if ( exists $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
    die "$0: bad OSCAR_HOME environmental variable value <$oscar_home>"
	if ( ! -d "$oscar_home");
} 
# or if that fails, try to figure out the directory we're running from
else {
    $oscar_home = $0;
    my $cwd = `pwd`;
    chomp $cwd;
    $oscar_home = $cwd . '/' . $oscar_home
	if $oscar_home !~ /^\//;   # prepend current dir if not abs
    $oscar_home =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
    $oscar_home =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
    $oscar_home =~ s,/\./,/,g;                 # change /./       to /
    $oscar_home =~ s,/packages/[^/]+/scripts/,/,g;
    $oscar_home =~ s,/[^/]+$,,;  # Remove the name of the program
    die "$0: bad calculated oscar base directory $oscar_home"
	if ( ! -d "$oscar_home");
    $ENV{OSCAR_HOME} = $oscar_home;
}
print "$0: oscar_home=<$oscar_home>\n" if $options{debug};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("bundling");    # allow -a -b or -ab
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

# set default option values
my %options = ( 'debug'       => 0,
                'verbose'     => 0 );

# parse command line options
GetOptions( \%options,
            'database|d=s',
            'debug!',
            'help',
            'host|h=s',
            'password=s',
            'port|p=i',
            'type|t=s',
            'user|u=s',
            'verbose!',
            'version' )
    || usage(1);
print "$0: after GetOptions ARGV=<@ARGV>\n" if $options{debug};
oda::print_hash( "", "$0: options after GetOptions", \%options) if $options{debug};

# --help flag just prints out usage information and exits
usage( 0 ) if exists $options{help};

# there has to be a directory argument
usage( 1, "Missing package directory name argument" )
    if ! @ARGV;
my $directory_argument = shift @ARGV;
my $package_directory = $directory_argument;
$package_directory = `pwd` . "/$package_directory" 
    if $package_directory !~ /^\//;
$package_directory =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
$package_directory =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
$package_directory =~ s,/\./,/,g;                 # change /./       to /
$package_directory =~ s,/$,,;       # take / off the end
print "$0: package_directory=<$package_directory>\n" if $options{debug};
usage( 1, 
       ( "$package_directory " . 
	 ( ( $directory_argument ne $package_directory ) ?
	   "(argument $directory_argument) " : "" ) .
	 "is not a directory" ) )
    if ! -d "$package_directory";

# there might be a package short name argument, if not,
# take the last portion of the directory path,
my $package_name;
if ( @ARGV ) {
    $package_name = shift @ARGV;
} else {
    $package_name = $package_directory;
    $package_name = $package_name . "/" if $package_name !~ /\/$/;
    $package_name =~ s,/\.\./[^/][^/][^/]+/,/,g; # change /../???*/ to /
    $package_name =~ s,/\.\./[^\./][^\./]/,/,g;  # change /../??/   to /
    $package_name =~ s,/\./,/,g;                 # change /./       to /
    $package_name =~ s,/$,,;       # take / off the end
    $package_name =~ s,^.*/,,;     # take */ off the beginning
    usage(1, "Cannot determine package name from directory $package_directory" )
	if $package_name eq "";
}
print "$0: package_name=<$package_name>\n" if $options{debug};
usage(1,
      "Package name $package_name from directory $package_directory has to start with a letter" )
    if $package_name !~ /^[a-zA-Z]/;
usage(1,
      "Package name $package_name from directory $package_directory has illegal characters" )
    if $package_name !~ /^[a-zA-Z0-9][a-zA-Z0-9\.\_\-]*$/;

# and if there is a package short name argument, there
# might be a package version argument
my $package_version = "";
if ( @ARGV ) {
    $package_version = shift @ARGV;
}

# any arguments left is an error
usage( 1, "unknown argument(s) " . join( ' ', @ARGV ) ) if @ARGV;

# connect to the database
my @error_strings = ();
if ( ! oda::connect( \%options,
		     \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
    die "$0: cannot connect to the OSCAR database";
}

# if a config.xml file does not exist for this package directory,
# we'll fake a simple one, otherwise read it in
my $config_file = "$package_directory/config.xml";
my $xml_ref = undef;
if ( ! -f $config_file ) {
    print "Warning, no $config_file exists, supplying one for package $package_name\n";
} else {
    print "Processing $config_file for package $package_name ...\n";
    my $xs = new XML::Simple(keyattr => {}, forcearray => 
			     [ "site", "uri", 
			       "rpm", "filter",
			       "shortcut", "fieldnames",
			       "requires", "conflicts", "provides" ]);
    $xml_ref = eval { $xs->XMLin( $config_file ); };
    if ($@) {
	print "ERROR, $config_file is invalid, supplying one for package $package_name\n";
        $xml_ref = undef;
    }
}
if ( ! defined $xml_ref ) {
    my %faked_xml;
    $faked_xml{class} = "third-party";
    $faked_xml{description} = "Not provided";
    $faked_xml{name} = $package_name;
    $faked_xml{summary} = "Not provided";
    $xml_ref = \%faked_xml;
}
#$options{debug}=1;
if ( $options{debug} ) {
    print "$0: xml_ref:\n";
    print Dumper($xml_ref);
}
# The function that reads in a package config.xml file 
# outputs a hash of the xml fields and value. For inscance
# if the package config.xml looked like this:
#
# <oscar>
#   <name>package name</name>
#   <filter architecture="ia32">
#   <filter architecture="ia64" distribution="redhat" distribution_version="7.2" >
#   <version>
#     <major>17</major>
#     <minor>2</minor>
#   </version>
#   <package>
#     <oda>
#       <shortcut> abcde fgh ij </shortcut>
#       <shortcut> kl mnop qrst </shortcut>
#       <fieldnames> packages_rpmlist scope </fieldnames>
#     </oda>
#     <packdir1>
#       <tag>tag1</tag>
#       <name>long-tag-1</name>
#     </packdir1>
#   </package>
#   <class>core</class>
#   <rpmlist>
#     <all>
#       <rpm>pack2-rpm-1</rpm>
#       <rpm>pack2-rpm-2</rpm>
#       <rpm>pack2-rpm-3</rpm>
#     </all>
#     <server>
#       <rpm>pack2-rpm-4</rpm>
#       <rpm>pack2-rpm-5</rpm>
#     </server>
#   </rpmlist>
#   <rpmlist>
#     <filter group="oscar_server" distribution="redhat" distribution_version="7.2" />
#     <filter group="oscar_server" distribution="redhat" distribution_version="8.0" />
#     <filter group="oscar_server" distribution="suse" />
#     <rpm>pack2-rpm-6</rpm>
#     <rpm>pack2-rpm-7</rpm>
#   </rpmlist>
#   <rpmlist>
#     <filter group="oscar_clients" />
#     <rpm>pack2-rpm-8</rpm>
#   </rpmlist>
#   <rpmlist>
#     <rpm>pack2-rpm-9</rpm>
#   </rpmlist>
# </oscar>
#
# then the returned hash pointed to by $xml_ref will look like this:
#
# {
#   'name' -> 'package name',
#   'filter' => [
#                 {
#                   'architecture' => 'ia32'
#                 }
#               ],
#               [
#                 {
#                   'architecture' => 'ia64',
#                   'distribution' => 'redhat',
#                   'distribution_versoin' => '7.2'
#                 }
#               ]
#   'version' -> {
#                  'major' -> '17',
#                  'minor' -> '2',
#                }
#   'package' => {
#                    'oda' => {
#                               'fieldnames' => [
#                                                 ' packages_rpmlist scope '
#                                               ],
#                               'shortcut' => [
#                                               ' abcde fgh ij ',
#                                               ' kl mnop qrst '
#                                             ],
#                             },
#                  'packdir1' -> {
#                                  'tag' -> 'tag1',
#                                  'name' -> 'long-tag-1'
#                                }
#                },
#   'class' -> 'core',
#   'rpmlist' -> {
#                  'all' -> {
#                             'rpm' -> [
#                                        'pack2-rpm-1',
#                                        'pack2-rpm-2',
#                                        'pack2-rpm-3'
#                                      ]
#                           },
#                },
#                {
#                  'server' -> {
#                                'rpm' -> [
#                                           'pack2-rpm-4',
#                                           'pack2-rpm-5'
#                                         ]
#                              }
#                },
#                {
#                  'filter' => [
#                                {
#                                  'group' => 'oscar_server',
#                                  'distribution' => 'redhat',
#                                  'distribution_version' => '7.2'
#                                },
#                                {
#                                  'group' => 'oscar_server',
#                                  'distribution' => 'redhat',
#                                  'distribution_version' => '8.0'
#                                },
#                                {
#                                  'group' => 'oscar_server',
#                                  'distribution' => 'suse'
#                                }
#                              ]
#                   'rpm' => [
#                              'pack2-rpm-6',
#                              'pack2-rpm-7'
#                            ],
#                },
#                {
#                  'filter' => [
#                                {
#                                  'group' => 'oscar_clients'
#                                }
#                              ]
#                   'rpm' => [
#                              'pack2-rpm-8
#                            ],
#                },
#                {
#                   'rpm' => [
#                              'pack2-rpm-9'
#                            ],
#                },
# }
#

# Find all the package level 'filter' information, 
# storing it in our filters list for later special 
# processing, swallowing the information from the 
# xml_ref hash.  The above example would end up with 
# this in the filters list:
#
# {
#   'architecture' => 'ia32'
# },
# {
#   'architecture' => 'ia64',
#   'distribution' => 'redhat',
#   'distribution_version' => '7.2'
# }
#
my $package_filters_ref;
print "$0: looking for package filtering data in xml for package <$package_name>\n" 
    if $options{debug};
# if there is a 'filter' key in that, ...
if ( exists $$xml_ref{filter} ) {
    # move it into our seperate package filters list
    $package_filters_ref = $$xml_ref{filter};
    delete $$xml_ref{filter};
}
if ( $options{debug} ) {
    print( "$0: package_filters_ref:\n" );
    print Dumper($package_filters_ref);
#    print "$0: xml_ref after pulling out package filterss:\n";
#    print Dumper($xml_ref);
}

# Find all the 'rpmlist' information, storing the
# information in our rpmlists hash for later special 
# processing, swallowing the information from the 
# xml_ref hash.  The above example would end up with 
# this in the rpmlists list:
#
# {
#   'all' -> {
#              'rpm' -> [
#                         'pack2-rpm-1',
#                         'pack2-rpm-2',
#                         'pack2-rpm-3'
#                       ]
#            },
# },
# {
#    'server' -> {
#                  'rpm' -> [
#                             'pack2-rpm-4',
#                             'pack2-rpm-5'
#                           ]
#                }
# },
# {
#    'filter' => [
#                  {
#                    'group' => 'oscar_server',
#                    'distribution' => 'redhat',
#                    'distribution_version' => '7.2'
#                  },
#                  {
#                    'group' => 'oscar_server',
#                    'distribution' => 'redhat',
#                    'distribution_version' => '8.0'
#                  },
#                  {
#                    'group' => 'oscar_server',
#                    'distribution' => 'suse'
#                  }
#                ]
#     'rpm' => [
#                'pack2-rpm-6',
#                'pack2-rpm-7'
#              ],
# },
# {
#    'filter' => [
#                  {
#                    'group' => 'oscar_clients'
#                  }
#                ]
#     'rpm' => [
#                'pack2-rpm-8
#              ],
# },
# {
#     'rpm' => [
#                'pack2-rpm-9'
#              ],
# }
#
#
my $package_rpmlists_ref;
print "$0: looking for rpmlist data in xml for package <$package_name>\n" 
    if $options{debug};
# if there is an 'rpmlist' key in that, ...
if ( exists $$xml_ref{rpmlist} ) {
    # move the rpmlist data into the rpmlists hash
    $package_rpmlists_ref = $$xml_ref{rpmlist};
    delete $$xml_ref{rpmlist};
}
if ( $options{debug} ) {
    print( "$0: package_rpmlists_ref:\n" );
    print Dumper($package_rpmlists_ref);
#    print "$0: xml_ref after pulling out rpmlists:\n";
#    print Dumper($xml_ref);
}

# Find all 'package'->'oda'->'fieldnames' 
# and all 'package'->'oda'->'shortcut'
# information, storing the information in the
# oda_fieldnames and oda_shortcuts hashes, respectively,
# swallowing the information from the xml_ref hash.
# The above example would end up with this in the 
# oda_fieldnames hash:
#
# {
#   'packages_rpmlist' -> 'scope'
# }
#
# and this in the oda_shortcuts hash:
#
# {
#   'abcde' -> 'fgh ij',
#   'kl' -> 'mnop qrst'
# }
#
print "$0: looking for special oda data in package <$package_name>\n" 
    if $options{debug};
# if there is a 'packages' key in that, ...
if ( exists $$xml_ref{package} ) {
    my $xml_package_package_ref = $$xml_ref{package};
    # if there is an 'oda' key in that, ...
    if ( exists $$xml_package_package_ref{oda} ) {
        print "$0: found oda package information in package <$package_name>\n"
            if $options{debug};
        my $oda_stuff_ref = $$xml_package_package_ref{oda};
        # if there are shortcuts, store them
        if ( exists $$oda_stuff_ref{shortcut} ) {
            my $shortcuts_ref = $$oda_stuff_ref{shortcut};
	    print( "$0: found oda shortcuts information\n" )
		if $options{debug};
	    foreach my $shortcut_line ( @$shortcuts_ref ) {
		# parse out leading word and use it for the shortcut name
		my @fields = grep( !/^$/, 
				   split( /\s+/, $shortcut_line ) );
		my $shortcut = shift @fields;
		my $expansion = join( ' ', @fields );
		print "$0: found shortcut=<$shortcut> value=<$expansion>\n"
		    if $options{debug};
		# store the shortcut if not already stored
		if ( ! exists $oda_shortcuts{$shortcut} ) {
		    $oda_shortcuts{$shortcut} = $expansion;
		} else {
		    warn "$0: duplicated oda shortcut $shortcut specified,\n";
		    warn "ignoring value <$expansion> specified by package $package_name\n";
		    warn "leaving value as previous value <$oda_shortcuts{$shortcut}>,\n";
		}
	    }
	    # now swallow the data from the parsed xml
	    delete $$oda_stuff_ref{shortcut};
	}
        # if there are fieldname specifiers, store them
	if ( exists $$oda_stuff_ref{fieldnames} ) {
	    my $fieldnames_ref = $$oda_stuff_ref{fieldnames};
	    print( "$0: found oda fieldnames information\n" )
		if $options{debug};
	    foreach my $fieldnames ( @$fieldnames_ref ) {
		print "$0: processing fieldnames data <$fieldnames>\n"
		    if $options{debug};
		# parse out leading word and use it for the fieldnames table name
		my @fieldnames_fields = grep( !/^$/, 
					      split( /\s+/, $fieldnames ) );
		my $fieldnames_table = shift @fieldnames_fields;
		# make sure someone else didn't alread define this one
		if ( ! exists $oda_fieldnames{$fieldnames_table} ) {
		    print "$0: storing fieldnames table=<$fieldnames_table> fields=<@fieldnames_fields>\n"
			if $options{debug};
		    $oda_fieldnames{$fieldnames_table} = \@fieldnames_fields;
		} elsif ( $package_name eq "oda" ) {
		    warn "$0: duplicated oda fieldnames $fieldnames_table specified,\n";
		    warn "previous value was <$oda_fieldnames{$fieldnames_table}>,\n";
		    warn "over-riding with oda value <@fieldnames_fields>\n";
		    $oda_fieldnames{$fieldnames_table} = \@fieldnames_fields;
		} else {
		    warn "$0: duplicated oda fieldnames $fieldnames_table specified,\n";
		    warn "ignoring value <@fieldnames_fields> specified by package $package_name\n";
		    warn "leaving value as previous value <$oda_fieldnames{$fieldnames_table}>,\n";
		}
	    }
	    # now swallow the data from the parsed xml
	    delete $$oda_stuff_ref{fieldnames};
	}
    }
}
if ( $options{debug} ) {
    print_hash( "", "$0: oda_shortcuts", \%oda_shortcuts );
    print_hash( "", "$0: oda_fieldnames", \%oda_fieldnames );
    print "$0: xml_ref after pulling out oda shortcuts and fieldnames:\n";
    print Dumper($xml_ref);
}

# Database tables and field names can be explictly 
# defined in package config.xml files, like this:
#
# <oscar>
#   ...
#   <tables>
#     <name1>
#       <fields>
#          <field11> </field11>
#          <field12> </field12>
#       </fields>
#     </name1>
#   </tables>
#   <package>
#     <tables>
#       <name2>
#         <fields>
#            <field13>
#              <attribute1> value1 </attribute1>
#            </field13>
#            <field14> </field14>
#            <field15> </field15>
#         </fields>
#       </name2>
#     </tables>
#   </package>
#   ...
# <oscar>
#
# Only the oda config.xml file can use the first form
# that has tables defined outside the <package> block.
# Table definitions inside the <package> block cause
# the package name to be prepended to the table name.
# For example, if the oda config.xml file looked like
# the above example, database tables with these fields
# would be created:
#
#    table               fields names ...
#
#    name1               field11 field12
#    package_oda_name2   field13 field14 field15
#
# Scan through the $xml_ref pointed to hash,
# storing explicit table/field definitions,
# removing them from the hash.

#print "Looking for explicitly defined database tables and fields ...\n";
print "$0: looking for explicit table/field definitions in package $package_name\n" 
    if $options{debug};
# if there is a 'tables' key in that, ...
if ( exists $$xml_ref{database_tables} ) {
    my $tables_ref = $$xml_ref{database_tables};
    if ( $package_name ne 'oda' ) {
	warn "The config.xml file for package $package_name cannot create\n"
	    . "database tables using a <tables> </tables> block except inside\n"
	    . "a <package> </package> block. Only the oda package\'s config.xml\n"
	    . "can do this. These database tables will not be created:\n"
	    . join(' ', sort keys %$tables_ref ) . "\n";
    } else {
	foreach my $table_name ( sort keys %$tables_ref ) {
	    print "$0: found explicit table $table_name definition in $package_name config.xml\n"
		if $options{debug};
	    my $table_ref = $$tables_ref{$table_name};
	    # if there is a <fields> ... </fields> block
	    # inside this <table> ... </table> block, ...
	    if ( exists $$table_ref{fields} ) {
		my $table_fields_ref = $$table_ref{fields};
		print_hash( "", "$0: for table $table_name table_ref", $table_ref ) if $options{debug};
		my %table_fields = ();
		foreach my $field_name ( sort keys %$table_fields_ref ) {
		    my $table_field_ref = $$table_fields_ref{$field_name};
		    print "$0: found explicit field   $field_name definition in $package_name config.xml\n"
			if $options{debug};
		    $table_fields{$field_name} = 
			( ref($table_fields{$field_name}) eq "HASH" ) ?
			"VARCHAR(250)" : $$table_fields_ref{$field_name};
		}
		my $table_parameters = 
		    ( exists $$table_ref{parameters} ) ?
		    $$table_ref{parameters} : undef;
		make_fix_table_fields( \%options,
				       "$table_name",
				       $table_parameters,
				       \%table_fields );
	    } else {
		warn "The config.xml file for package $package_name is trying\n"
		    . "to define a database table named $table_name using a\n"
		    . "<tables> </tables> block without having any fields\n"
		    . "defined inside that using <field> </field> blocks.\n"
		    . "The database table $table_name will not be created.\n";
	    }
	}
    }
    delete $$xml_ref{database_tables};
}
if ( exists $$xml_ref{package} ) {
    my $package_package_ref = $$xml_ref{package};
    if ( exists $$package_package_ref{database_tables} ) {
	my $tables_ref = $$package_package_ref{database_tables};
	foreach my $table_name ( sort keys %$tables_ref ) {
	    my $full_table_name = "package_" . $package_name . "_" . $table_name;
	    print "$0: found explicit table <$full_table_name> definition in $package_name config.xml\n"
		if $options{debug};
	    my $table_ref = $$tables_ref{$table_name};
	    # if there is a <fields> ... </fields> block 
	    # inside this <table> ... </table> block, ...
	    if ( exists $$table_ref{fields} ) {
		my $table_fields_ref = $$table_ref{fields};
		print_hash( "", "$0: for table $table_name table_ref", $table_ref ) if $options{debug};
		my %table_fields = ();
		foreach my $field_name ( sort keys %$table_fields_ref ) {
		    my $table_field_ref = $$table_fields_ref{$field_name};
		    print "$0: found explicit field   <$field_name> definition in $package_name config.xml\n"
			if $options{debug};
		    $table_fields{$field_name} = 
			( ref($table_fields{$field_name}) eq "HASH" ) ?
			"VARCHAR(250)" : $$table_fields_ref{$field_name};
		}
		my $table_parameters = 
		    ( exists $$table_ref{parameters} ) ?
		    $$table_ref{parameters} : undef;
		make_fix_table_fields( \%options,
				       "$full_table_name",
				       $table_parameters,
				       \%table_fields );
	    } else {
		warn "The config.xml file for package $package_name is trying\n"
		    . "to define a database table named $full_table_name using a\n"
		    . "<tables> </tables> block without having any fields\n"
		    . "defined inside that using <field> </field> blocks.\n"
		    . "The database table $full_table_name will not be created.\n";
	    }
	}
	delete $$package_package_ref{database_tables};
    }
}

# Scan through the config files hash pointed to by
# $xml_ref, converting this kind of information:
#
#    field1 ->
#        subname1 ->
#            subsubname1 -> value1
#            subsubname2 -> value2
#        subname3 -> value3
#        subname4 -> (value4,value5,value6)
#    field2 ->
#        subname5 ->
#            subsubname3 -> (value7,value8)
#    field3 ->
#        subname6 -> value9
#    field4 -> (
#                [ subname7 -> value10
#                  subname8 -> value10 ]
#               ,
#                [ subname9 -> value11
#                  subname10 -> value12 ]
#              )
#
# into the %package_single_value_folded_fields hash as:
#
#    field1_subname1_subsubname1 -> value1
#    field1_subname1_subsubname2 -> value2
#    field1_subname3 -> value3
#    field3_subname6 -> value9
#
# and into %multiple_value_folded_fields hash as:
#
#    field1_subname4 -> (value4,value5,value6)
#    field2_subname5_subsubname3 -> (value7,value8)
#    field4 -> ( HASHsubnames7and8, HASHsubnames9and10 )
#
# and with a flag hash %list_of_multiple_value_folded_fields:
#
# field1_subname4 -> 1
# field2_subname5_subsubname3 -> 1

#print "Looking for database table <packages> implictly defined fields ... \n";

# Go through all of the parsed package config xml files
# hash, for each package that has another level of hashes,
# for each combined field id put it in either the single
# values table or the multiple values table
print "$0: folding fields in xml data for package <$package_name>\n" 
    if $options{debug};
my @field_ids_list = ();
my %package_single_value_folded_fields = ();
my %package_multiple_value_folded_fields = ();
recursive_fold_fields( \%options,
    \%package_single_value_folded_fields,
    \%package_multiple_value_folded_fields,
    $xml_ref,
    \@field_ids_list );

# go through all the single value fields, and if 
# another package had multiple values for the
# same field, move the single value field to the
# multiple value fields tables
foreach my $folded_field_id ( sort keys %package_single_value_folded_fields ) {
    if ( $list_of_multiple_value_folded_fields{ $folded_field_id } ) {
	print "$0: moving package <$package_name> folded field <$folded_field_id> to multiple values tables\n"
	    if $options{debug};
	my @folded_values_list = 
	    $package_single_value_folded_fields{ $folded_field_id };
	$package_multiple_value_folded_fields{ $folded_field_id } =
	    \@folded_values_list;
	delete $package_single_value_folded_fields{ $folded_field_id };
    }
}
if ( $options{debug} ) {
    print_hash( "", "$0: package_single_value_folded_fields",
		\%package_single_value_folded_fields );
    print_hash( "", "$0: list_of_multiple_value_folded_fields",
		\%list_of_multiple_value_folded_fields );
    print "$0: package_multiple_value_folded_fields:\n";
    print Dumper( \%package_multiple_value_folded_fields );
}

# Database tables that are for a particular package
# were put into the package's config.xml file like this:
#
# config.xml file for mpich:
# <oscar>
#   <package>
#     <switcher>
#       <tag>mpi</tag>
#       <name>mpich-1.2.4</name>
#     </switcher>
#   </package>
# </oscar>
#
# This made single_value_folded_fields entries like this:
#
# mpich->
#    package_switcher_name -> <mpich-1.2.4>
#    package_switcher_tag -> <mpi>
#
# These need to be deleted from single_value_folded_fields
# and produce database tables such as package_switcher in 
# this example which would have these fields and records:
#
# package  tag      name
#
#  mpich   mpi   mpich-1.2.4
#   lam    mpi    lam-6.5.7

# scan through the parsed config.xml files hash 
# and find the table names and fields for each
# table for the package specific database tables
#print "Looking for package specific database tables and fields ...\n";
my %package_specific_tables_fields = ();
foreach my $folded_field_id ( sort keys %package_single_value_folded_fields ) {
    # if this is a "package_*_" type field, ...
    if ( $folded_field_id =~ /^package_[^\_]+_[^\_]/ ) {
	# parse the database table name and field id
	my @fields = split( '_', $folded_field_id );
	shift @fields;
	my $table_name = $package_tables_name_prefix . shift @fields;
	my $field_name = join( '_', @fields );
	my $field_value = 
	    $package_single_value_folded_fields{$folded_field_id};
	print "$0: package=<$package_name> ffi=<$folded_field_id> table=<$table_name> field=<$field_name> value=<$field_value>\n"
	    if $options{debug};
	# put a package entry in if not there yet
	if ( ! exists $package_specific_tables_fields{$table_name} ) {
	    my %fields = ();
	    $package_specific_tables_fields{$table_name} =\%fields;
	}
	# get a pointer to the fields hash for this package
	my $tables_fields_ref =
	    $package_specific_tables_fields{$table_name};
	# if we haven't seen this field name yet,
	# save the field id as a lowly INT type
	$$tables_fields_ref{ $field_name } = "INT"
	    if ! exists $$tables_fields_ref{ $field_name };
	# figure out the type of this particular
	# value of this field, and upgrade the
	# type of this field if needed, INT is
	# simplest type, VARCHAR supercedes INT,
	# TEXT supercedes INT and VARCHAR
	if ( length $field_value > 250 ) {
	    $$tables_fields_ref{ $field_name } = "TEXT";
	} elsif ( $field_value !~ /^[0-9]+$/ &&
		  $$tables_fields_ref{ $field_name } eq "INT" ) {
	    $$tables_fields_ref{ $field_name } = "VARCHAR\(255\)";
	}
    }
}
print_hash( "", "$0: package_specific_tables_fields",
	    \%package_specific_tables_fields )
    if $options{debug};
# make the package specific database tables 
# that have been found along with their field
# names and types, adding the "package" field
# to each before making them
foreach my $table_name ( keys %package_specific_tables_fields ) {
    print "$0: making package specific table <$table_name>\n"
	if $options{debug};
    my $tables_fields_ref =
	$package_specific_tables_fields{$table_name};
    $$tables_fields_ref{ package } = "VARCHAR\(255\)";
    make_fix_table_fields( \%options,
			   $table_name,
			   undef,
			   $tables_fields_ref );
}
# scan through the parsed config.xml files hash and
# insert the data into the package specific tables
my %tables_records = ();
foreach my $folded_field_id ( keys %package_single_value_folded_fields ) {
    # if this is a "package_*_" type field, ...
    if ( $folded_field_id =~ /^package_[^\_]+_[^\_]/ ) {
	# parse the database table name and field id
	my @fields = split( '_', $folded_field_id );
	shift @fields;
	my $table_name = $package_tables_name_prefix . shift @fields;
	my $field_name = join( '_', @fields );
	print "$0: package=<$package_name> ffi=<$folded_field_id> table=<$table_name> field=<$field_name>\n"
	    if $options{debug};
	if ( ! exists $tables_records{$table_name} ) {
	    my %record = ();
	    $tables_records{$table_name} =\%record;
	    $record{package} = $package_name;
	}
	my $tables_records_ref = $tables_records{$table_name};
	$$tables_records_ref{$field_name} =
	    $package_single_value_folded_fields{$folded_field_id};
	# get rid of the single_value_folded_fields
	# entry now that we have used it
	delete $package_single_value_folded_fields{$folded_field_id};
    }
}
foreach my $table_name ( keys %tables_records ) {
    my $record_ref = $tables_records{$table_name};
    my @tables_fields = ( "$table_name" );
    my @wheres = ();
    my @already_existing_records = ();
    foreach my $key ( keys %$record_ref ) {
	push @tables_fields, $key;
	push @wheres, "$table_name.$key = \"$$record_ref{$key}\"";
    }
    print_hash( "", "$0: tables_fields=(" . 
		join(',', @tables_fields ) . ") wheres=(" .
		join(',', @wheres ) . ") record",
		$record_ref )
        if $options{debug};
    my @error_strings = ();
    if ( ! oda::read_records( \%options,
			      \@tables_fields,
			      \@wheres,
			      \@already_existing_records,
			      1,
			      \@error_strings ) ) {
	warn shift @error_strings while @error_strings;
    } else {
	print( "$0: returned already existing (" . 
	       join(',', @already_existing_records ) . ")\n" )
	    if $options{debug};
	if ( ! @already_existing_records ) {
	    print_hash( "", "$0: inserting record in table <$table_name>",
			$record_ref )
		if $options{debug};
	    my @error_strings = ();
	    oda::insert_record( \%options,
				$table_name,
				$record_ref,
				undef,
				\@error_strings );
	    warn shift @error_strings while @error_strings;
	}
    }
}
#print_hash( "", "$0: package_field_types", \%package_field_types )
#    if $options{debug};


# Synthesize a master version field if it
# wasn't specified on the command line.
# Then set the version field.
if ( $package_version eq "" ) {
    if ( exists $package_single_value_folded_fields{version} &&
	 defined $package_single_value_folded_fields{version} &&
	 $package_single_value_folded_fields{version} ne "" ) {
	$package_version = $package_single_value_folded_fields{version};
    } else {
	if ( exists $package_single_value_folded_fields{version_major} &&
	     defined $package_single_value_folded_fields{version_major} &&
	     $package_single_value_folded_fields{version_major} ne "" ) {
	    $package_version = $package_single_value_folded_fields{version_major};
	    if ( exists $package_single_value_folded_fields{version_minor} &&
		 defined $package_single_value_folded_fields{version_minor} &&
		 $package_single_value_folded_fields{version_minor} ne "" ) {
		$package_version = $package_version . "." . 
		    $package_single_value_folded_fields{version_minor};
		if ( exists $package_single_value_folded_fields{version_subversion} &&
		     defined $package_single_value_folded_fields{version_subversion} &&
		     $package_single_value_folded_fields{version_subversion} ne "" ) {
		    $package_version = $package_version . "." .
			$package_single_value_folded_fields{version_subversion};
		}
	    }
	    $package_version =~ s/\.0$//;
	    $package_version =~ s/\.0$//;
	    if ( exists $package_single_value_folded_fields{version_release} &&
		 defined $package_single_value_folded_fields{version_release} &&
		 $package_single_value_folded_fields{version_release} ne "" ) {
		$package_version = $package_version . "-" . 
		    $package_single_value_folded_fields{version_release};
	    }
	} else {
	    $package_version = "Unknown";
	}
    }
}
$package_single_value_folded_fields{version} = $package_version;

# Determine the field names and types for the
# packages database table which is a common 
# table for most package information. These
# are the single value fields parsed above.
# (except for ones that start with package_*_
# which make other tables and fields which 
# were already taken care of above).
# Each packages database table has a "name"
# field which is the longer name of the package.
# this will be substituted into the database as
# the "package" field value, and the package 
# directory tree location will be put into the
# "name" field. Since we figured out the size
# of what was listed as the "name" field we
# put that sizing type into the "package" field
# and leave the "name" field in our hash.
# We also need to put the real directory path
# of the package into the "directory" field.

my %package_field_types = ();
$package_single_value_folded_fields{package} =
    $package_single_value_folded_fields{name}
    if exists $package_single_value_folded_fields{name};
$package_single_value_folded_fields{name} = $package_name;
print STDERR
    "$0: Warning,\n" .
    "the config.xml file for package $package_name\n" .
    "has a <directory> block defined with a value of:\n" .
    "$package_single_value_folded_fields{directory},\n" .
    "which will be over-ridden with the actual package\n" .
    "directory location:\n" .
    "$package_directory.\n"
    if exists $package_single_value_folded_fields{directory};
$package_single_value_folded_fields{directory} = $package_directory;
foreach my $folded_field_id ( sort keys %package_single_value_folded_fields ) {
    # if we haven't seen this field name yet,
    # save the field id as a lowly INT type
    $package_field_types{ $folded_field_id } = "INT"
    if ! exists $package_field_types{ $folded_field_id };
# figure out the type of this particular
# value of this field, and upgrade the
# type of this field if needed, INT is
# simplest type, VARCHAR superceded INT,
# TEXT supercedes INT and VARCHAR
my $value = 
    $package_single_value_folded_fields{ $folded_field_id };
if ( length $value > 250 ) {
    $package_field_types{ $folded_field_id } = "TEXT";
} elsif ( $value !~ /^[0-9]+$/ &&
	  $package_field_types{ $folded_field_id } eq "INT" ) {
    $package_field_types{ $folded_field_id } = "VARCHAR\(255\)";
}
#	print "$0: folded_field_id=<$folded_field_id> value=<$value> type=<$package_field_types{ $folded_field_id }>\n"
#	    if $options{debug};
}
print_hash( "", "$0: package_field_types", \%package_field_types )
    if $options{debug};

# create the packages database table with the
# proper field definitions if the table doesn't
# already exist, or add any missing fields
# if the table already exists
make_fix_table_fields( \%options,
		       $packages_table_name,
		       undef,
		       \%package_field_types );

# Write out the packages table record for this
# package if it isn't already in the database.
# If the database already includes a record for
# this package, save a few key field values from
# the previous record, wipe out any other field
# field values from the previous record, and 
# modify the record to have the new values from
# the config.xml file that we just read in.
# Don't forget we already moved the "name"
# field value from the config.xml files into 
# the "package" value and put the package 
# directory location into the "name" field
my @table_fields = ( $packages_table_name );
my @package_record_wheres = ( "packages.name = \"$package_name\"" );
push @package_record_wheres, "packages.version = \"$package_version\""
    if $multiple_package_versions;
my @read_results = ();
my @error_strings = ();
if ( ! oda::read_records( \%options,
			  \@table_fields,
			  \@package_record_wheres,
			  \@read_results,
			  1,
			  \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
} else {
    if ( ! @read_results ) {
	print "Writing a new $packages_table_name record for package $package_name"
	    . ( ( $multiple_package_versions ) ? " version $package_version" : "" ) . "\n";
	@error_strings = ();
	if ( ! oda::insert_record( \%options,
				   $packages_table_name,
				   \%package_single_value_folded_fields,
				   undef,
				   \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	}
    } else {
	print "Modifying existing $packages_table_name record(s) for package $package_name"
	    . ( ( $multiple_package_versions ) ? " version $package_version" : "" ) . "\n";
	print "$0: very strange, there is more than one $packages_table_name record" .
	    "for package $package_name"
	    . ( ( $multiple_package_versions ) ? " version $package_version" : "" ) . "\n"
	    if scalar @read_results > 1;
	# build up a modification hash, start with undefined values for all fields
	my %package_modification_field_values = ();
	my @field_names = ();
	@error_strings = ();
	if ( ! oda::list_fields( \%options,
				 $packages_table_name,
				 \@field_names,
				 \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	}
	foreach my $field_name ( @field_names ) {
	    $package_modification_field_values{$field_name} = undef;
	}
	# Then overwrite with field values with the
	# values read from the package's config.xml.
	# For now, leave the installable field the way
	# that the package's config.xml field was set,
	# since we have to look at the package filtering
	# information to set it and we haven't setup the
	# package filtering information yet.
	foreach my $field_name ( keys %package_single_value_folded_fields ) {
	    $package_modification_field_values{$field_name} =
		$package_single_value_folded_fields{$field_name};
	}

	# a few fields are gotten from the already existing record
#	my $existing_field_values_ref = $read_results[0];
#	foreach my $field_name ( ) {
#	    if ( exists $$existing_field_values_ref{$field_name} &&
#		 defined $$existing_field_values_ref{$field_name} &&
#		 $$existing_field_values_ref{$field_name} ne "" ) {
#		$package_modification_field_values{$field_name} =
#		    $$existing_field_values_ref{$field_name};
#	    }
#	}
	# and the main key fields are not written back out
	delete $package_modification_field_values{id}
	    if exists $package_modification_field_values{id};
	delete $package_modification_field_values{name}
	    if exists $package_modification_field_values{name};
	delete $package_modification_field_values{version}
	    if exists $package_modification_field_values{version} &&
		$multiple_package_versions;
	# now modify the existing record
	@error_strings = ();
	my @modified_tables = ( "$packages_table_name" );
        if ( $options{debug} ) {
            print "$0: package_modification_field_values:\n";
            print Dumper( \%package_modification_field_values );
        }
	if ( ! oda::modify_records( \%options,
				    \@modified_tables,
				    \%package_modification_field_values,
                                    \@package_record_wheres,
                                    \@error_strings ) ) {
	    warn shift @error_strings while @error_strings;
	}
    }
}
    
# any of the fields fields in the package xml that
# had multiple values such as rpmlist or conflicts
# or provides or requires, ended up being parsed 
# into the %multiple_value_folded_fields hash
# with arrays of hash references somewhere down
# the chain of references. we need to take
# the contents that look like this:
#
# package1 ->
#    provides -> ( 
#                  {
#                    type -> type1
#                    name -> name1
#                  }
#                )
#    requires -> ( 
#                  {
#                    type -> type2
#                    name -> name2
#                  }
#                )
#    rpmlist_all_rpm -> ( rpm1, rpm2 )
#               )
# package2 ->
#    rpmlist_all_rpm -> ( rpm3 )
#    rpmlist_server_rpm -> ( rpm4, rpm5 )
#
# This needs to create these 3 new database tables
# with these records of field=value filled in:
#
# package_provides
#    package=package1   type=type1   name=name1
# package_requires
#    package=package1   type=type2   name=name2
# package_rpmlist
#    package=package1   scope=all    rpm=rpm3
#    package=package2   scope=server rpm=rpm4
#    package=package2   scope=server rpm=rpm5

my %multiple_tables_fields = ();
my %multiple_tables_records = ();
print "$0: PMV processing multiple value fields ...\n"
    if $options{debug};
foreach my $folded_name ( sort keys %package_multiple_value_folded_fields ) {
    # figure out what the _ seperated fields are
    my @folded_fields = split( '\_', $folded_name );
    my $first_field = shift @folded_fields;
    # figure out what database table this will go in
    my $table_name = $packages_table_name . "_" . $first_field;
    print "$0: PMV folded=<$folded_name> table=<$table_name> data=\n"
	if $options{debug};
    # get a pointer to the data parsed from xml,
    # this could either be an array of scalar
    # values, or it could be an array of hash 
    # pointers
    my $data_ref = $package_multiple_value_folded_fields{ $folded_name };
    print Dumper( $data_ref ) if $options{debug};
    # see if this is field will make a new database table
    if ( ! exists $multiple_tables_fields{ $table_name } ) {
	print "$0: marking new multiple value database table <$table_name>\n"
	    if $options{debug};
	my %tables_fields = ();
	$multiple_tables_fields{ $table_name } = \%tables_fields;
	my @tables_records = ();
	$multiple_tables_records{ $table_name } = \@tables_records;
	print_hash( "", "$0: updated multiple_tables_fields",
		    \%multiple_tables_fields )
	    if $options{debug};
    }
    # get pointers to the stuff for this database table
    my $tables_fields_ref = $multiple_tables_fields{ $table_name };
    my $tables_records_ref = $multiple_tables_records{ $table_name };
    # see if there were any field names 
    # specified for this table elsewhere
    my @specified_fieldnames = ();
    if ( exists $oda_fieldnames{ $table_name } ) {
	my $fieldnames_ref = $oda_fieldnames{ $table_name };
	foreach my $fieldname ( @$fieldnames_ref ) {
	    push @specified_fieldnames, $fieldname;
	}
	print "$0: multiple values specified_fieldnames=(" .
	    join( ',', @specified_fieldnames ) . ")\n"
	    if $options{debug};
    }
    # get the array of data values
    my @data_array = @$data_ref;
    # we always have a package name field in this database
    $$tables_fields_ref{ package } = "VARCHAR(250)";
    # if the array is filled with hash pointers,
    # that means that each key in the hash will 
    # be a database table field name,
    # with each value coming from that key, the only
    # other database table field name will be the package
    # which will have as data this package name
    if ( ! @data_array ) {
	print "$0: PMV empty data array\n" if $options{debug};
    } elsif ( ref($data_array[0]) eq "HASH" ) {
	foreach my $data_hash_ref ( @data_array ) {
	    my %record = ();
	    $record{ package } = $package_name;
	    foreach my $field_name ( sort keys %$data_hash_ref ) {
		# make sure this field name is going
		# to be in the table
		$$tables_fields_ref{ $field_name } = "VARCHAR(250)"
		    if ! exists $$tables_fields_ref{ $field_name };
		$record{ $field_name } = $$data_hash_ref{ $field_name };
	    }
	    push @$tables_records_ref, \%record;
	}
    } else {
	# all elements in the folded_fields array 
	# database field value except for the last
	# one which is the field name for the data
	# that is in the data_array. the field names
	# for the folded_fields array should be 
	# specified in the specified_fieldnames
	# array, make sure there are enough field
	# names to go around and make some up
	# if not enough
	my $last_field_name = pop @folded_fields;
	my @field_names = ( @specified_fieldnames, $last_field_name );
	my @field_values_except_last = @folded_fields;
	print "$0: specified_fieldnames=(" .
	    join( ',', @specified_fieldnames ) .
	    ") folded_fields=(" .
	    join( ',', @folded_fields ) .
	    ")\n"
	    if $options{debug};
	if ( scalar @specified_fieldnames <
	     scalar @folded_fields ) {
	    warn "$0: specified_fieldnames=(" . join( ',', @specified_fieldnames ) . ") folded_fields=(" . join( ',', @folded_fields ) . ")\n";
	    warn "$0: package $package_name did not supply enough (or any)\n";
	    warn "specified field names with a construct like this:\n";
	    warn "<oscar>\n  <fieldnames> NAMES</fieldnames>\n</oscar>\n";
	    warn "config.xml construct, not storing the data in the\n";
	    warn join( '/', ($first_field, @folded_fields, $last_field_name) ) .
		" having data (" . join( ',', @data_array ) . ")\n";
	} elsif ( scalar @specified_fieldnames >
		  scalar @folded_fields ) {
	    warn "$0: package $package_name supplied too many\n";
	    warn "specified field names with a construct like this:\n";
	    warn "<oscar>\n  <fieldnames> NAMES</fieldnames>\n</oscar>\n";
	    warn "config.xml construct, not storing the data in the\n";
	    warn join( '/', ($first_field, @folded_fields, $last_field_name) ) .
		" having data (" . join( ',', @data_array ) . ")\n";
	} else {
	    foreach my $last_data ( @data_array ) {
		my %record = ();
		my @field_values = ( @field_values_except_last, $last_data );
		$record{ package } = $package_name;
		foreach my $field_name ( @field_names ) {
		    $$tables_fields_ref{ $field_name } = "VARCHAR(250)"
			if ! exists $$tables_fields_ref{ $field_name };
		    $record{ $field_name } = shift @field_values;
		}
		push @$tables_records_ref, \%record;
#		    print_hash( "", "$0: inserting new updated multiple_tables_fields",
#				\%multiple_tables_fields )
#			if $options{debug};
	    }
	}
    }
}
if ( $options{debug} ) {
    print_hash( "", "multiple_tables_fields", \%multiple_tables_fields );
    print "$0: multiple_tables_records:\n";
    print Dumper( \%multiple_tables_records );
}

# make and populate the database tables that we have parsed
foreach my $table_name ( sort keys %multiple_tables_fields ) {
    print "$0: making/updating database table <$table_name>\n" 
	if $options{debug};
    my $table_fields_ref = $multiple_tables_fields{ $table_name };
    if ( keys %$table_fields_ref ) {
	make_fix_table_fields( \%options,
			       $table_name, 
			       undef,
			       $table_fields_ref );
	# write out any records that aren't there already
	my $records_ref = $multiple_tables_records{ $table_name };
	foreach my $record_ref ( @$records_ref ) {
	    insert_or_verify_record( \%options,
				     $table_name,
				     $record_ref );
	}
    } else {
	warn "$0: empty multiple values package table $table_name ignored";
    }
}

# store any found shortcuts in the database
my %shortcuts_fields = ();
$shortcuts_fields{ shortcut } = "VARCHAR(250)";
$shortcuts_fields{ expansion } = "TEXT";
my $shortcuts_table_name = "oda_shortcuts";
make_fix_table_fields( \%options,
		       $shortcuts_table_name,
		       undef,
		       \%shortcuts_fields );
#print "Looking for database shortcut definitions ...";
my $shortcuts_existing = 0;
my $shortcuts_created = 0;
my $shortcuts_updated = 0;
foreach my $shortcut ( sort keys %oda_shortcuts ) {
    my %match_record;
    $match_record{shortcut} = $shortcut;
    my %write_record;
    $write_record{shortcut} = $shortcut;
    $write_record{expansion} = $oda_shortcuts{$shortcut};
    insert_or_verify_record( \%options,
			     $shortcuts_table_name,
			     \%match_record,
			     \%write_record );
}

# get a hash of the package names going to package record ids,
# and find the numeric package id number of this package
my %table_fields = ();
my @wanted_fields = ( "id" );
my $package_names_to_ids_hash_ref =
    database_read_table_fields( "packages",
				\@wanted_fields,
				undef,
				"name",
				1 );
if ( $options{debug} ) {
    print "$0: package_names_to_ids_hash_ref:\n";
    print Dumper( $package_names_to_ids_hash_ref );
}

# now we process the rpmlists data that we
# set aside earlier into the %rpmlists hash. 
# we want to end up with these tables/fields
# from the previous example:
# 
# table packages_rpmlists:
#   record:
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-1
#   record:
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-2
#   record:
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-3
#   record:
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-4
#   record:
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-5
#   record:
#     distribution = redhat
#     distribution_version = 7.2
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-6
#   record:
#     distribution = redhat
#     distribution_version = 8.0
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-6
#   record:
#     distribution = suse
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-6
#   record:
#     distribution = redhat
#     distribution_version = 7.2
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-7
#   record:
#     distribution = redhat
#     distribution_version = 8.0
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-7
#   record:
#     distribution = suse
#     group = oscar_server
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-7
#   record:
#     group = oscar_clients
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-8
#   record:
#   record:
#     group = oscar_clients
#     package_id = numeric id for package 'packdir2' record
#     rpm = pack2-rpm-9
#
my @package_rpm_records_refs = ();
#$options{debug}=1;
if ( ! defined $package_names_to_ids_hash_ref ) {
    warn "Failed to read records from database table packages";
    warn "Cannot store any rpmlist data for package $package_name";
} else {
    print "$0: processing package <$package_name> in rpmlists ...\n"
	if $options{debug};
    # find the packages table numeric identifier for this
    # package record
    if ( ! exists $$package_names_to_ids_hash_ref{$package_name} ) {
	warn "Failed to read a record from database table packages for package $package_name";
	warn "Cannot store any rpmlist data for package $package_name";
    } else {
	my $package_id = $$package_names_to_ids_hash_ref{$package_name}->{id};
#	if ( $options{debug} ) {
#	     print "$0: package_rpmlists_ref:\n";
#	     print Dumper( $package_rpmlists_ref );
#	}
	# we can have either an array of hash references here,
	# or just one hash, either way figure out a list
	# of the hash references to process
	my $hash_refs_ref;
	if ( ref($package_rpmlists_ref) eq "HASH" ) {
	    my @hash_refs = ( $package_rpmlists_ref );
	    $hash_refs_ref = \@hash_refs;
	} else {
	    $hash_refs_ref = $package_rpmlists_ref;
	}
	foreach my $package_rpmlist_ref ( @$hash_refs_ref ) {
	    if ( $options{debug} ) {
		print "$0: package_rpmlist_ref:\n";
		print Dumper( $package_rpmlist_ref );
	    }
	    # if they have an old deprecated style all, server, or client
	    # block, we have to treat it in a special way
	    foreach my $trigger_word ( "client", "server", "all" ) {
		my $scope = undef;
		if ( exists $$package_rpmlist_ref{$trigger_word} ) {
		    $scope = "oscar_clients" if $trigger_word eq "client";
		    $scope = "oscar_server" if $trigger_word eq "server";
		    my $deprecated_hash_ref = $$package_rpmlist_ref{$trigger_word};
		    my $rpms_ref;
		    if ( ! defined ( $rpms_ref = $$deprecated_hash_ref{rpm} ) 
			 || ! @$rpms_ref ) {
			print STDERR
			    "$0: Warning,\n" .
			    "the config.xml file for package $package_name\n" .
			    "has an <rpmlist> block with a <$trigger_word>\n" .
			    "block inside that, but with no <rpm> blocks\n" .
			    "inside that.\n";
		    } else {
			print STDERR
			    "$0: Warning,\n" .
			    "the config.xml file for package $package_name\n" .
			    "has an <rpmlist> block with a <$trigger_word>\n" .
			    "block inside that, which may be deprecated in\n" .
			    "future versions of OSCAR.  That block should\n" .
			    "be changed to something like this:\n" .
			    "     <rpmlist>\n";
			print STDERR
			    "         <filter group=\"$scope\"/>\n"
			    if defined $scope;
			foreach my $rpm ( @$rpms_ref ) {
			    print STDERR "         <rpm>$rpm</rpm>\n";
			}
			print STDERR "     </rpmlist>\n";
			foreach my $rpm ( @$rpms_ref ) {
			    print "$0: packages_rpmlists " .
				( ( defined $scope ) ? "group=<$scope> " : "" ) .
				"package_id=<$package_id> rpm=<$rpm>\n"
				if $options{debug};
			    my %package_rpm_record = ();
			    $package_rpm_record{group} = $scope
				if defined $scope;
			    $package_rpm_record{package_id} = $package_id;
			    $package_rpm_record{rpm} = $rpm;
			    push @package_rpm_records_refs, 
			    \%package_rpm_record;
			}
		    }
		}
	    }
	    if ( exists $$package_rpmlist_ref{rpm} ) {
		my $rpms_ref = $$package_rpmlist_ref{rpm};;
		if ( ! @$rpms_ref ) {
		    print STDERR
			"$0: Warning,\n" .
			"the config.xml file for package $package_name\n" .
			"has an <rpmlist> block with an empty <rpm>\n" .
			"block inside that.\n";
		} else {
		    my $filter_xml_ref;
		    if ( exists $$package_rpmlist_ref{filter} ) {
			$filter_xml_ref = $$package_rpmlist_ref{filter};
		    } else {
			my %empty_filters = ();
			my @empty_filters_list = ( \%empty_filters );
			$filter_xml_ref = \@empty_filters_list;
		    }
		    if ( $options{debug} ) {
			print "$0: filter_xml_ref:\n";
			print Dumper( $filter_xml_ref );
		    }
		    my $filter_hashes_ref;
		    if ( ref($filter_xml_ref) eq "HASH" ) {
			my @single_filter_hash = ( $filter_xml_ref );
			$filter_hashes_ref = \@single_filter_hash;
		    } else {
			$filter_hashes_ref = $filter_xml_ref;
		    }
		    foreach my $filter_hash_ref ( @$filter_hashes_ref ) {
			my $architecture = undef;
			if ( exists $$filter_hash_ref{architecture} ) {
			    $architecture = $$filter_hash_ref{architecture};
			    delete $$filter_hash_ref{architecture};
			}
			my $distribution = undef;
			if ( exists $$filter_hash_ref{distribution} ) {
			    $distribution = $$filter_hash_ref{distribution};
			    delete $$filter_hash_ref{distribution};
			}
			my $distribution_version = undef;
			if ( exists $$filter_hash_ref{distribution_version} ) {
			    $distribution_version = 
				$$filter_hash_ref{distribution_version};
			    delete $$filter_hash_ref{distribution_version};
			}
			my $group = undef;
			if ( exists $$filter_hash_ref{group} ) {
			    $group = $$filter_hash_ref{group};
			    delete $$filter_hash_ref{group};
			}
			foreach my $unknown_key ( keys %$filter_hash_ref ) {
			    print STDERR
				"$0: Warning,\n" .
				"the config.xml file for package $package_name\n" .
				"has an <rpmlist> block with a <rpm> block\n" .
				"inside that, that includes an unknown filter\n" .
				"element <$unknown_key>.\n";
			}
			foreach my $rpm ( @$rpms_ref ) {
			    if ( $options{debug} ) {
				print "$0: packages_rpmlists ";
				print "architecture=<$architecture> "
				    if defined $architecture;
				print "distribution=<$distribution> "
				    if defined $distribution;
				print "distribution_version=<$distribution_version> "
				    if defined $distribution_version;
				print "group=<$group> "
				    if defined $group;
				print "package_id=<$package_id> rpm=<$rpm>\n";
			    }
			    my %package_rpm_record = ();
			    $package_rpm_record{architecture} = $architecture
				if defined $architecture;
			    $package_rpm_record{distribution} = $distribution
				if defined $distribution;
			    $package_rpm_record{distribution_version} = 
				$distribution_version
				if defined $distribution_version;
			    $package_rpm_record{group} = $group
				if defined $group;
			    $package_rpm_record{package_id} = $package_id;
			    $package_rpm_record{rpm} = $rpm;
			    push @package_rpm_records_refs, 
			    \%package_rpm_record;
			}
		    }
		}
	    }
	}
	my @error_strings = ();
	my @tables = ( "packages_rpmlists" );
	my @package_rpmlist_records_wheres = 
	    ( "packages_rpmlists.package_id = \"$package_id\"" );
	push @package_rpmlist_records_wheres,
	    "packages_rpmlists.package_version = \"$package_version\""
	    if $multiple_package_versions;
	if ( ! oda::delete_records( \%options,
				    \@tables,
				    \@package_rpmlist_records_wheres,
				    \@error_strings ) ) {
	    oda::disconnect( \%options,
			     \@error_strings );
	    warn shift @error_strings while @error_strings;
	    exit 1;
	}
    }
}
if ( $options{debug} ) {
    print "$0: package_rpm_records_refs:\n";
    print Dumper( \@package_rpm_records_refs );
}
foreach my $package_rpm_record_ref ( @package_rpm_records_refs ) {
    $$package_rpm_record_ref{package_version} = $package_version
	if $multiple_package_versions;
    insert_or_verify_record( \%options,
			     "packages_rpmlists",
			     $package_rpm_record_ref );
}

# now we process the package filters data that
# we set aside earlier, we want to end up with 
# these tables/fields from the previous example:
# 
# table packages_filters:
#   record:
#     package_id = numeric id for package record
#     architecture = ia32
#   record:
#     package_id = numeric id for package record
#     architecture = ia64
#     distribution = redhat
#     distribution_version = 7.2
#
my @package_filter_records_refs = ();
#$options{debug}=1;
if ( ! defined $package_names_to_ids_hash_ref ) {
    warn "Failed to read records from database table packages";
    warn "Cannot store any package filter data for package $package_name";
} else {
    print "$0: processing package $package_name in filters ...\n"
	if $options{debug};
# find the packages table numeric identifier for this
# package record
    if ( ! exists $$package_names_to_ids_hash_ref{$package_name} ) {
	warn "Failed to read a record from database table packages for package $package_name";
	warn "Cannot store any package filter data for package $package_name";
    } else {
	my $package_id = $$package_names_to_ids_hash_ref{$package_name}->{id};
#	if ( $options{debug} ) {
#	     print "$0: package_filters_ref:\n";
#	     print Dumper( $package_filters_ref );
#	}
	# we can have either an array of hash references here,
	# or just one hash, either way figure out a list
	# of the hash references to process
	my $hash_refs_ref;
	if ( ref($package_filters_ref) eq "HASH" ) {
	    my @hash_refs = ( $package_filters_ref );
	    $hash_refs_ref = \@hash_refs;
	} else {
	    $hash_refs_ref = $package_filters_ref;
	}
	foreach my $filter_xml_ref ( @$hash_refs_ref ) {
	    if ( $options{debug} ) {
		print "$0: filter_xml_ref:\n";
		print Dumper( $filter_xml_ref );
	    }
	    my $filter_hashes_ref;
	    if ( ref($filter_xml_ref) eq "HASH" ) {
		my @single_filter_hash = ( $filter_xml_ref );
		$filter_hashes_ref = \@single_filter_hash;
	    } else {
		$filter_hashes_ref = $filter_xml_ref;
	    }
	    foreach my $filter_hash_ref ( @$filter_hashes_ref ) {
		my $architecture = undef;
		if ( exists $$filter_hash_ref{architecture} ) {
		    $architecture = $$filter_hash_ref{architecture};
		    delete $$filter_hash_ref{architecture};
		}
		my $distribution = undef;
		if ( exists $$filter_hash_ref{distribution} ) {
		    $distribution = $$filter_hash_ref{distribution};
		    delete $$filter_hash_ref{distribution};
		}
		my $distribution_version = undef;
		if ( exists $$filter_hash_ref{distribution_version} ) {
		    $distribution_version = 
			$$filter_hash_ref{distribution_version};
		    delete $$filter_hash_ref{distribution_version};
		}
		my $group = undef;
		if ( exists $$filter_hash_ref{group} ) {
		    $group = $$filter_hash_ref{group};
		    delete $$filter_hash_ref{group};
		}
		foreach my $unknown_key ( keys %$filter_hash_ref ) {
		    print STDERR
			"$0: Warning,\n" .
			"the config.xml file for package $package_name\n" .
			"has a package level filter that includes an\n" .
			"unknown filter element <$unknown_key>.\n";
		}
		if ( $options{debug} ) {
		    print "$0: packages_filters ";
		    print "architecture=<$architecture> "
			if defined $architecture;
		    print "distribution=<$distribution> "
			if defined $distribution;
		    print "distribution_version=<$distribution_version> "
			if defined $distribution_version;
		    print "group=<$group> "
			if defined $group;
		    print "package_id=<$package_id>\n";
		}
		my %package_filter_record = ();
		$package_filter_record{architecture} = $architecture
		    if defined $architecture;
		$package_filter_record{distribution} = $distribution
		    if defined $distribution;
		$package_filter_record{distribution_version} = 
		    $distribution_version
		    if defined $distribution_version;
		$package_filter_record{group} = $group
		    if defined $group;
		$package_filter_record{package_id} = $package_id;
		$package_filter_record{package_version} = $package_version;
		push @package_filter_records_refs, 
		\%package_filter_record;
	    }
	}
	my @error_strings = ();
	my @tables = ( "packages_filters" );
	my @package_filter_records_wheres = 
	    ( "packages_filters.package_id = \"$package_id\"" );
	push @package_filter_records_wheres,
	    "packages_filters.package_version = \"$package_version\""
	    if $multiple_package_versions;
	if ( ! oda::delete_records( \%options,
				    \@tables,
				    \@package_filter_records_wheres,
				    \@error_strings ) ) {
	    oda::disconnect( \%options,
			     \@error_strings );
	    warn shift @error_strings while @error_strings;
	    exit 1;
	}
    }
}
if ( $options{debug} ) {
    print "$0: package_filter_records_refs:\n";
    print Dumper( \@package_filter_records_refs );
}
foreach my $package_filter_record_ref ( @package_filter_records_refs ) {
    insert_or_verify_record( \%options,
			     "packages_filters",
			     $package_filter_record_ref );
}

# Now that the package filters are written into the database for
# this package, determine it's installable field value and set
# that value appropriately.  If this package is the oda package 
# or any core package, it's always installable.
my $installable;
if ( $package_name eq "oda" ) {
    print "$0: setting package oda installable\n" if $options{debug};
    $installable = 1;
} elsif ( defined $package_single_value_folded_fields{class} &&
	  $package_single_value_folded_fields{class} eq "core" ) {
    print "$0: setting core package $package_name installable\n"
	if $options{debug};
    $installable = 1;
# otherwise, if there are no package filters for this package,
# the package is installable
} elsif ( ! @package_filter_records_refs ) {
    print "$0: setting filter-less package $package_name installable\n"
	if $options{debug};
    $installable = 1;
} else {
    my ( $architecture,
	 $distribution,
	 $distribution_version ) =
	     database_read_filtering_information( 1 );
    $installable = 0;
    foreach my $record_ref ( @package_filter_records_refs ) {
	if (
	    ( ! defined $$record_ref{architecture} ||
	      ! defined $architecture ||
	      $$record_ref{architecture} eq $architecture )
	    &&
	    ( ! defined $$record_ref{distribution} ||
	      ! defined $distribution ||
	      $$record_ref{distribution} eq $distribution )
	    &&
	    ( ! defined $$record_ref{distribution_version} ||
	      ! defined $distribution_version ||
	      $$record_ref{distribution_version} eq $distribution_version )
	    ) {
	    print "$0: setting package $package_name installable\n"
		if $options{debug};
	    $installable = 1;
	    last;
	}
    }
    print "$0: setting package $package_name non-installable\n"
	if ! $installable && $options{debug};
}
# now modify the existing record
@error_strings = ();
my @modified_tables = ( "$packages_table_name" );
my %modified_fields;
$modified_fields{installable} = $installable;
if ( ! oda::modify_records( \%options,
			    \@modified_tables,
			    \%modified_fields,
			    \@package_record_wheres,
			    \@error_strings ) ) {
    warn shift @error_strings while @error_strings;
    warn "$0: failed to set the installable field for package record $package_name to a value of $installable";
}

oda::disconnect( \%options );
exit 0;
