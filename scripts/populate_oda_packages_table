#!/usr/bin/perl

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Inspired by the package_config_xmls_to_database script which was splitted
# up into prepare_oda and this script.
#
# Copyright (c) 2007 Erich Focht <efocht@hpce.nec.com>
#                    All rights reserved.
#       
# $Id$
#

use strict;
use Getopt::Long;
use lib "$ENV{OSCAR_HOME}/lib", "$ENV{OSCAR_HOME}/lib/OSCAR";
use OSCAR::Database;
use OSCAR::Database_generic;
use OSCAR::oda;
use OSCAR::OCA::OS_Detect;
use OSCAR::PackagePath;
use OSCAR::OpkgDB;
use Data::Dumper;
use Carp;

my @error_strings = ();
my %table_fields_hash = ();
my %options = ( debug => 0 );

if ( (exists $ENV{OSCAR_VERBOSE} && $ENV{OSCAR_VERBOSE} == 10) 
    || $ENV{OSCAR_DB_VERBOSE} || $ENV{OSCAR_DB_DEBUG}){
    $options{debug} = 1;
}
my $oscar_home;
# first try the environmental variable
if (exists $ENV{OSCAR_HOME}) {
    $oscar_home = $ENV{OSCAR_HOME};
    die "[$0]:\n====> bad OSCAR_HOME environmental variable value <$oscar_home>"
	if ( ! -d "$oscar_home");
} else {
    die "\nEnv variable \$OSCAR_HOME is not set!\n";
}

print "[$0]:\n====> oscar_home=<$oscar_home>\n" if $options{debug};

# configure command line options parsing
Getopt::Long::Configure("ignore_case"); # ignore case
Getopt::Long::Configure("bundling");    # allow -a -b or -ab
Getopt::Long::Configure("auto_abbrev"); # allow abbreviated input

# parse command line options
GetOptions( \%options,
            'debug!',
            'help', )
    || usage(1);

print "[$0]:\n====> after GetOptions ARGV=<@ARGV>\n" if $options{debug};

usage (0) if $options{help};

my ($os, $distro_string);

#
# The argument passed on the command line is interpreted as distro string.
# If it is wrong, no opkgs will be detected, so don't worry. We can't
# reverse-lookup compat_distros, anyway, as they correspond to multiple
# distros.
#
if ($ARGV[0]) {
    $distro_string = $ARGV[0];
    #
    # we MUST detect it's OS, it is needed later
    #
    my %pools = &list_distro_pools();
    for my $p (keys(%pools)) {
	my $tos = $pools{$p}{os};
	next if !$tos;
	if (&os_cdistro_path($tos) eq $distro_string) {
	    $os = $tos;
	    last;
	}
    }
    if (!$os) {
	print "\nCould not detect distro $distro_string among\n".
	    "configured distro pools!\n";
	usage(1);
    }
    print "Populating Packages table for distribution: $distro_string\n";
}

if (!$os) {
    $os = &distro_detect_or_die();
    $distro_string = &os_cdistro_string($os);
}

if (!oda::oda_connect( \%options, \@error_strings)) {
    warn shift @error_strings while @error_strings;
    die "[$0]:\n====> cannot connect to the OSCAR database";
}

my %fields = ();
if ((scalar keys %table_fields_hash) == 0) {
    oda::list_fields(\%options,"Packages",\%fields,\@error_strings);
    my %packages_hash = %fields;
    foreach my $field (keys %packages_hash) {
        if($field eq "__group"){ $field = "group"; }
        if($field eq "__class"){ $field = "class"; }
        $packages_hash{$field} = 1;
    }
    $table_fields_hash{"Packages"} = \%packages_hash;
}

#
# All packages are candidates for deletion. Add them to a hash.
#
my %opkg_to_be_deleted = ();
my @opkgs = ();
&get_packages(\@opkgs,\%options,\@error_strings, distro => $distro_string);
foreach my $opkg_ref (@opkgs){
    my $name = $$opkg_ref{package};
    $opkg_to_be_deleted{$name} = $$opkg_ref{version};
}

#
# Get info on all opkgs available in the passed OS repositories
#
my %o = &opkg_hash_available(os => $os);

print "\n[$0]:\n<<<<<===========================".
    " Populating the Packages records starts\n"
    if $options{debug};

#
# The loop over the detected opkgs.
#
foreach my $package (sort(keys(%o))) {

    my $pkg_version;

    # remove package from deletion candidates list
    # but remember the version they had
    if ($opkg_to_be_deleted{$package}) {
	$pkg_version = $opkg_to_be_deleted{$package};
	delete $opkg_to_be_deleted{$package};
    }

    print "\n[$0]:\nPACKAGE : <<<<<<<<<<<<< $package >>>>>>>>>>>>>".
	" : Packages Table\n"
	if $options{debug};

    my %opkg = %{$o{$package}};

    my $package_id = &is_installed($package,$pkg_version);
    if ($package_id) {
	&delete_packages_related_table($package, \%options, \@error_strings);
	&update_packages(\%opkg, "Packages", $package_id, \%table_fields_hash,
			    \%options, \@error_strings);
    } else {
	print Dumper(\%opkg) if $options{debug};
	
	# Insert into "Packages" table
	&insert_packages(\%opkg, "Packages", \%table_fields_hash,
			 \%options, \@error_strings);
    }
}

print "\n[$0]:\n===========================>>>>> ".
    "Populating the Packages records is finished\n"
    if $options{debug};

# Delete the packages to be deleted, i.e. those which we didn't find
# in the current scan of the repositories.
# This needs to clean the tables related to Packages too.
foreach my $pkg (keys %opkg_to_be_deleted){
    if ($opkg_to_be_deleted{$pkg}){
	my $version = $opkg_to_be_deleted{$pkg};
	&delete_packages_related_table($pkg,
				      \%options,
				      \@error_strings,
				      $version);
	my %sel = (package => $pkg, distro => $distro_string,
		   version => $version );
	&delete_package(\%options, \@error_strings, %sel);
    }
}

oda::oda_disconnect( \%options );
exit 0;

##########################################################################
### Internal Functions
##########################################################################

sub is_installed {
    my ($package, $version) = @_;

    print "[$0]:\n====> in is_installed".
	" Checking to see if Packages table has been already populated\n"
        if $options{debug};
    my @results;
    my %scope = ( package => $package, distro => $distro_string );
    $scope{version} = $version if ($version);
    &get_packages(\@results, \%options, \@error_strings, %scope);
    my $res = pop @results;
    return $res->{id};                    
}

sub delete_packages_related_table {
    my ($package,$options_ref,$error_ref) = @_;
    my $where = "";

    my @list_of_tables = ("Packages_servicelists",
                          "Packages_switcher");
    foreach my $table_name (@list_of_tables){
	$where = "WHERE package='$package'";
        &delete_table($options_ref, $table_name, $where ,$error_ref);
    }
}



sub usage {
    my ( $exit_status, @error_strings ) = @_;
    my $progname = $0;
    print <<USAGE;

This program populates the Packages table with information retrieved
from the reachable repositories for a particular distro-version-arch
combination. Without an argument it queries the repositories
corresponding to the machine the program runs on.

An argument of the form DISTRO-VERSION-ARCHITECTURE is used to update
the Packages table with info from repositories different from the
current node's (for example in a heterogeneous cluster). The argument
contains "compatible" distro information, i.e. the directory names in
/tftpboot/oscar, not those in /tftpboot/distro! The passed argument is
verified against the configured distro pools. If you have no distro
pool configured corresponding to this distro, the command won't work.

Options:
  --help            prints out usage information then exits
  --[no]verbose     turns on[off] verbose output, default is off

Usage:
    $progname [options] [distro-version-architecture]

USAGE
    if ( @error_strings ) {
	print "\n";
	warn shift @error_strings while @error_strings;
    }
    exit $exit_status;
}

