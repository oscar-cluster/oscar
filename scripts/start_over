#!/usr/bin/perl -w
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

# $Id$

use strict;
use Carp;
use lib "$ENV{OSCAR_HOME}/lib";
use OSCAR::PackagePath;
use File::Basename;
use Getopt::Long;


# First of all, enforce that the user running this script is 'root'
croak "You must be 'root' to run this script.  Aborting" if ($< != 0);

# Only continue if we're on a configured OSCAR system
my $oscar_home;
if ( exists $ENV{OSCAR_HOME} && -d $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
} else {
    croak "The environment variable \$OSCAR_HOME isn't set!\n".
	"Refusing to continue!!!\n";
}
print "Using $oscar_home as OSCAR base directory\n";
use lib "$ENV{OSCAR_HOME}/lib";

my ($yes, @keep);
GetOptions(
	   "yes|y"       => \$yes,
	   "keep|k=s"    => \@keep;
	   );

if ($yes) {
    $yes = "-y";
} else {
    $yes = "";
}

my %distro_pools = &OSCAR::PackagePath::list_distro_pools();
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_url();
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url();

my @repos = split(",","$distro_pkg_pool,$oscar_pkg_pool");
@repos = map { "--repo $_" } @repos;

print "##### deleting all OSCAR packages and their dependencies #####\n";
my @opkgs = `yume-opkg --list --all`;
@opkgs = map { chomp $_ } @opkgs;

# skip oda package (and keep mysql around)
@opkgs = grep !/^oda$/, @opkgs;


my @orpms;
for my $opkg (@opkgs) {
    my @rpms = `yume-opkg --list --rpms $opkg`;
    @rpms = map { chomp $_ } @rpms;
    push @orpms, @rpms;
}

# skip rpms which were passed on the command line as worthy to stay
my $match = join("|",@keep);
@orpms = grep !/^($match)$/, @orpms;



my @known_services = qw(
                        dhcpd
                        gmond
                        httpd
                        maui
                        named
                        ntpd
                        mysqld
                        pbs_server
                        systemimager
                       );



# delete the oscar database

print "Deleting oda database ...\n";
if(-e '/etc/odapw'){
    eval "use lib \"$oscar_home/lib\"";
    eval "use OSCAR::oda";
    oda::drop_database(undef, undef);
}    
#print "Deleting oda database saved password file ...\n";
#unlink "/etc/odapw";

# find a list of all the services installed by the oscar rpms

print "Searching for services in the oscar rpm files ... ";
my @oscar_services = ();
foreach my $rpm ( @orpms ) {
  my @files = `rpm -ql $rpm`;
  chomp @files;
  my @service_files = grep( /^\/etc\/(rc\.d\/|)init\.d\/[^\/]/, @files );
  foreach ( @service_files ) {
    $_ =~ s,^.*/,,g;
    #print "found service $_ in rpm $oscar_rpm_path\n";
  }
  push @oscar_services, @service_files;
}
@oscar_services = sort_uniq( @oscar_services );
my $services_count = scalar @oscar_services;
print "found these $services_count services:\n";
my $services_string = join ' ', @oscar_services;
print "$services_string\n";

# stop all oscar services

stop_services( @oscar_services );

# Delete the clients first so /etc/hosts gets cleaned
print "Deleting all OSCAR images.\n";
do_command( "/usr/bin/mksimachine --Delete --all" )
  if -x "/usr/bin/mksimachine";


# Delete all opkgs smartly: with yume-opkg

my $cmd = "yume-opkg "$yes." ".join(" ",@repos)." --remove ".join(" ",@opkgs);
do_command($cmd);

# remove prereqs (hardcoded right now)
# (leaving the perl stuff in place, otherwise it might delete more things
#  than expected)
$cmd = "yum ".$yes." remove packman-depman packman-depman-rpms yume";
do_command($cmd);


my %orepo_done;
my $err = 0;
for my $dist (keys %distro_pools) {
    my %d = %{$distro_pools{$dist}};
    my $orepo = $d{oscar_repo};
    next if (exists $orepo_done{"$orepo"});
    print "Removing directory $orepo\n";
    system("rm -rf $orepo");
}

for my $f (glob("$oscar_home/tmp/*.md5")) {
    my $file = basename($f);
    next if ($file =~ /^pool_distro/);
    print "Removing checksum file: $f\n";
    system("rm -f $f");
}

cleanup_files();

delete_oscar_users();

print "
##########################################################################
The OSCAR installation process modifies the environment of both the
shell that it was installed from as well as any shells that were started
after the OSCAR installer was invoked.  

This script does not attempt to clean the environment of this shell.
It is not possible for this script to clean the environment of any
other currently running shells.

It is therefore **HIGHLY** recomended that you logout and log back in
before attempting most actions (including re-installing OSCAR).
##########################################################################
";

sub delete_oscar_users {
  my @oscar_users = qw(
                       oscartst
                      );
  foreach my $oscar_user (@oscar_users) {
    print "Removing user $oscar_user\n";
    do_command("userdel -r $oscar_user");
  }
}

sub stop_services {
  my @found_services = @_;
  my @all_services = ( @found_services, @known_services );
  @all_services = sort_uniq( @all_services );
  foreach my $service (@all_services) {
    do_command( "/etc/init.d/$service stop" ) if -r "/etc/rc.d/init.d/$service";
  }
}


sub cleanup_files {
    #
    # This is a bad and messy routine as it can leave you with RPMs registered
    # in the database but with all files missing. Very very ugly!!! [EF]
    #
  my @dirs = (
              '/opt/kernel_picker',
              '/opt/opium',
              '/etc/systemimager',
              '/etc/dhcpd.conf',
    	      '/etc/odapw',
              '/etc/profile.d/00-modules.*',
              '/etc/profile.d/apitest.*',
              '/etc/profile.d/c3.*',
              '/etc/profile.d/oscar_home.*',
              '/etc/profile.d/pbs-oscar.*',
              '/etc/profile.d/sge.*',
              '/etc/profile.d/ssh-oscar.*', 
              '/etc/systeminstaller',
              '/opt/autoupdate',
              '/opt/env-switcher*',
              '/opt/lam*',
              '/opt/maui',
              '/opt/modules',
              '/opt/mpich*',
              '/opt/pbs',
              '/opt/perl-Qt',
              '/opt/sge',
              '/opt/sync_files',
              '/tftpboot/initrd.img',
              '/tftpboot/kernel',
              '/tftpboot/pxelinux.0',
              '/tftpboot/pxelinux.cfg',
              '/usr/lib/systemimager',
              '/usr/lib/systeminstaller',
              '/var/lib/clamdr',
              '/var/lib/ganglia',
              '/var/lib/mysql',
              '/var/lib/mysqld',
              '/var/lib/oscar',
              '/var/lib/systemimager',
              '/var/lib/systeminstaller',
              '/var/log/systemimager',
              '/var/spool/pbs',
              '/usr/share/systeminstaller/distinfo',
              "$oscar_home/.oscar",
             );
  foreach my $file (@dirs) {

      # trying to make this safer: skip files belonging to installed packages

      my $err = system("rpm -qf $file >/dev/null 2>&1");
      if ($err) {
	  # file belongs to no package
	  print "Executing: rm -rf $file\n";
	  system("rm -rf $file");
      } else {
	  # file belongs to some package
	  print "File/dir $file belongs to some package. Not removing!\n";
      }	  
  }

  # Remove the .configurator.values files from each package directory
  use File::Find ();
  File::Find::find({wanted => \&wanted}, "$oscar_home/packages");
  sub wanted {
    /^\.configurator\.values\z/s && unlink($_);
  }
}

sub do_command {
  my ( $command ) = ( @_ );
  print "$command\n";
  return system( "$command" );
}

# return a sorted, unique lines only version of a passed list

sub sort_uniq {
  my ( @input_list ) = @_;
  my %seen;
  foreach my $value ( @input_list ) {
    $seen{$value}++;
  }
  my @result = sort ( keys %seen );
  return @result;
}
