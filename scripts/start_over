#!/usr/bin/perl -w
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

# Copyright (C) 2006 Bernard Li <bli@bcgsc.ca>
#               All rights reserved

# Completely rewritten:
#  - new package deletion selection
#  - pre-oscar package protection
#  - file removal: protection of non-orphan files
# Copyright (C) 2006 Erich Focht <efocht@hpce.nec.com>
#               All rights reserved
# Copyright (c) 2007 The Trustees of Indiana University.  
#                    All rights reserved.

# Execute this script as root to "uninstall" OSCAR from your headnode.
# It will uninstall all binary packages and other files installed on your
# system as part of the OSCAR installation.
# The OSCAR developers recommend a clean re-install of the OS on the headnode
# as this script is considered experimental.  Use it at your own risk!

# $Id$

use strict;
use Carp;
use lib "$ENV{OSCAR_HOME}/lib","/usr/lib/systeminstaller","/usr/lib/systemimager/perl";
use OSCAR::PackagePath;
use OSCAR::oda;
use SystemInstaller::Tk::Image;
use File::Basename;
use Getopt::Long;

# First of all, enforce that the user running this script is 'root'
croak "You must be 'root' to run this script.  Aborting" if ($< != 0);

# Only continue if we're on a configured OSCAR system
my $oscar_home;
if ( exists $ENV{OSCAR_HOME} && -d $ENV{OSCAR_HOME} ) {
    $oscar_home = $ENV{OSCAR_HOME};
} else {
    croak "The environment variable \$OSCAR_HOME isn't set!\n".
	"Refusing to continue!!!\n";
}
print "Using $oscar_home as OSCAR base directory\n";
use lib "$ENV{OSCAR_HOME}/lib";

my ($yes, @keep);
GetOptions(
	   "yes|y"       => \$yes,
	   "keep|k=s"    => \@keep,
	   );

if ($yes) {
    $yes = "-y";
} else {
    $yes = "";
}

my %distro_pools = &OSCAR::PackagePath::list_distro_pools();
my $oscar_pkg_pool = &OSCAR::PackagePath::oscar_repo_url();
my $distro_pkg_pool = &OSCAR::PackagePath::distro_repo_url();

my @repos = split(",","$distro_pkg_pool,$oscar_pkg_pool");
@repos = map { "--repo $_" } @repos;

print "##### deleting all OSCAR packages and their dependencies #####\n";
my @opkgs = `yume-opkg --list --all`;
@opkgs = map { chomp; $_ } @opkgs;

# skip oda package (and keep mysql around)
@opkgs = grep !/^oda$/, @opkgs;

my @orpms;
for my $opkg (@opkgs) {
    my @rpms = `yume-opkg --list --rpms $opkg`;
    @rpms = map { chomp; $_ } @rpms;
    push @orpms, @rpms;
}

# skip rpms which were passed on the command line as worthy to stay
my $match = join("|",@keep);
@orpms = grep !/^($match)$/, @orpms;

# add prerequisites to deletions
push @orpms, qw( perl-Qt
		 perl-Tk
		 perl-HTML-Tree
		 perl-XML-Simple
		 perl-XML-Parser
		 update-rpms );

my %deleterpms;
#
# EF: Do we have a pre-oscar rpmlist? Only then we can safely uninstall.
#
if (-f "$oscar_home/tmp/pre-oscar.rpmlist") {
    print "========================================================\n";
    print "      first pass on detecting opkg removal impact\n";
    print "========================================================\n";

    print "= = checking whether deleting any opkg would remove pre-oscar rpms\n";
    my @preoscar;
    open IN, "$oscar_home/tmp/pre-oscar.rpmlist" or
	die "Could not open $oscar_home/tmp/pre-oscar.rpmlist : $!";
    @preoscar = <IN>;
    close IN;
    chomp(@preoscar);
    @preoscar = grep !/^\s*\#/, @preoscar;  # ignore commented lines
    @preoscar = grep !/^\s*$/, @preoscar;   # ignore empty lines

    @preoscar = map { quotemeta } @preoscar;
    my $preomatch = join("|",@preoscar);

    for my $r (@orpms) {
	chomp(my $remove = `$oscar_home/scripts/rpms_require $r`);
	my @removes = split(" ",$remove);
	# will any of the pre-oscar rpms be deleted?
	my @m = grep /^($preomatch)$/, @removes;
	if (!scalar(@m)) {
	    $deleterpms{$r} = 1 if (!scalar(@m));
	} else {
	    print "  = skipping $r : triggers deletion of ".
		join(",",@m)."\n";
	}
    }

    my $delmatch = join("|",keys(%deleterpms));

    # EF: second pass: add dependencies of current deletions
    # and add those to the list which don't trigger the deletion of
    # pre-oscar packages

    print "========================================================\n";
    print "      second pass (might take longer...)\n";
    print "========================================================\n";

    for my $r (keys(%deleterpms)) {
	chomp(my $depends = `$oscar_home/scripts/rpm_depends $r`);
	my @deps = split(" ",$depends);

	
	# delete those dependencies from list which are on pre-oscar list
	my @m = grep !/^($preomatch)$/, @deps;

	# which dependencies would trigger pre-oscar deletions?
	for my $d (@m) {

	    # already on deletes list
	    next if (exists($deleterpms{$d}));

	    chomp(my $remove = `$oscar_home/scripts/rpms_require $d`);
	    my @removes = split(" ",$remove);

	    # will any of the pre-oscar rpms be deleted?
	    my @m = grep /^($preomatch)$/, @removes;
	    if (!scalar(@m)) {
		print "  = adding $d\n";
		$deleterpms{$d} = 1  if (!scalar(@m));
	    } else {
		print "  = skipping $d : triggers deletion of ".
		    join(",",@m)."\n";
	    }
	}
    }
}



my @known_services = qw(
                        dhcpd
                        gmond
                        httpd
                        maui
                        named
                        ntpd
                        pbs_server
                        systemimager
                       );


# Update rsyncd.conf file before removing all the OSCAR images
my $rsyncd_conf = "/etc/systemimager/rsyncd.conf";
my $rsync_stubs = "/etc/systemimager/rsync_stubs";
my @images = &list_images;
foreach my $image (@images){
    SystemInstaller::Tk::Image::delfromrsyncd($rsyncd_conf,$image);
}
unlink glob "$rsync_stubs/40*";

# Delete the clients first so /etc/hosts gets cleaned
print "Deleting all OSCAR images.\n";
do_command( "/usr/bin/mksimachine --Delete --all" )
    if -x "/usr/bin/mksimachine";


#
# EF: Use yum directly for deletion, run from cache as deps don't need to be
# constructed from repository info (I hope)...
#
my $cmd = "yum $yes remove ".join(" ",keys(%deleterpms));
my $err = &do_command($cmd);

if ($err) {
    print "yum returned an error, exiting.\n";
    exit 1;
}

my %orepo_done;
$err = 0;
for my $dist (keys %distro_pools) {
    my %d = %{$distro_pools{$dist}};
    my $orepo = $d{oscar_repo};
    next if (exists $orepo_done{"$orepo"});
    print "Removing directory $orepo\n";
    system("rm -rf $orepo");
}

for my $f (glob("$oscar_home/tmp/*.md5")) {
    my $file = basename($f);
    next if ($file =~ /^pool_distro/);
    print "Removing checksum file: $f\n";
    system("rm -f $f");
}

cleanup_files();

delete_oscar_users();

drop_db();

print "
##########################################################################
The OSCAR installation process modifies the environment of both the
shell that it was installed from as well as any shells that were started
after the OSCAR installer was invoked.  

This script does not attempt to clean the environment of this shell.
It is not possible for this script to clean the environment of any
other currently running shells.

It is therefore **HIGHLY** recomended that you logout and log back in
before attempting most actions (including re-installing OSCAR).
##########################################################################
";

# Subroutines below here

sub delete_oscar_users {
  my @oscar_users = qw(
                       oscartst
                      );
  foreach my $oscar_user (@oscar_users) {
    print "Removing user $oscar_user\n";
    do_command("userdel -r $oscar_user");
  }
}

sub cleanup_files {
    #
    # This is a bad and messy routine as it can leave you with RPMs registered
    # in the database but with all files missing. Very very ugly!!! [EF]
    #
  my @dirs = (
              '/opt/kernel_picker',
              '/opt/opium',
              '/etc/systemimager',
              '/etc/dhcpd.conf',
              '/etc/profile.d/00-modules.*',
              '/etc/profile.d/apitest.*',
              '/etc/profile.d/c3.*',
              '/etc/profile.d/oscar_home.*',
              '/etc/profile.d/pbs-oscar.*',
              '/etc/profile.d/sge.*',
              '/etc/profile.d/ssh-oscar.*', 
              '/etc/systeminstaller',
              '/opt/autoupdate',
              '/opt/env-switcher*',
              '/opt/lam*',
              '/opt/maui',
              '/opt/modules',
              '/opt/mpich*',
              '/opt/pbs',
              '/opt/perl-Qt',
              '/opt/sge',
              '/opt/sync_files',
              '/tftpboot/initrd.img',
              '/tftpboot/kernel',
              '/tftpboot/pxelinux.0',
              '/tftpboot/pxelinux.cfg',
              '/usr/lib/systemimager',
              '/usr/lib/systeminstaller',
              '/var/lib/ganglia',
              '/var/lib/mysql',
              '/var/lib/oscar',
              '/var/lib/systemimager',
              '/var/log/systemimager',
              '/var/spool/pbs',
              "$oscar_home/.oscar",
	      '/etc/apache/conf.d/ganglia.conf',
	      '/etc/apache2/conf.d/ganglia.conf',
	      '/etc/httpd/conf.d/ganglia.conf',
	      "$ENV{OSCAR_HOME}/lib/OSCAR/OCA/RM_Detect/SGE.pm",
	      "$ENV{OSCAR_HOME}/lib/OSCAR/OCA/RM_Detect/TORQUE.pm",
             );
  foreach my $pattern (@dirs) {
      # treat each match separately (good for /opt/lam* and alike)
      foreach my $file (glob($pattern)) {
	  # EF: trying to make this safer:
	  # skip files belonging to installed packages
	  my $err = system("rpm -qf $file >/dev/null 2>&1");
	  if ($err) {
	      # file belongs to no package
	      print "Executing: rm -rf $file\n";
	      system("rm -rf $file");
	  } else {
	      # file belongs to some package
	      print "File/dir $file belongs to some package. Not removing!\n";
	  }
      }
  }

  # Remove the .configurator.values files from each package directory
  use File::Find ();
  File::Find::find({wanted => \&wanted}, "$oscar_home/packages");
  sub wanted {
    /^\.configurator\.values\z/s && unlink($_);
  }
}

sub do_command {
  my ( $command ) = ( @_ );
  print "$command\n";
  return system( "$command" );
}

# return a sorted, unique lines only version of a passed list

sub sort_uniq {
  my ( @input_list ) = @_;
  my %seen;
  foreach my $value ( @input_list ) {
    $seen{$value}++;
  }
  my @result = sort ( keys %seen );
  return @result;
}


# delete the oscar database and stop mysqld
sub drop_db {
    my %databases = ();
    my %options = ();
    my @errors = ();
    my $db_type = "";
    oda::list_databases( \%options, \%databases, \@errors);
    if ( $databases{ oscar } ){
        print "Deleting oscar user from mysql database\n";
        print "Deleting oda database ...\n";
        $db_type = oda::remove_oda(\%options, \@errors);
    }

    # Remove the symlink of scripts/oda
    my $oda_link = "/usr/local/bin/oda";
    unlink $oda_link if -e $oda_link;

    # stopping database service, in case it was running before
    # if it gets deleted (the database package), it will be stopped anyway
    if ( $db_type eq "Pg"){
        ! system("/etc/init.d/postgresql stop")
            or croak("Failed to stop postgresql");
    }elsif ( $db_type eq "mysql"){
        for my $s qw( mysql mysqld ) {
            if (-x "/etc/init.d/$s") {
                !system("/etc/init.d/$s stop") or croak("Failed to stop $s");
                last;
            }
        }
    }
}

# get the list of OSCAR images
sub list_images {
    my @list;
    if( open IN, "mksiimage --list |" ) {
        while (<IN>) {
            next if $. <= 2;
            chomp;
            my @items = split;
            push @list, $items[0] if $items[0];
        }
        close IN;
    }
    return @list;
}

