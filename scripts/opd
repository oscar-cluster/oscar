#!/usr/bin/env perl
#
# Copyright (c) 2003, The Board of Trustees of the University of Illinois.
#                     All rights reserved.
# Copyright (c) 2002-2003 The Trustees of Indiana University.  
#                         All rights reserved.
# 
# This file is part of the OSCAR software package.  For license
# information, see the COPYING file in the top level directory of the
# OSCAR source distribution.
#
# $Id: opd,v 1.25 2003/07/17 21:00:52 tfleury Exp $
#

use strict;
use Carp;
use LWP::UserAgent;
use File::Copy;
use Getopt::Long;
use Term::ReadLine;
use Digest::MD5 qw(md5_hex);
use Cwd;
use File::Basename;

# Debugging
use Data::Dumper;

# First of all, enforce that the user running this script is 'root'
# This is necessary for access to /var/cache/oscar/downloads
croak "You must be 'root' to run this script.  Aborting" if ($< != 0);

# Lame hack to set the locale to "C".  If we don't do this, then
# functions like length() may barf on the downloaded binary data
# because they may not conform to the locale's conception of valid
# characters.  I tried using the setlocale() function, but couldn't
# get that to work.  So just reset the LC_ALL environment variable and
# re-exec.  Sigh.

if (($ENV{LC_ALL} && $ENV{LC_ALL} ne "C") ||
    ($ENV{LANG} && $ENV{LANG} ne "C")) {
    $ENV{LC_ALL} = "C";
    $ENV{LANG} = "C";
    exec($0, @ARGV) || 
	die("Could not re-exec to reset the locale properly!\n");
}

# Setup some global variables

my $default_master_location = "SourceForge, USA";
my $default_master_uri = 
    "http://oscar.sourceforge.net/repository/";
my $default_master_name = "Main OSCAR package repository";

my $none_attribute = "<none>";
my $print_pkg_width = 20;
my $screen_width = 78;

my $repository_listing;
my $repository_selected = -1;
my $repository_filename = "oscar_repositories.xml";

my $package_listing;
my $package_filename;
my @packages_selected = ();
my $packages_per_page = 1000000; # For future expansion

my $kilobyte = 1024;
my $megabyte = $kilobyte * 1024;
my $gigabyte = $megabyte * 1024;

my $cachedir = "/var/cache/oscar";
my $downloaddir = "$cachedir/downloads";
my $metadatadir = "$cachedir/opd";
my $expanddir = "/var/lib/oscar/packages";

my $opd_term = new Term::ReadLine 'OPD';

my $argv_master_uri;
my $argv_nomaster;
my $argv_repository_uri;
my $argv_force = 0;
my $argv_noforce = 0;
my $argv_wget = 0;
my $argv_lwp = 0;
my $argv_parsable = 0;
my @argv_packages = ();

my $num_download_retries = 3;
my $ua = -1;

my $empty_di_info = {
    download => 0,
    download_uri_index => -1,
    install => 0
};

# See if we have wget

my $have_wget = 1;
$have_wget = 0 if (system("which wget > /dev/null 2>&1") != 0);

# Do some primitive error checks before we go any further
# See if we have XML::Simple and XML::Parser installed

my $have_xml_parser = 1;
my $have_xml_simple = 1;
eval { require XML::Parser };
$have_xml_parser = 0 if ($@);
eval { require XML::Simple };
$have_xml_simple = 0 if ($@);

# Similar for SHA1 support

my $have_digest_sha1 = 1;
eval { require Digest::SHA1; };
$have_digest_sha1 = 0 if ($@);
my $have_sha1sum = 1;
$have_sha1sum = 0 if (system("which sha1sum > /dev/null 2>&1") != 0);

# Print out some friendly error/warning messages

if (!$have_xml_simple || !$have_xml_parser) {
    print("The OSCAR Package Downloader (OPD) could not be run because you do
not appear to have the prerequsite Perl modules installed.

You appear to be missing:\n");

    print("\tXML::Parser\n") if (!$have_xml_parser);
    print("\tXML::Simple\n") if (!$have_xml_simple);

print("
You may either install these modules manually (try using CPAN), or run
the OSCAR Installer Wizard (which will automatically install them).
If you run the OSCAR Installer Wizard, let it complete its startup
(i.e., install the required Perl modules) and display the initial GUI
menu.  Then click the \"Exit\" button and run OPD again.

You *must* have all packages dowloaded via OPD before performing your
OSCAR installation.

");
    exit(1);
}

if (!$have_digest_sha1 && !$have_sha1sum) {

   print("WARNING: You do not appear to have the Perl module
Digest::SHA1 installed, nor do you have the sha1sum executable
installed.  Packages that use SHA1 sums for verification WILL NOT BE
ABLE TO BE CHECKED!

Although SHA1 support is not *necessary*, you are STRONGLY urged to
quit and install it before downloading any OSCAR packages.  The
Digest::SHA1 Perl module can be easily installed using the Perl CPAN
tool.  For example:

    perl -MCPAN -e \"install Digest::SHA1\"

The sha1sum executable is part of recent versions of the GNU textutils
distribute, available from ftp://ftp.gnu.org/gnu/.

");
}

# Now that we know that we have XML::Simple, use it

my $xs = new XML::Simple(keyattr => {}, forcearray => 
			 [ "site", "uri", "package", "packager", "maintainer",
			   "requires", "conflicts", "provides" ]);


#
# Analyze the command line options
#
sub analyze_argv {
    Getopt::Long::Configure("bundling", "require_order");
    my $ok = Getopt::Long::GetOptions("master|m=s" => \$argv_master_uri,
                                      "repository|r=s" => \$argv_repository_uri,
				      "nomaster" => \$argv_nomaster,
				      "force|f" => \$argv_force,
				      "noforce|n" => \$argv_noforce,
				      "wget" => \$argv_wget,
				      "lwp" => \$argv_lwp,
                                      "parsable" => \$argv_parsable,
                                      "package=s" => \@argv_packages,
                                      );
    if (!$ok) {
        
	print("Usage: $0 [--master|m URI] [--repository|-r URI] 
                ([--force|-f]|[--noforce|-n])
                [--lwp|--wget] 
                [--parsable [--package package_uri]]\n");
	exit(1);
    }

    if ($argv_noforce) {
        $argv_force = 0;
    }
}


#
# Equivalent of "mkdir -p".  Something similar is also in
# Meta::Utils::File::Mkdir, but that's yet another RPM that has to be
# installed (that isn't installed by default).  So we just have
# something relatively simple here.
#
sub mkdir_p {
    my ($dir) = @_;

    # If this dir already exists, return success

    return 1 if (-d $dir);

    # Take the parent directory, make it if necessary

    my @parts = split(/\//, $dir);
    pop @parts;
    my $parent_dir = join("/", @parts);
    return 0 if !mkdir_p($parent_dir);

    # Make the current directory

    if (!mkdir($dir, 0700)) {
        die("ERROR: Unable to create the \"$dir\" directory");
    }

    1;
}


#
# Read the repository listing file, updating it if necessary
#
sub read_repository_listing {
    my $rfilename = "$metadatadir/$repository_filename";
    my $now = time();
    
    # Do we need to update the master repository listing?

    my $want_update = 0;
    $want_update = 1 if (! -f $rfilename || $argv_force);
    if ($want_update == 0 && -f $rfilename) {
	my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
	    $atime, $mtime, $ctime, $blksize, $blocks)
	    = stat($rfilename);
	$want_update = 1 if (($now - $mtime) > (24 * 60 * 60));
    }
    my $uri = $default_master_uri;
    if (defined($argv_master_uri)) {
	$uri = $argv_master_uri;
	$want_update = 1;
    }

    # If we want the update, go download it

    if ($want_update) {
	$uri =~ s/\/$//g;
	my $str = "\$uri =~ s/$repository_filename\$//g";
	eval $str;
	$uri =~ s/\/$//g;

	print("Updating master repository listing from:\n  $uri\n") 
            if (!$argv_parsable);
	my ($happy, $content) = download_from_uri("$uri/$repository_filename",
						  "$rfilename.opd");
	if ($happy == 1) {
	    if (!move("$rfilename.opd", $rfilename)) {
		print ("WARNING: Unable to overwrite $rfilename -- not updated");
	    } else {

		# Update the timestamp on the file that we just
		# downloaded; download agents like wget will use the
		# timestamp from the HTTP header (which may be a long
		# time ago)

		utime $now, $now, $rfilename;
	    }
	} else {
            if ($argv_parsable) {
                die("ERROR: unable to download repository listing");
            } else {
                print("WARNING: Unable to download repository listing\n");
            }
	}
    }

    # Read in the default repositories file
    
    if (-f $rfilename) {
	if (!($repository_listing = 
	      $xs->XMLin($rfilename))) {
	    die("ERROR: Unable to open $rfilename -- Aborting");
	}
    } else {
	die("ERROR: Unable to open $rfilename -- Aborting");
    }

    # Now fill in some data

    $package_filename = $repository_listing->{files}->{package_listing};
}


#
# Download a file from a specific repository.  Return the content or
# an error message indicating what went wrong.
#
sub download_from_uri {
    my ($uri, $local_filename) = @_;
    my $i;
    my $res;

    my $agent;
    my @agents = ();
    my $happy = 0;
    my $msg;
    my $wget_cmd;

    # Allow command line override of preference of download agents.
    # User may wish to use LWP so that proxy settings can be used.

    if ($argv_parsable) {
        $wget_cmd = "wget -q";
    } else {
        $wget_cmd = "wget";
    }

    # If user specified LWP, use it first, else use wget first
    if ($argv_lwp) {
      push(@agents,"LWP");
      push(@agents,$wget_cmd) if ($have_wget);
    } else {
      push(@agents,$wget_cmd) if ($have_wget);
      push(@agents,"LWP");
    }

    for ($i = 0; $i < $num_download_retries * scalar(@agents); ++$i) {
	$agent = $i % scalar(@agents);
	print("Attempting to download using $agents[$agent]:\n  $uri\n")
            if (!$argv_parsable);

	# Use wget

	if ($agents[$agent] =~ /^wget/) {
	    if (!system("$wget_cmd $uri -O $local_filename")) {
		print("Successful!\n\n")
                    if (!$argv_parsable);
		return (1, read_file($local_filename));
	    }
	}

	# Use LWP

	else {
            # If we haven't previously setup LWP, do so now.

            if ($ua == -1) {
                $ua = LWP::UserAgent->new({ env_proxy => 1 });
                $ua->agent("OSCAR package downloader/1.0");
            }

	    my $req = HTTP::Request->new(GET => $uri);
	    $res = $ua->request($req);
	    if ($res->is_success()) {
		open(FILE, ">$local_filename") || 
		    die("ERROR: Could not write to $local_filename");
		print FILE $res->content;
		close(FILE);
		print("Successful!\n\n")
                    if (!$argv_parsable);
		return (1, \$res->content);
	    } else {
		$msg = $res->message;
	    }
	}

        # Only print the message here if we're not in "parsable
        # output" mode

        if (!$argv_parsable) {
            if ($msg) {
                print("Failed: $msg\n");
            } else {
                print("Failed\n");
            }
        }
    }

    print("Failed after $num_download_retries -- giving up\n")
        if (!$argv_parsable);
    return (0, $msg);
}


#
# Utility function to read a file into a returned string
#
sub read_file {
    my $filename = shift;

    my $content = "";
    if (-f $filename) {
	open(FILE, $filename);
	seek(FILE, 0, 2);
	my $size = tell(FILE);
	seek(FILE, 0, 0);
	sysread(FILE, $content, $size);
	close(FILE);
    }

    \$content;
}


#
# Print out the contents of the repository listing, in parsable or
# pretty output
#
sub print_repository_listing {
    my $num_repos = $#{$repository_listing->{site}} + 1;
    my $tmp;

    foreach my $i (0 .. ($num_repos - 1)) {
        my $uri = $repository_listing->{site}[$i]->{uri}[0];
        if (! $uri =~ /\/$/) {
            $uri .= "/";
        }

        if ($argv_parsable) {
            print("\"" . $repository_listing->{site}[$i]->{name} . "\":\"" .
                  $repository_listing->{site}[$i]->{location} ."\":\"" .
                  $repository_listing->{site}[$i]->{uri}[0] . "\"\n");
        } else {
            print(($i + 1) . ". " . $repository_listing->{site}[$i]->{name});
            print(" (default)") if $repository_selected == $i;
            print("\n   ==> " . $repository_listing->{site}[$i]->{uri}[0] .
                  "\n");
        }
    }
}

#
# Make the user select a repository
#
sub select_default_repository {
    my $selection = -1;
    my $num_repos = $#{$repository_listing->{site}} + 1;

    # If the user specified a repository URI on the command line, look
    # for that in the listing

    if ($argv_repository_uri) {
        if (! $argv_repository_uri =~ /\/$/) {
            $argv_repository_uri .= "/";
        }
        foreach my $i (0 .. ($num_repos - 1)) {
            my $uri = $repository_listing->{site}[$i]->{uri}[0];
            if (! $uri =~ /\/$/) {
                $uri .= "/";
            }
            if ($uri eq $argv_repository_uri) {
                $repository_selected = $i;
                last;
            }
        }

        # If we didn't find the URI in the list that we already had,
        # then give the user the benefit of the doubt :-) and make an
        # entry with this URI.

        if ($repository_selected == -1) {
            my $i = $num_repos;
            $repository_listing->{site}[$i]->{name} = 
                "Command-line specified repository";
            $repository_listing->{site}[$i]->{location} = "Unknown";
            $repository_listing->{site}[$i]->{uri}[0] = $argv_repository_uri;
            $repository_selected = $i;
        }
    }

    # Otherwise, nothing was specified on the command line.  So prompt
    # for it for the available list.

    else {
        while (1) {
            print("Please select a default repository:\n\n");
            
            print_repository_listing();
            
            print("\nSelection (1-$num_repos): ");
            $selection = <STDIN>;
            print("\n\n");
            chomp($selection);
            if ($selection > 0 && $selection <= $num_repos) {
                $repository_selected = $selection - 1;
                last;
            }
        }
    }
}


#
# Download the packages file from a repository
#
sub download_packages_file {
    select_default_repository() if ($repository_selected == -1);

    my $file = $repository_listing->{files}->{package_listing};
    my $uri = $repository_listing->{site}[$repository_selected]->{uri}[0];
    my $name = $repository_listing->{site}[$repository_selected]->{name};

    if (! $uri =~ /\/$/) {
	$uri .= "/$file";
    } else {
	$uri .= "$file";
    }

    # Download the packages file

    my $happy;
    my $content;
    my $ffname = "$metadatadir/$package_filename";
    ($happy, $content) = download_from_uri($uri, "$ffname.opd");

    # If we got it, save it to a file.  Then load each entry with an
    # empty download/install info hash

    if ($happy) {
	if (!($package_listing = 
	      $xs->XMLin("$ffname.opd"))) {
	    die("ERROR: Unable to open \"$ffname\" for reading");
	}

	# Overwrite the old file; count how many packages available

	move("$ffname.opd", "$ffname");
	my $num_pkgs = $#{$package_listing->{package}} + 1;
	print((($num_pkgs == 1) ?
	       "Found 1 package" :
	       "Found $num_pkgs packages") . "\n\n\n")
            if (!$argv_parsable);

	# Add empty download/install info hash
	# Automatically mark / override the package as "third party"

	for (my $i = 0; $i < $num_pkgs; ++$i) {
	    $package_listing->{package}->[$i]->{opd} = $empty_di_info;
	    $package_listing->{package}->[$i]->{class} = "third-party";
	    $package_listing->{package}->[$i]->{installable} = "yes";
	}
    } 

    # If we didn't get it, complain

    else {
	die("ERROR: Unable to download \"$uri\" -- Aborting");
    }
}


#
# $page is 1 indexed
# $start_pkg/$end_pkg are 1 indexed
#
sub list_packages_page {
    my ($page) = @_;

    my $num_pkgs = $#{$package_listing->{package}} + 1;
    my $start_pkg = (($page - 1) * $packages_per_page) + 1;
    while ($start_pkg > $num_pkgs) {
	$start_pkg -= $packages_per_page;
	--$page;
    }
    my $end_pkg = $start_pkg + $packages_per_page;
    $end_pkg = $num_pkgs if ($end_pkg > $num_pkgs);

    for (my $i = $start_pkg; $i <= $end_pkg; ++$i) {
        my ($name, $version, $installable, $downloadable, 
            $md5sum, $sha1sum, $size) =
                get_package_info($i);


        # If we're in "parsable output" mode, then print stuff in
        # machine-parsable format

        if ($argv_parsable) {
            my $sep = '":"';
            my $p = $package_listing->{package}[$i - 1];
            my $unwrapped_description = $p->{description};
            $unwrapped_description =~ s/\n/ /g;

            # A bunch of standalone information

            print('"' .
                  $p->{name} . $sep .

                  $p->{version}->{major} . $sep .
                  $p->{version}->{minor} . $sep .
                  $p->{version}->{release} . $sep .
                  $p->{version}->{subversion} . $sep .
                  $p->{version}->{epoch} . $sep .

                  $p->{oscar_version}->{major} . $sep .
                  $p->{oscar_version}->{minor} . $sep .
                  $p->{oscar_version}->{release} . $sep .
                  $p->{oscar_version}->{subversion} . $sep .
                  $p->{oscar_version}->{epoch} . $sep);

            # List of packagers and e-mail addresses

            my $num = $#{$p->{packager}};
            if ($num < 0) {
                print $sep;
            } else {
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{packager}[$i]->{name});
                    print('","') if ($i < $num);
                }
                print $sep;
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{packager}[$i]->{email});
                    print('","') if ($i < $num);
                }
            }
            print $sep;

            # A bunch more stanalone information

            print($unwrapped_description . $sep . 
                  $p->{license} . $sep . 
                  $p->{installable} . $sep . 
                  $p->{group} . $sep . 
                  $p->{summary} . $sep . 
                  $p->{url} . $sep . 
                  $p->{class} . $sep . 
                  $p->{download}->{md5sum} . $sep . 
                  $p->{download}->{sha1sum} . $sep);

            # List of download URIs

            my $num = $#{$p->{download}->{uri}};
            if ($num >= 0) {
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{download}->{uri}[$i]);
                    print('","') if ($i < $num);
                }
            }
            print $sep;

            # List of provides

            my $num = $#{$p->{provides}};
            if ($num < 0) {
                print $sep;
            } else {
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{provides}[$i]->{name});
                    print('","') if ($i < $num);
                }
                print $sep;
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{provides}[$i]->{type});
                    print('","') if ($i < $num);
                }
            }
            print $sep;

            # List of requires

            my $num = $#{$p->{requires}};
            if ($num < 0) {
                print $sep;
            } else {
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{requires}[$i]->{name});
                    print('","') if ($i < $num);
                }
                print $sep;
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{requires}[$i]->{type});
                    print('","') if ($i < $num);
                }
            }
            print $sep;

            # List of conflicts

            my $num = $#{$p->{conflicts}};
            if ($num < 0) {
                print $sep;
            } else {
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{conflicts}[$i]->{name});
                    print('","') if ($i < $num);
                }
                print $sep;
                for (my $i = 0; $i <= $num; ++$i) {
                    print($p->{conflicts}[$i]->{type});
                    print('","') if ($i < $num);
                }
            }

            print("\"\n");
        } 

        # Otherwise, print the information in prettyprint mode

        else {
            my $status="";
            my $end="";

            for (my $j = 0; $j <= $#packages_selected; ++$j) {
                if ($packages_selected[$j] == $i) {
                    $status=" SELECTED PACKAGE [ ";
                    $end=" ]";
                } 
            }

            if (!$status) {
                if ($installable != "yes") {
                    $status="!!! Not Installable !!!";
                    $end="!";
                }
                elsif (!$downloadable){
                    $status="!!! Not Downloadable !!!";
                    $end="!";
                }
            }

            my $oscar_ver = "";
            if (defined($package_listing->{package}[$i - 1]->{oscar_version})) {
                $end .= "\n   (intended for OSCAR v" .
                    build_version_string($package_listing->{package}[$i - 1]->{oscar_version}) .
                    ")";
                
            }

            print("$i.$status $name $version ($size) $end");
            print("\n");
        }
    }
}


#
# Resolve ranges of packages and then apply a function to each package
#
sub do_packages_range {
    my ($func) = @_;
    shift;
    my @ranges = @_;
    my $num_pkgs = $#{$package_listing->{package}} + 1;
    my $start;
    my $end;

    foreach my $r (@ranges) {

    my (@list)=split(/,/,$r);

    foreach $r (@list) {

	if ($r =~ /^[0-9]+$/) {
	    $start = $end = $r;
	} elsif ($r =~ /^[0-9]+-[0-9]+/) {
	    ($start, $end) = split(/-/, $r);
	} else {
	    print("Illegal range ($r) -- ignored\n");
	    next;
	}

	if ($start < 1 || $end > $num_pkgs) {
	    print("Illegal range ($r) -- ignored\n");
	    next;
	}

	for (my $i = $start; $i <= $end; ++$i) {
	    &$func($i);
	}
    }
    }
}


#
# Find the index number of a given package, either of its name or its
# provides name
#
sub find_index {
    my ($name, $top) = @_;
    my $i = -1;

    my $num_reqs = $#{$top->{package}};

    for ($i = 0; $i <= $num_reqs; ++$i) {

	# Check the main name

	return $i if ($top->{package}[$i]->{name} eq $name);

	# Go through the array of provides names

	if ($top->{package}[$i]->{provides}) {
	    my @provides = $top->{package}[$i]->{provides};
	    my $num_provides = $#{$provides[0]};

	    for (my $j = 0; $j <= $num_provides; ++$j) {
		if ($provides[0][$j]->{name} eq $name) {
		    return $i;
		}
	    }
	}
    }

    -1;
}


#
# Build a list of indices of requirements for a specific package
#
sub build_requires_list {
    my ($package_index, $top, $results) = @_;
    my $pkg = $top->{package}[$package_index - 1];

    # JMS This entire routine is just about entirely experimental and
    # unfinished.  Ignore it.

    # If the results reference is empty, fill it with empty lists

    if (!$results) {
	print("Loading initial results\n");
	*$results = { found => [],
		      not_found => [] };
    }

    # Start the main loop

    print("Building requires list for package: " . $pkg->{name} . "\n");

    my $num_reqs = $#{$pkg->{requires}};
    for (my $i = 0; $i <= $num_reqs; ++$i) {
	my $type = $pkg->{requires}[$i]->{type};
	next if ($type ne "package");
	
	my $name = $pkg->{requires}[$i]->{name};
	my $index = find_index($name, $top);
	
	print("Chasing: $name\n");
	
	if ($index >= 0) {
	    
	    # Did we find this one already?

#	    for (my $j = 0; $j <= $#found)
	    my $item = { name => $name,
			 index => $index };
#	    push @found, $item;
#		my %sub_results = build_requires_list($index, $top, \$results);
	} else {
#	    push @not_found, $name;
	}
    }

    # Only assign to $results if there are things to assign

#    my $results = {
#	found => [@found],
#	not_found => [@not_found]
#    };
    print Dumper($results);
    $results;
}


#
# Print a list of selected packages
#
sub list_selected_packages {
    if ($#packages_selected < 0) {
	print("No packages selected\n");
    } else {
	print("Selected packages:\n\n");
	for (my $i = 0; $i <= $#packages_selected; ++$i) {
	    my $pkg = $package_listing->{package}[$packages_selected[$i] - 1];
	    print($pkg->{name} . "\n");
	}
    }
}


#
# Mark a package for downloading
#
sub select_package {
    my ($pkg_index) = @_;
    my $pkg = $package_listing->{package}[$pkg_index - 1];

    # See if we already have this package downloaded

    for (my $i = 0; $i <= $#{$pkg->{download}->{uri}}; ++$i) {
	my @parts = split(/\//, $pkg->{download}->{uri}[$i]);
	my $filename = $parts[$#parts];

	if (-f "$downloaddir/$filename") {
	    print("This package appears to already have been downloaded.
If you wish to download it again, remove the following file:
  $downloaddir/$filename
and then select to download this package again.\n\n");
	    return;
	}
    }

    # Build a requires list for this package

    # JMS Not implemented yet
    #my @reqs = build_requires_list($i, $package_listing, \$results);

    # JMS Not implemented yet
    # Chase down dependencies; tail recursion

    # If it's not already in the list, add this package to the list to
    # be downloaded

    for (my $i = 0; $i <= $#packages_selected; ++$i) {
	if ($packages_selected[$i] == $pkg_index) {
	    print("Package \"" . $pkg->{name} . "\" is already selected\n");
	    return;
	}
    }

    push @packages_selected, $pkg_index;
    print("Package \"" . $pkg->{name} . "\" is selected\n");
}


#
# Print information about a specific package
#
sub print_package {
    my ($i) = @_;
    my $p = $package_listing->{package}[$i - 1];
    my $w = $print_pkg_width;
    my $temp;

    print_pkg_attr($p, $w, "Name", "name", "", "");
    $temp = "Version:";
    print_filled($temp, $w);
    print(build_version_string($p->{version}) . "\n");

    $temp = "OSCAR Version:";
    print_filled($temp, $w);
    if ($p->{oscar_version}) {
        print(build_version_string($p->{oscar_version}) . "\n");
    } else {
        printf("<none>\n");
    }

    print_pkg_attr($p, $w, "Class", "class", "", "");
    print_pkg_attr($p, $w, "Installable", "installable", "", "");

    print_pkg_attr($p, $w, "Summary", "summary", "", "");
    print_pkg_attr($p, $w, "License", "license", "", "");
    print_pkg_attr($p, $w, "Group", "group", "", "");
    print_pkg_attr($p, $w, "Project URL", "url", "", "");
    $temp = "Maintainer:";
    print_filled($temp, $w);
    print(build_name_email_string("maintainer", $p) . "\n");
    $temp = "Packager:";
    print_filled($temp, $w);
    print(build_name_email_string("packager", $p) . "\n");

    print_pkg_array_attr($p, $w, \&build_provides_string, 
			 "Provides", "provides", "", "");
    print_pkg_array_attr($p, $w, \&build_requires_string,
			 "Requires", "requires", "", "");
    print_pkg_array_attr($p, $w, \&build_conflicts_string,
			 "Conflicts", "conflicts", "", "");

    $temp = "Download size:";
    print_filled($temp, $w);
    print(build_size_string($p->{download}->{size}) . "\n");
    print_pkg_attr($p, $w, "Download md5sum", "download", "md5sum", "");
    print_pkg_attr($p, $w, "Download sha1sum", "download", "sha1sum", "");
    $temp = "Download URIs:";
    for ($i = 0; $i <= $#{$p->{download}->{uri}}; ++$i) {
	print_filled($temp, $w);
	print_filled($p->{download}->{uri}[$i], $screen_width - $w);
	print("\n");
	$temp = "";
    }
    print("\n");

    print("Description:\n\n");
    if ($p->{description}) {
	print($p->{description} . "\n");
    } else {
	print("$none_attribute\n");
    }
}


#
# Simple formatting function -- right pad with spaces to desired width
#
sub print_filled {
    my ($text, $w) = @_;

    if (length($text) > $w) {
	print(substr($text, 0, $w - 2) . "..");
    } else {
	my $temp;
	for (my $i = 0; $i < $w - length($text); ++$i) {
	    $temp .= " ";
	}
	print("$text$temp");
    }
    print(" ");
}


#
# Print a filled field name and then a given attribute off a package
#
sub print_pkg_attr {
    my ($p, $w, $text, $a1, $a2, $a3) = @_;
    my $attr;

    if ($a1 && $a2 && $a3) {
	$attr = $p->{$a1}->{$a2}->{$a3};
    } elsif ($a1 && $a2) {
	$attr = $p->{$a1}->{$a2};
    } elsif ($a1) {
	$attr = $p->{$a1};
    }
    $attr = $none_attribute if (!$attr);
    print_filled("$text:", $w);
    print("$attr\n");
}


#
# Similar to print_pkg_attr, but do it for an attribute that is an
# array (i.e., loop over printing all elements in the attribute array)
#
sub print_pkg_array_attr {
    my ($p, $w, $func, $text, $a1, $a2, $a3) = @_;
    my $array;
    my $num_pkgs;

    if ($a1 && $a2 && $a3) {
	$array = $p->{$a1}->{$a2}->{$a3};
    } elsif ($a1 && $a2) {
	$array = $p->{$a1}->{$a2};
    } elsif ($a1) {
	$array = $p->{$a1};
    }
    $num_pkgs = $#{$array} + 1;

    if (!$num_pkgs) {
	print_filled("$text:" , $w);
	print("$none_attribute\n");
    } else {
	$text .= ":";
	for (my $i = 0; $i < $num_pkgs; ++$i) {
	    print_filled($text, $w);
	    print(&$func($array->[$i]) . "\n");
	}
    }
}


#
# Build a version number from its components.  Always show the major
# and minor number, only show the subversion and release numbers if
# they exist.
#
sub build_version_string {
    my ($v) = @_;
    my $out;
    my $temp;

    # Release

    if ($v->{release}) {
	$out = "-" . $v->{release};
    }

    # Subversion

    if ($v->{subversion}) {
	$out = $v->{subversion} . $out;
    }

    # Minor

    if ($v->{minor}) {
	$temp = $v->{minor};
    } else {
	$temp = "0";
    }
    if ($v->{subversion}) {
	$out = "$temp.$out";
    } else {
	$out = "$temp$out";
    }

    # Major

    if ($v->{major}) {
	$out = $v->{major} . ".$out";
    } else {
	$out = "0.$out";
    }

    $out;
}


#
# Build a size string
#
sub build_size_string {
    my ($size) = @_;

    if (!$size) {
	$size = "unknown size";
    } else {
	if ($size < $kilobyte) {
	    $size = "${size}B";
	} elsif ($size < $megabyte) {
	    my $s = int($size / $kilobyte * 10) / 10;
	    $size = "${s}kB";
	} elsif ($size < $gigabyte) {
	    my $s = int($size / $megabyte * 10) / 10;
	    $size = "${s}MB";
	}
    }

    $size;
}


#
# Build the name/e-mail string
#
sub build_name_email_string {
    my ($field, $pkg) = @_;
    my $p = $pkg->{$field};
    my $out;
    my $temp;
    my $addr;
    my $name;

    my $num = $#{$p};
    for (my $i = 0; $i <= $num; ++$i) {
        $addr = ($p->[$i]->{email}) ? "<" . $p->[$i]->{email} . ">" : "";
        $name = ($p->[$i]->{name}) ? $p->[$i]->{name} : "";

        $out .= ", "
            if ($i > 0);
        $out .= "$name "
            if ($name);
        $out .= "$addr"
            if ($addr);
    }
    $out = $none_attribute if (!$out);

    $out;
}


#
# Build the provides string
#
sub build_provides_string {
    my ($provides) = @_;

    $provides->{name} . " (" . $provides->{type} . ")";
}


#
# Build the requires string
#
sub build_requires_string {
    my ($requires) = @_;

    $requires->{name} . " (" . $requires->{type} . ")";
}


#
# Build the conflicts string
#
sub build_conflicts_string {
    my ($conflicts) = @_;

    $conflicts->{name} . " (" . $conflicts->{type} . ")";
}


#
# Return some basic info
#
sub get_package_info {
    my ($i) = @_;
    my $pkg = $package_listing->{package}[$i - 1];

    my $name = $pkg->{name};
    my $version = build_version_string($pkg->{version});
    my $installable = $pkg->{general}->{installable};
    my $downloadable = $pkg->{download}->{uri};
    my $md5sum = $pkg->{download}->{md5sum};
    my $sha1sum = $pkg->{download}->{sha1sum};
    my $size = build_size_string($pkg->{download}->{size});

    ($name, $version, $installable, $downloadable, $md5sum, $sha1sum, $size);
}


#
# Download the selected packages
#
sub download_selected_packages {
    if ($#packages_selected < 0) {
	print("No packages are selected\n");
    } else {
	print(($#packages_selected + 1) . " packages are selected\n");

	my @packages_remaining = ();
	for (my $i = 0; $i <= $#packages_selected; ++$i) {
	    print("\n--> Downloading package " . ($i + 1) . "\n");
	    if (!download_package($packages_selected[$i])) {
		push @packages_remaining, $packages_selected[$i];
	    }
	}
	@packages_selected = @packages_remaining;
    }
}


#
# Download packages listed on the command line
#
sub download_argv_packages {
    my $i;
    my $num_pkgs = $#{$package_listing->{package}};

    # Find the corresponding entry in the repository's listing for
    # each package that was specified on the command line.  Barf if
    # there's a package on the command line that is not in the
    # repository listing.

    PACKAGE_ARGV: foreach my $uri (@argv_packages) {
        for ($i = 0; $i <= $num_pkgs; ++$i) {
            my $p = $package_listing->{package}[$i]->{download}->{uri};
            my $num_uri = $#{$p};
            for (my $j = 0; $j <= $num_uri; ++$j) {
                if ($p->[$j] eq $uri) {
                    download_package($i + 1);
                    next PACKAGE_ARGV;
                }
            }
        }

        if ($i > $num_pkgs) {
            die("ERROR: URI \"$uri\" not found in repository listing");
        }
    }
}


#
# Download a package
#
sub download_package {
    my ($i) = @_;
    my $pkg = $package_listing->{package}[$i - 1];

    # Try downloading the URI's in sequence

    my $success = 0;
    my $happy = 0;
    my $content;
    my $name = $pkg->{name};
    for ($i = 0; $i <= $#{$pkg->{download}->{uri}}; ++$i) {
	$content = undef;
	my @parts = split(/\//, $pkg->{download}->{uri}[$i]);
	my $filename = $parts[$#parts];

	# Download the file

	($happy, $content) = download_from_uri($pkg->{download}->{uri}[$i],
					       "$downloaddir/$filename.opd");
	if ($happy) {

	    # Check the downloaded file size

	    print("- Checking size... ")
                if (!$argv_parsable);
	    if (!$pkg->{download}->{size} ||
		$pkg->{download}->{size} < 0) {
		print("not provided\n")
                    if (!$argv_parsable);
	    } elsif (length($$content) ne $pkg->{download}->{size}) {
                print("ERROR: $pkg->{name} " . length($$content) .
                          " != $pkg->{download}->{size}\n");
		next;
	    } else {
		print("OK\n")
                    if (!$argv_parsable);
	    }

	    # Check the downloaded MD5 sum

	    print("- Checking MD5 sum... ")
                if (!$argv_parsable);
	    if (defined($pkg->{download}->{md5sum}) &&
		$pkg->{download}->{md5sum}) {
		my $digest = md5_hex($$content);
		if ($digest ne $pkg->{download}->{md5sum}) {
		    print("FAILED: $name $digest != $pkg->{download}->{md5sum}\n");
		    next;
		} else {
		    print("OK\n")
                        if (!$argv_parsable);
		}
	    } else {
		print("Not provided\n")
                    if (!$argv_parsable);
	    }

	    # Check the downloaded SHA1 sum

	    print("- Checking SHA1 sum... ")
                if (!$argv_parsable);
	    if (defined($pkg->{download}->{sha1sum}) &&
		$pkg->{download}->{sha1sum}) {
		my $digest;

		if ($have_digest_sha1) {
		    $digest = Digest::SHA1::sha1_hex($$content);
		} elsif ($have_sha1sum) {
		    if (open(SHA1, "sha1sum $downloaddir/$filename.opd|")) {
			($digest) = split(/ /, <SHA1>);
			close(SHA1);
		    }
		} else {
		    print "NO SHA1 SUPPORT INSTALLED: "
                        if (!$argv_parsable);
		}
		if ($digest ne $pkg->{download}->{sha1sum}) {
		    print("FAILED: $name $digest != $pkg->{download}->{sha1sum}\n");
		    next;
		} else {
		    print("OK\n")
                        if (!$argv_parsable);
		}
	    } else {
		print("Not provided\n")
                    if (!$argv_parsable);
	    }

	    # Save the file

	    print("- Saving to $downloaddir/$filename... ")
                if (!$argv_parsable);
	    if (!move("$downloaddir/$filename.opd", 
		      "$downloaddir/$filename")) {
		print("FAILED: could not overwrite $downloaddir/$filename\n");
		next;
	    }
	    print("OK\n")
                if (!$argv_parsable);

	    # If we have OSCAR_HOME, expand the file 

	    print("- Unpacking into $expanddir/... ")
                if (!$argv_parsable);
	    my $cmd = "cd $expanddir ; tar zxf $downloaddir/$filename";
	    if (system($cmd)) {
		print("FAILED: $name could not expand into $expanddir\n");
		next;
	    }
	    print("OK\n")
                if (!$argv_parsable);

	    # If all went well, then this URI was good enough

            print("\"$name\":\"downloaded\":\"expanded\"\n")
                if ($argv_parsable);
	    last;
	} else {
    print("FAILED: could not download $name\n") 
      if ($argv_parsable);
  }

    }
}


#
# Loop over the main menu
#
sub main_menu {
    my $selection;

    my $name = $repository_listing->{site}[$repository_selected]->{name};
    my $uri = $repository_listing->{site}[$repository_selected]->{uri}[0];

    my $num_pkgs = $#{$package_listing->{package}} + 1;
    my $packages = ($num_pkgs == 1) ?
	"1 package available" :
	"$num_pkgs packages available";

    my $show_info = 1;
    my $cmd;
    my @options;

    # Setup tab completion

    my $attribs = $opd_term->Attribs;
    $attribs->{completion_entry_function} =
	$attribs->{list_completion_function};
    $attribs->{completion_word} =
	[qw(download help info list print quit exit repository update)];

    # Main prompt loop

    while (1) {
	
	if ($show_info) {
	    print("
==> $name
==> $uri
==> $packages\n\n");
	    $show_info = 0;
	}

	# Use GNU Readline to prompt and get input.  Readline rocks.

	last if (!defined($_ = $opd_term->readline("opd>")));
	next if (!$_);

	# Analyze what we got back

	@options = split(/[ \t]/);
	$cmd = "";
	while (!$cmd && $#options >= 0) {
	    $cmd = lc($options[0]);
	    shift(@options);
	}
	next if (!$cmd);

	# Change repository

	if (/^r/i || /^repos/i || /^repository/i) {
	    select_default_repository();
	    download_packages_file();
	} 

	# Update oscar_packages.xml file

	elsif (/^u/i || /^up/i || /^upd/i || /^update/i) {
	    print("\n");
	    download_packages_file();
	} 

	# Select package(s) to download

	elsif (/^[0-9]+-[0-9]+/ || /^[0-9]+/ || /^s/i || /^se/i || /^sel/i || /^select/i) {
	    print("\n");
        if (/^[0-9]+-[0-9]+/ || /^[0-9]+/) {
		    do_packages_range(\&select_package, $cmd);
        }
        elsif ($#options < 0) {
		    list_selected_packages();
	    } 
        else {
		    do_packages_range(\&select_package, @options);
	    }
	    print("\n");
	} 

	# Actually do the downloads

	elsif (/^d/i || /^do/i || /^dow/i || /^down/i || /^download/i) {
	    print("\n");
	    download_selected_packages();
	    print("\n");
	} 

	# List the packages that are available

	elsif (/^l/i || /^li/i || /^list/i || /^ls/i ) {
	    print("\n");
	    list_packages_page(1);
	    print("\n");
	} 

	# Print info about a specific package

	elsif (/^p/i || /^pr/i || /^print/i) {
	    print("\n");
	    if ($#options < 0) {
		print("Must supply a range\n");
	    } else {
		do_packages_range(\&print_package, @options);
	    }
	    print("\n");
	} 

	# Print the help message

	elsif (/^\?/ || /^h/i || /^help/i) {
	    print("
[d] download   - Download selected packages
[h] help       - This message
[i] info       - Display repository information
[l] list       - List available packages
[p] print N    - Display information about package N
[q] quit       - Quit
[r] repository - Change repository
R              - Select the specified package(s)
[u] update     - Re-download the packages file from the repository

N has an integer value

R can be a single integer value, a range or an enumeration of all that :

  download 1 3    - marks packages 1 and 3 for downloading
  1,2,5-6         - select packages 1,2,5,6
  download 1 3-5  - marks packages 1, 3, 4, and 5 for downloading\n\n");
	} 

	# Show repository info

	elsif (/^i/i || /^in/i || /^info/i) {
	    $show_info = 1;
	}

	# Exit

	elsif (/^q/i || /^quit/i || 
		 /^e/i || /^exit/i) {
	    last;
	}

	# Have no idea -- issue a warning

	else {
	    print("\nIllegal command -- ignored\n\n");
	}
    }
}

#########################################################################
#
# Main
#
#########################################################################

analyze_argv();

mkdir_p($downloaddir);
mkdir_p($metadatadir);
mkdir_p($expanddir);

# We read the repository listing regardless of what mode we're in
# (e.g., whether --master was specified or not, whether --repository
# was specified or not, etc.) because we need some of the other meta
# data such as the package listing filename, repository listing
# filename, etc.

read_repository_listing() unless $argv_nomaster;
$package_filename ||= $repository_listing->{files}->{package_listing} ||= "/oscar_packages.xml";

# Now act on whether we're in "parsable output" mode or interactive
# mode

if ($argv_parsable) {
    if (@argv_packages) {
        die("ERROR: Must specify --repository with --package")
            if (!$argv_repository_uri);
        download_packages_file();
        download_argv_packages();
    } elsif ($argv_repository_uri) {
        download_packages_file();
        list_packages_page(1);
    } else {
        print_repository_listing();
    }
} else {
    select_default_repository();
    download_packages_file();
    main_menu();
    print("\nGoodbye.\n\n");
}

# All done

exit(0);
