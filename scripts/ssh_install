#!/usr/bin/env perl
#

# $Id$
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#
#
# ssh/sshd installation script for a linux cluster.
#
# Author: Neil Gorsuch ngorsuch@ncsa.uiuc.edu

# This script is meant to be run on a cluster server.  It installs
# openssh/sshd/scp on the server if required, and configures ssh/sshd on
# the server and it's clients so that any user (including root) can
# transparently ssh or scp from this host or any of the clients to this
# host or any of the clients. It can be run as often as needed, before
# or after adding or deleting clients.  All host keys among the clients
# are set the same as on this server.  All root user keys among the
# clients are set the same as on this server. It is assumed that the
# clients that have not been set up yet have a ~root/.rhosts file
# already set up to allow the server to execute commands as root using
# rsh. 

#--------------------- begin configuration section --------------------

# this script requires them to specify one or more directories
# that are the base directories of system images to be updated.

use strict;
use warnings "all";
use File::Path;
use Getopt::Long;

use OSCAR::Env;
use OSCAR::FileUtils;
use OSCAR::Logger;
use OSCAR::LoggerDefs;
use OSCAR::Utils;

my ($verbose,$debug,$quiet);
my (@BASES);

sub help () {
    print "Type \"man $0\" for help information\n";
}

sub help_and_die {
    help ();
    exit 1;
}

sub help_and_exit {
    help ();
    exit 0;
}

GetOptions  (
        "verbose"   => \$verbose,
        "debug"     => \$debug,
        "quiet"     => \$quiet,
            ) || help_and_die();

if ($debug) {
    $ENV{OSCAR_VERBOSE} = 10;
    $OSCAR::Env::oscar_verbose=10;
} elsif ($verbose) {
    $ENV{OSCAR_VERBOSE} = 5;
    $OSCAR::Env::oscar_verbose=5;
} elsif ($quiet) {
    $ENV{OSCAR_VERBOSE} = 0;
    $OSCAR::Env::oscar_verbose=0;
}

foreach my $arg (@ARGV) {
    chomp ($arg);
    push (@BASES, $arg);
}

# We check first that the parameters are images directories
foreach my $b (@BASES) {
    if (! -d $b) {
        oscar_log(1, ERROR, "Invalid parameter; $b is not a valid image directory");
        exit 1;
    }
}

# the directory where ssh/sshd puts host configuration data
my $SSHCFGDIR="/etc/ssh";
if ( ! -d $SSHCFGDIR) {
    File::Path::mkpath ($SSHCFGDIR, 1, 0755) 
        or (oscar_log(1, ERROR, "Unable to create $SSHCFGDIR"), exit 1);
}

#------------------------ end configuration section --------------------

my $cmd;

# make the server host keys if required
# first step: generation of the RSA key
my $file= "$SSHCFGDIR/ssh_host_key";
OSCAR::Logger::oscar_log(5,INFO, "Checking for host key file $file...");
if ( ! -f $file ) {
    OSCAR::Logger::oscar_log(5, INFO, "Making host key file $file...");
    $cmd = "/usr/bin/ssh-keygen -t rsa -b 1024 -f $file -N \"\"";
    if (oscar_system ($cmd)) {
        oscar_log(1, ERROR, "Unable to create host rsa key");
        exit 1;
    }
}

# second step generation of the DSA key
$file= "$SSHCFGDIR/ssh_host_dsa_key";
OSCAR::Logger::oscar_log(5, INFO, "Checking for host key file $file...");
if ( ! -f $file ) {
    $cmd = "/usr/bin/ssh-keygen -t dsa -d -f $file -N \"\"";
    if (oscar_system ($cmd)) {
        oscar_log(1, ERROR, "Unable to create host dsa key");
        exit 1;
    }
}

# make sure that the server sshd configuration file has
# some important authentication methods turned on
$file = "$SSHCFGDIR/ssh_config";
OSCAR::Logger::oscar_log(1, INFO, "Checking configuration file $file...");

# TODO: we should have a nice Perl module like OSCAR::ConfigFile in order
# to deal with this kind of config file. Right now, if tabs are included,
# everything will fall apart.
my $pos = OSCAR::FileUtils::line_in_file ("ForwardX11 no", $file);
if ($pos != -1) {
    if (OSCAR::FileUtils::replace_line_in_file ($file, $pos, "ForwardX11 yes")) {
        oscar_log(1, ERROR, "Impossible to add \"ForwardX11 yes\" to $file");
        exit 1;
    }
} else {
    if (OSCAR::FileUtils::add_line_to_file_without_duplication ("ForwardX11 yes\n",
                                                                $file)) {
        oscar_log(1, ERROR, "ERROR: Impossible to add \"ForwardX11 yes\" to $file");
        exit 1;
    }
}

my @wantedno = ("StrictHostKeyChecking", "UsePrivilegedPort");
foreach my $key (@wantedno) {
    $pos = OSCAR::FileUtils::line_in_file ("$key yes", $file);
    if ($pos != -1) {
        if (OSCAR::FileUtils::replace_line_in_file ($file, $pos, "$key no")) {
            oscar_log(1, ERROR, "Impossible to add \"$key no\" to $file ($pos)");
            exit 1;
        }
    } else {
        if (OSCAR::FileUtils::add_line_to_file_without_duplication ("$key no\n",
                                                                    $file)) {
            oscar_log(1, ERROR, "Impossible to add line \"$key on\" to $file");
            exit 1;
        }
    }
}

$file= "$SSHCFGDIR/sshd_config";
OSCAR::Logger::oscar_log(5, INFO, "Checking configuration file $file...");

my $SSHVER=`/usr/bin/ssh -V 2>&1 | cut -f2 -d'p' | cut -f2 -d'_'`;
if (!OSCAR::Utils::is_a_valid_string ($SSHVER)) {
    oscar_log(1, ERROR, "ERROR: Impossible to get the SSH version");
    exit 1;
}

my ($SSHMINORVER, $SSHMAJORVER);
if ($SSHVER =~ /(\d+)\.(\d+)/) {
    $SSHMAJORVER = $1;
    $SSHMINORVER = $2;
} else {
    $SSHMAJORVER = $SSHVER;
    $SSHMINORVER = 0;
}
    
my $SSHBADMAJORVER = 3;
my $SSHBADMINORVER = 7;

my @wantedyes = ("IgnoreRhosts", "X11Forwarding", "RhostsRSAAuthentication",
                 "RSAAuthentication", "PermitRootLogin");
foreach my $key (@wantedyes) {
    $pos = OSCAR::FileUtils::line_in_file ("$key no", $file);
    if ($pos != -1) {
        OSCAR::FileUtils::replace_line_in_file ($file, $pos, "$key yes");
    } else {
        OSCAR::FileUtils::add_line_to_file_without_duplication (
            "$key yes\n", $file);
    }
}

# Mandriva install openssh with "PermitRootLogin no" while the others installs
# it with that line commented ("#PermitRootLogin no"), which is the same thing
# as "yes". As we cannot use generic-setup here (once this is a bash script)
# the following section will set "PermitRootLogin yes" to all distros, which
# should be transparent for RHEL and Fedora.
@wantedno = ("RhostsAuthentication");
foreach my $key (@wantedno) {
    $pos = OSCAR::FileUtils::line_in_file ("$key yes", $file);
    if ($pos != -1) {
        OSCAR::FileUtils::replace_line_in_file ($file, $pos, "$key no");
    } else {
        OSCAR::FileUtils::add_line_to_file_without_duplication (
            "$key no\n", $file);
    }
}

# set up root

my $user= "root";
oscar_log(1, INFO, "Setting up user $user on this machine...");
my $home=`egrep \"^$user\:\" /etc/passwd | awk -F: '{print \$6}' | tail -1`;
if (!OSCAR::Utils::is_a_valid_string ($home)) {
    oscar_log(1, ERROR, "Impossible to detect the home directory for $user");
    exit 1;
}
chomp ($home);
if (! -d $home) {
    oscar_log(1, ERROR, "Cannot determine home directory of user $user");
    exit 1;
} else {
    oscar_log(5, INFO, "The home directory for user $user ".
        "is $home");
    my %ssh_keys = (
        "rsa"   => ["$home/.ssh/id_rsa", "$home/.ssh/authorized_keys2"],
        "dsa"   => ["$home/.ssh/id_dsa", "$home/.ssh/authorized_keys2"],
        "rsa1"  => ["$home/.ssh/identity", "$home/.ssh/authorized_keys"],
        );
    my $orig_file;
    my $dest_file;
    foreach my $k (keys (%ssh_keys)) {
        if (! -f $ssh_keys{$k}[0]) {
            oscar_log(1, INFO, "Generating $k key for user $user in $ssh_keys{$k}[0].");
            $cmd = "/usr/bin/ssh-keygen -t $k -N \'\' -f $ssh_keys{$k}[0]";
            if (oscar_system ($cmd)) {
                oscar_log(1, ERROR, "Unable to generate $k key for user $user in $ssh_keys{$k}[0].");
                exit 1;
            }
            $orig_file = "$ssh_keys{$k}[0].pub";
            $dest_file = "$ssh_keys{$k}[1]";
            if (! -f $orig_file) {
                oscar_log(1, ERROR, "File $orig_file does not exist");
                exit 1;
            }
            if (! -f $dest_file) {
                $cmd = "/bin/cat $orig_file > $dest_file";
            } else {
                $cmd = "/bin/cat $orig_file >> $dest_file";
            }
            if (oscar_system ($cmd)) {
                oscar_log(1, ERROR, "Unable to add $orig_file to $dest_file");
                exit 1;
            }
        } else {
            OSCAR::Logger::oscar_log(1, INFO, $ssh_keys{$k}[0]." already exists (kept unmodified)");
        }
    }

    $cmd = "/bin/chmod 600 $home/.ssh/authorized_keys*";
    if (oscar_system ($cmd)) {
        oscar_log(1, ERROR, "Unable to set permission 600 for $home/.ssh/authorized_keys*");
        exit 1;
    }
}


# now we take care of updating each specified image
if (scalar (@BASES) == 0) {
    oscar_log(1, WARNING, "No image(s) specified for the ssh configuration");
} else {
    oscar_log(1, INFO, "Configuring ssh for the following images:");
    foreach (@BASES) {
        oscar_log(1, NONE, "       - $_");
    }
}

foreach my $image (@BASES) {
    OSCAR::Logger::oscar_log(1, INFO, "Checking/updating ssh config for image $image .");
    $cmd = "/bin/cp -fpr $SSHCFGDIR $image$SSHCFGDIR";
    if (oscar_system ($cmd)) {
        oscar_log(1, ERROR, "Unable to copy $SSHCFGDIR to $image$SSHCFGDIR");
        exit 1;
    }

    # every user except root ends up being taken care of by /home cross-mount
    OSCAR::Logger::oscar_log(1, INFO, "Copying ssh config for $user to ".
        "image $image$home .");
    if (! -d "$image$home") {
        File::Path::mkpath ("$image$home") 
            or (oscar_log(1, ERROR, "Unable to create $image$home"), exit 1);
        $cmd = "/bin/chown $user $image$home";
        if (oscar_system ($cmd)) {
            oscar_log(1, ERROR, "Unable to set ownsership to $user for $image$home");
            exit 1;
        }
    }
    $cmd = "/bin/cp -fpr $home/.ssh $image$home";
    if (oscar_system ($cmd)) {
        oscar_log(1, ERROR, "Unable to copy $home/.ssh to $image$home");
        exit 1;
    }

    # updating the ssh configuration in the image
    my $image_ssh_configfile = "$image/etc/ssh/ssh_config";
    $pos = OSCAR::FileUtils::line_in_file ("GSSAPIAuthentication yes",
                                           $image_ssh_configfile);
    if ($pos != -1) {
        oscar_log(5, INFO, "Updating $image/etc/ssh/ssh_config (GSSAPIAuthentication no)");
        if (OSCAR::FileUtils::replace_line_in_file ($image_ssh_configfile,
                                                    $pos,
                                                    "GSSAPIAuthentication no")){
                oscar_log(1, ERROR, "Unable to add \"GSSAPIAuthentication\" to ".
                    $image_ssh_configfile);
                exit 1;
        } else {
            if (OSCAR::FileUtils::add_line_to_file_without_duplication (
                "GSSAPIAuthentication no\n",
                $image_ssh_configfile)) {
                    oscar_log(1, ERROR, "Unable to add \"GSSAPIAuthentication no\" ".
                        "to $image_ssh_configfile");
                    exit 1;
            }
        }
    }
}

oscar_log(1, INFO, "SSH succesffully configured for OSCAR.");
exit 0

__END__

=head1 DESCRIPTION

ssh_install, a command line tool for OSCAR to setup ssh both on the OSCAR
server and into OSCAR images.

=head1 SYNTAX

ssh_install [OPTIONS] image_directories

=head1 OPTIONS

Recognized options include:

=over 8

=item --verbose

Display more information during script execution.

=back

=head1 AUTHORS

=over 8

=item Neil Gorsuch

=item Geoffroy Vallee

=back

=cut
