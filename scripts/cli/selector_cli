#!/usr/bin/perl -w

# $Id$
#
# Copyright (c) 2006 Oak Ridge National Laboratory.
#                  All rights reserved.
#
# This file is a very simple selector that will select
# or unselect packages to be installed in OSCAR.  You can also
# print out the packages or a subset of packages to see which
# are currently selected.

BEGIN {
    if (defined $ENV{OSCAR_HOME}) {
        unshift @INC, "$ENV{OSCAR_HOME}/lib";
        unshift @INC, "$ENV{OSCAR_HOME}/lib/Qt";
    }
}

use strict;
use OSCAR::Logger;
use OSCAR::Database;
use Qt::SelectorUtils;
use Qt::SelectorTable;
use Getopt::Long;
use Term::Complete;

# Command line arguement variables
my $file = '';
my $inun = 0;
my $help = '';

# Parses the command line args
GetOptions('help' => \$help, 'm' => \$inun, 'filename=s' => \$file, 'f=s' => \$file);

# The help text
if ($help)
{
    print "Usage: selector_cli [FLAGS]

    -m                        maintain current package state
    --filename -f filename    File to be read in to automate this step\n";
	exit 0;
}

my %options = ();
my @errors = ();
$| = 1;

my ($printStatus, $printPackage, $printClass, $printVersion);

#Format to print out the package information
format STDOUT=
@|||||||||||@|||||||||||||||||@|||||||||||@||||||||||||||
$printStatus,  $printPackage,  $printClass, $printVersion
.

#If the debug option is set, we should use it
$options{debug} = 1 if $ENV{OSCAR_DB_DEBUG};

OSCAR::Logger::oscar_log_section("Beginning the OSCAR Package Selector");

#Populate the list of packages
OSCAR::Logger::oscar_log_subsection("Populating list of packages");

my @groups_list;
my @package_sets;
my $selected_group;

#Get a list of all the packages
my $allPackages = SelectorUtils::getAllPackages();

my $success = OSCAR::Database::get_groups_for_packages(\@groups_list);

foreach my $groups_ref (@groups_list) {
    push @package_sets, $$groups_ref{group_name};
}

if($success) {
    if ((scalar @package_sets) > 0) {
        $selected_group = OSCAR::Database::get_selected_group(\%options, \@errors);
        if(!$selected_group) {$selected_group = "Default";}
    } else {
        SelectorUtils::createDefaultPackageSet();
    }
}

#List the packages and start getting input
#Print the packages before giving a prompt
printPackages("all");


#If there is a filename as an arguement, don't get user input 
if($file ne '') { 
    #If the user doesn't want to maintain the package state, 
    #reset all core and included packages to selected and others to unselected 
    if($inun == 1) { 
        foreach my $pack (keys %{$allPackages}) { 
            if($$allPackages{$pack}{__class} eq "core" || $$allPackages{$pack}{__class} eq "included") { 
                processInput("select -q $pack"); 
            } else { 
                processInput("unselect -q $pack"); 
            } 
        } 
    } 
    processInput("file " . $file); 
    processInput("quit"); 
} 

#Start the prompt section
#This will exit by the user typing 'quit'
my $ppid = getppid();
my $log_path = "/var/log/oscar";
open(LOG, ">$log_path/selector.$ppid.clilog") 
    || die "Can't open the log to write to.\n";
print LOG "################################################################################\n" .
          "#select <packageName> - Select a package to be installed\n" .
          "#    -q - Quiet mode:  Don't print out verbose dialog\n" .
          "#unselect <packageName> - Unselect a package to prevent it from being installed\n" .
          "#    -q - Quiet mode:  Don't print out verbose dialog\n" .
          "#list <class> - Lists the packages and their installation status\n" .
          "#        class, and version number\n" .
          "#file <filename> - Reads in commands from a file\n" .
          "#help - Prints this message\n" .
          "#quit/exit - Quits the selector and continue with the next step\n" .
          "#\\q - Force quit (as in ctrl-c)\n" .
          "################################################################################\n";
my $continue = 1;
my @completion_list = qw ( select unselect list file help quit exit );
my $prompt = "\nselector> ";

while($continue)
{
    my $response = Complete($prompt, @completion_list);
    print LOG "$response\n";
    $continue = processInput($response);
}
close LOG;

exit 0;

# Print the packages that match the specified class (core, included, third party, all)
# with their <status> <short package name> <class> <version>
sub printPackages
{
    my $class = shift; #The class name should be the only arguement
    
    #Get all the selected packages
    my $selected_packages = SelectorTable::getPackagesInPackageSet($selected_group);

    #Get installed packages
    my $installed_packages = SelectorTable::getPackagesInstalled();

    #Get a list of all the packages
    my $allPackages = SelectorUtils::getAllPackages();

    #Set the package status
    foreach my $package_ref (keys %{$allPackages}) {
        $$allPackages{$package_ref}{status} = "Unselected";
        $$allPackages{$package_ref}{status} = "Selected" if $$selected_packages{$package_ref};
        $$allPackages{$package_ref}{status} = "Installed" if $$installed_packages{$package_ref};
    }

    OSCAR::Logger::oscar_log_subsection("List of packages");
    if(defined $class && $class eq "core")
    {
        print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
        foreach my $package (keys %{$allPackages})
        {
            if($$allPackages{$package}{__class} eq "core")
            {
                #Need to set up these variables to be printed out
                $printStatus = $$allPackages{$package}{status};
                $printPackage = $package;
                $printClass = $$allPackages{$package}{__class};
                $printVersion = $$allPackages{$package}{version};
                
                #Print out the information
                write;
            }
        }
        return;
    }
    elsif(defined $class && $class eq "included")
    {
        print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
        foreach my $package (keys %{$allPackages})
        {
            if($$allPackages{$package}{__class} eq "included")
            {
                #Need to set up these variables to be printed out
                $printStatus = $$allPackages{$package}{status};
                $printPackage = $package;
                $printClass = $$allPackages{$package}{__class};
                $printVersion = $$allPackages{$package}{version};
                
                #Print out the information
                write;
            }
        }
        return;
    }
    elsif(defined $class && $class eq "third-party")
    {
        print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
        foreach my $package (keys %{$allPackages})
        {
            #Need to set up these variables to be printed out
            if($$allPackages{$package}{__class} eq "third-party")
            {
                $printStatus = $$allPackages{$package}{status};
                $printPackage = $package;
                $printClass = $$allPackages{$package}{__class};
                $printVersion = $$allPackages{$package}{version};
                
                #Print out the information
                write;
            }
        }
        return;
    }
    else
    {
        print "   Status           Name          Class        Version\n---------------------------------------------------------\n";
        foreach my $package (keys %{$allPackages})
        {
            #Need to set up these variables to be printed out
            $printStatus = $$allPackages{$package}{status};
            $printPackage = $package;
            $printClass = $$allPackages{$package}{__class};
            $printVersion = $$allPackages{$package}{version};
            
            #Print out the information
            write;
        }
        return;
    }
}

#Process the user's response from the prompt
sub processInput 
{
    #Change the response from a scalar to an array
    my @response = split(' ', shift);

    my $command = shift(@response);
    my $requested;
    
    #By default, ask for help
    if(!defined $command)
    {
        $command = "help";
    }
    
    #If the user is trying to select a package
    if($command eq "select")
    {
        my $packagename = shift(@response);

        if(!$packagename) {
            print "Format: select [-q] package_name\n";
            return 1;
        }

        #If the user adds a -q flag, don't print out the verbose dialog
        my $quiet = 0;
        if($packagename eq "-q")
        {
            $quiet = 1;
            #Move the next arguement over to make parsing the command line easy
            $packagename = shift(@response);
            
            if(!$packagename) {
                print "Format: select [-q] package_name\n";
                return 1;
            }
        }

        #Make sure the package exists and is not already installed
        # If the package is "Selected", the "requested" value for the
        # table "Node_Package_Status" is set to 2, otherwise 1.
        # (i.e.,
        #  if package selected, requested = 2: should_be_installed
        #  if package unselected, requested = 1: should_not_be_installed )
        $requested = 1;
        if(defined $$allPackages{$packagename} && $$allPackages{$packagename}{status} ne "Installed")
        {
            $$allPackages{$packagename}{status} = "Selected";
            $requested = 2;
            $success = OSCAR::Database::set_group_packages
                ($selected_group,$packagename,$requested,\%options,\@errors);
            
            #Check for dependencies
            print "Checking dependencies\n" unless $quiet;
            my $dependencies;
            $dependencies = SelectorUtils::getRequiresList($dependencies,$packagename);
            delete $$dependencies{""}; #Delete the empty key
            #If there is a dependency, select it
            foreach my $name (keys %{$dependencies})
            {
                if ($name eq $packagename) {next;}
                print "Package dependant on " . $name . "\n" unless $quiet;
                $$allPackages{$name}{status} = "Selected";
                # requested = 2
                $success = OSCAR::Database::set_group_packages
                    ($selected_group,$name,$requested,\%options,\@errors);
            }
            
            #Check for conflicts
            print "Checking conflicts\n" unless $quiet;
            my $conflict;
            $conflict = SelectorUtils::getConflictsList($dependencies);
            #If there is a conflict, unselect the conflicting package
            delete $$conflict{""}; #Delete the empty key
            foreach my $name (keys %{$conflict})
            {
                if ($name eq $packagename) {next;}
                print "Conflicting package " . $name . "\n" unless $quiet;
                $$allPackages{$name}{status} = "Unselected";
                $requested = 1;
                $success = OSCAR::Database::set_group_packages
                    ($selected_group,$name,$requested,\%options,\@errors);
            }
        }
        elsif(!defined $$allPackages{$packagename})
        {
            print "Package name " . $packagename . " not recognized\n" unless $quiet;
        }
        elsif($$allPackages{$packagename}{status} eq "Installed")
        {
            print "Package " . $packagename . " already installed\n" unless $quiet;
        }
    }
    #If the user is trying unselect a package
    elsif($command eq "unselect")
    {
        my $packagename = shift(@response);

        if(!$packagename) {
            print "Format: select [-q] package_name\n";
            return 1;
        }

        #If the user adds a -q flag, don't print out the verbose dialog
        my $quiet = 0;
        if($packagename eq "-q")
        {
            $quiet = 1;
            #Move the next arguement over to make parsing the command line easy
            $packagename = shift(@response);

            if(!$packagename) {
                print "Format: select [-q] package_name\n";
                return 1;
            }
        }

        #Make sure the package exists
        if(defined $$allPackages{$packagename} && $$allPackages{$packagename}{__class} ne "core")
        {
            $requested = 1;
            $$allPackages{$packagename}{status} = "Unselected";
            $success = OSCAR::Database::set_group_packages
                ($selected_group,$packagename,$requested,\%options,\@errors);
            
            #Check to see if anything depends on this
            print "Checking dependencies\n" unless $quiet;
            my $reqby;
            $reqby = SelectorUtils::getIsRequiredByList($reqby,$packagename);
            delete $$reqby{""}; #Delete the empty key
            #If something depended on this package, unselect it
            foreach my $package (keys %{$reqby})
            {
                if ($package eq $packagename) {next;}
                print "Package " . $package . " depends on " . $packagename . "\n" unless $quiet;
                $$allPackages{$package}{status} = "Unselected";
                $success = OSCAR::Database::set_group_packages
                    ($selected_group,$package,$requested,\%options,\@errors);
            }
        }
        elsif(!defined $$allPackages{$packagename})
        {
            print "Package name " . $packagename . " not recognized\n" unless $quiet;
        }
        elsif($$allPackages{$packagename}{__class} eq "core")
        {
            print "Cannot unselect core packages\n" unless $quiet;
        }
    }
    #If the user is trying to list the packages again
    elsif($command eq "list")
    {
        my $class = shift(@response);
        
        #The default action if the selected class does not exist is to print all of the packages
        if(!defined $class)
        {
            printPackages("all");
        }
        else
        {
            printPackages($class);
        }
    }
    #If the user is trying to quit the program
    elsif($command eq "quit" || $command eq "exit")
    {
        #Everything should already have been taken care of so go ahead and move on
        return 0;
    }
    #If the user wants to read in responses from a file
    elsif($command eq "file")
    {
        my $filename = shift(@response);

        if(!$filename) {
            print "Format: file file_name\n";
            return 1;
        }

        if (! -f $filename) {
            print "File $filename not found!\n";
            return 1;
        }

        open(FILE, $filename);
        #Read the file just like it is normal input from the keyboard
        #The file is not required to have a quit command in it
        while(<FILE>)
        {
            chomp $_;
            
            #Comment
            if(/^#/) {next;}

            #Empty line
            elsif(!$_) {next;}
            
            processInput($_);
        }
        exit 0;
    }
    elsif ( $command eq "\\q" ) {
        print "Force quit\n";
        exit 1;
    }
    #Default response is to print out the list of commands and their use
    else
    {
        print <<EOF
select <packageName> - Select a package to be installed
\t-q - Quiet mode:  Don't print out verbose dialog
unselect <packageName> - Unselect a package to prevent it from being installed
\t-q - Quiet mode:  Don't print out verbose dialog
list <class> - Lists the packages and their installation status, class, and version number
file <filename> - Reads in commands from a file
help - Prints this message
quit/exit - Quits the selector and continues with the next step
\\q - Force quit (as in ctrl-c)
EOF
    }

    return 1;
}
