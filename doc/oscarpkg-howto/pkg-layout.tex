% $Id: pkg-layout.tex,v 1.12 2003/10/01 00:36:16 tfleury Exp $

% TJN: Mention the XML tools that are helpful, e.g., 'xmllint'
%      which >= 2.5.8 (i believe) has --schema option too! :)
%      Also, probably want to include the DTD (& Schema) for
%      general perusal/clarity.

\section{Package Layout}
\label{sect:pkg-layout}

As OSCAR evolved it became obvious that the mechanism to configure and
install a cluster needed to be cleanly separated from the software that was
to be installed.  The approach taken was to create \emph{OSCAR Packages}.
The OSCAR Package layout is geared toward making things as simple as
possible for package authors.  So, in its simplest form an OSCAR Package is
an RPM\footnote{A binary RPM compiled for an OSCAR supported Linux
distribution.}.  However, most software requires further configuration for
a cluster environment so additional scripts, documentation, etc. may be
added.  The basic directory structure for an OSCAR Package is as follows.

\begin{quote}
\begin{description}
  \item[\file{config.xml}] -- meta file with description, version, etc.
  \item[\directory{RPMS/}] -- directory containing binary RPM(s) for the package
  \item[\directory{SRPMS/}] -- directory containing source RPM(s) used to build
                            the package
  \item[\directory{scripts/}] --  set of scripts that run at particular times
                     during the installation/configuration of the cluster
  \item[\directory{testing/}] -- unit test scripts for the package
  \item[\directory{doc/}] -- documentation and/or license information
\end{description}
\end{quote}

\noindent For reference purposes, Table~\ref{tab:oscar-envvars}
contains a list of the currently recognized environment variables used by
the OSCAR framework.

% Table with all currently supported/recognized Environment Variables
\input{oscar-envvars-table.tex}

The packaging API provides authors the ability to make use of configuration
scripts to setup cluster software outside of the RPM itself.  The scripts
fire at different stages of the installation process as detailed in
Section~\ref{sect:pkg-scripts}.  The packages may also include simple test
scripts in the \directory{testing/} directory, which are used to verify the
software was properly installed (see Section~\ref{sect:pkg-testing}).
Lastly, an OSCAR Package Downloader (OPD) tool is provided to simplify
acquisition of new packages (see Section~\ref{sect:opd}).




\subsection{\file{config.xml}}
\label{sect:pkg-config-xml}

This XML file provides the package name (\xmltag{name}), version number
(\xmltag{version}) and description information (\xmltag{description}) as
well as the list of RPMS (\xmltag{rpmlist}) and their installation location
(e.g., ``oscar\_server'', ``oscar\_clients'').   The file enables an author
to convey constraints such as supported distribution (\xmltag{filter}) or
simple dependencies (\xmltag{requires}) upon other OSCAR Packages, e.g.,
Env-Switcher.  If this meta file is not included a simplistic default is
used---install all files in \directory{RPMS/} on all machines in cluster.
The available XML elements for use in this file are listed in
Appendix~\ref{sect:supported-xml-tags}, page~\pageref{sect:supported-xml-tags}
with a complete example given in Section~\ref{sect:example-pkg}.

The \xmltag{rpmlist} contains the list of RPM names (without version
numbers) to be installed for the package.  There may be multiple instances
of these \xmltag{rpmlist}'s using the \xmltag{filter} to differentiate
where necessary.  The \xmltag{filter} constraints enable an author to
express what \xmlattr{distribution}, \xmlattr{distribution\_version} and
\xmlattr{architecture} the associated \xmltag{rpm}'s support.  The
\xmlattr{group} value specifies where the to install the \xmltag{rpm}'s.
Things are implicitly global if no constraints are provided, i.e., entire
cluster for all distributions.  

% Table with all currently supported XML tags & brief description
%\input{pkg-xml-table.tex}


\subsection{RPMS \& SRPMS}
\label{sect:pkg-rpms-srpms}

The pre-compiled binary version of the software is provided in RPM format.
The RPMS are placed, obviously enough, in the \directory{RPMS} directory.
The OSCAR Wizard copies all files from this \directory{RPMS} directory to
the \directory{/tftpboot/rpm} directory.

% % TJN: (9/26/03) I prefer this text but it is not correct! ;)
% %  Ultimately this should be closer to what actually happens.
% 
% The OSCAR Wizard copies all files listed in the \xmltag{rpmlist} from this
% \directory{RPMS} directory to the \directory{/tftpboot/rpm} directory or
% alternately the directory specified by the environment variable
% \envvar{OSCAR\_RPMPOOL}.   The \xmltag{rpmlist} that is processed, based
% upon The exact \xmltag{rpmlist} that is processed is determined based upon
% the the \xmltag{filter} that is entirely true and most particular.  The
% list of supported distributions for each OSCAR release is typically stored
% in Table 1 of the installation document.

If present, whichever \xmltag{rpmlist} that fits the available distribution
(based on \xmltag{filter} constraints) is recorded in the OSCAR database
for that particular package\footnote{The contents of \xmltag{rpmlist} have
no bearing on what is copied to \directory{/tftpboot/rpm}.  All files in
\directory{RPMS} are blindly copied.}.
The list of supported distributions for each OSCAR
release is typically stored in Table 1 of the installation document.



\begin{verse}
   {\bfseries Notice: } As of OSCAR-2.3 the \xmltag{filter} tag does not
   yet support the \xmlattr{subdir} attribute, which is used to specify a
   directory for the \xmltag{rpm}'s in the \xmltag{rpmlist}.  Due to this
   limitation, some packages use a \file{setup} script to copy the
   appropriate files to this \directory{RPMS} area based on the values
   (distro\_name, distro\_ver) returned from Perl method
   \verb=OSCAR::Distro::which_distro_server()=.  To access this method from
   your \file{scripts/setup} file add the includes: 
   \begin{footnotesize}
   \begin{verbatim}
           use lib "$ENV{OSCAR_HOME}/lib";
           use OSCAR::Distro;
           my ($distro_name, $distro_ver) = which_distro_server();
   \end{verbatim}
   \end{footnotesize}
\end{verse}




\subsection{scripts}
\label{sect:pkg-scripts}

The OSCAR framework recognizes the set of scripts outlined in
Table~\ref{tab:pkg-scripts}.  A package author may use any/all of these as
needed for application configuration.  The order of operation during the
OSCAR installation process is summarized in
Table~\ref{tab:sequence-of-events}.  The ``Location'' column indicates
where the actual modification/operations take place\footnote{Note, the
\file{post\_install} scripts in practice often operate on both the server
and client filesystems -- regardless of what the original specifications
suggested.}.  Each phase of scripts is executed per package, with packages 
processed in alph-order. 
%\footnote{The Perl function \file{readdir()} is used to build the list.}.
% TJN: Confirm this before uncommenting...have to look at current code.


% Table outlining the available OSCAR API scripts
\input{pkg-scripts-table.tex}


\begin{table}[h!]
  \begin{center}
      \begin{tabular}{rll}
        \hline
        \multicolumn{2}{c}{Description} &
        \multicolumn{1}{c}{Location} \\
        \hline
%		
		1. & Install framework pre-requisites  & Server filesystem \\
%
      1.1. & Call the API scripts: \cmd{setup} & Server filesystem \\
%
      1.2. & Read XML config files & Server filesystem \\
%
      1.3. & Install server core RPMs & Server filesystem \\
%
      1.4. & (\emph{Optional}) Download additional packages & Server
              filesystem \\
%
    1.4.1. & \hspace{2pt} Call the API scripts: \cmd{setup} & Server 
              filesystem \\
%
    1.4.2. & \hspace{2pt} Read XML config files & Server filesystem \\
%
      1.5. & Select which packages to install & Server filesystem \\
%
      1.6. & Call the API scripts: \cmd{pre\_configure} & Server
              filesystem \\
%
      1.7. & Configure the selected packages & Server filesystem \\
%
      1.8. & Call the API scripts: \cmd{post\_configure} & Server
             filesystem \\
%
      1.9. & Install the server non-core RPMs & Server filesystem \\
%
        2. & Call the API scripts: \cmd{post\_server\_rpm\_install} &
        Server filesystem \\
%
        3. & Install all the client RPMs & 
		Client/\cmd{chroot}'d environment \\
%
        4. & Call the API scripts: \cmd{post\_client\_rpm\_install} &
        Client/\cmd{chroot}'d environment \\
%
        5. & Define clients in the OSCAR/SIS database & Server
        filesystem \\
%
        6. & Call the API scripts: \cmd{post\_clients} & Server
        filesystem \\
%
        7. & Push the images to the nodes & Server filesystem \\
%
        8. & Call the API scripts: \cmd{post\_install} & 
		   Server filesystem (access to clients)\\
        \hline
      \end{tabular}
      \caption{Note the \cmd{chroot}'d environment indicates 
	  the operations happen in the SIS image not on the actual machine.
	  In step 8, the script runs on the Server but can affect the clients,
	  e.g., via C3 commands.}
    \label{tab:sequence-of-events}
  \end{center}
\end{table}

\subsubsection{Package Setup}

The \file{setup} script executes before any packages are installed.  This
phase can be used to move files around in the package's directory or to do
dynamic setup before the package \file{config.xml} scripts are processed.
Once these XML files have been processed the available packages are then
passed to the GUI where they are processed by the Selector panel.  If any
of the selected packages contain \file{pre\_configure} scripts those are
processed and then handed to the Configurator.  After the Configurator has
run any existing \file{post\_configure} scripts are processed.  At this
point no package software has been installed and all that is know by the
database is what packages were selected and their \file{config.xml}
information (version, etc.).

\begin{verse}
   {\bfseries Notice: } If a user skips the ``Configure Packages'' step in
   the Wizard, the \file{pre\_configure} and \file{post\_configure} scripts
   will not be processed, i.e., the Configurator will not be run. 
\end{verse}




\subsubsection{Configurator}
\label{sect:pkg-configurator}

Packages may obtain user input via a simple facility called the
``Configurator''.  The package author writes a simple HTML Form style
document that is presented to the user if the package is selected for
installation.  The standard multi-pick lists, radio button, checkbox fields
are available.  Typically default values are provided to simplify matters
where possible for users.  

To make use of this facility create a file in the top-level of the
package's directory called \file{configurator.html}.  After the package
selection phase of the OSCAR Wizard all packages containing this file are
processed by the Configurator.  The results of this processing are written
out in XML format to the top-level directory of the package in a file
called \file{.configurator.values}.  At this point the
\file{post\_configure} API scripts are fired so packages may read the
results of the configuration phase.    The Perl \file{XML::Simple} module
is typically used for processing these results in conjunction with the
\envvar{OSCAR\_PACKAGE\_HOME} environment variable.  Alternatively, you can
use the Perl subroutine \texttt{readInConfigValues} available in the
\file{OSCAR::Configbox} module.  See Section~\ref{sect:example-configurator}
for examples of the input and simple processing scripts.

\subsubsection*{Writing the \file{configurator.html} File}

To present configuration options to the user, the Configurator uses
a simple HTML \textbf{Form}. While the basics of writing HTML files
and HTML forms are discussed in detail in many books and online tutorials,
this section seeks to describe the HTML form tags available to a package
maintainer and how to use those tags to get information from the user.

Many of the basic HTML tags are supported in the OSCAR Configurator,
including:

\begin{itemize}
\item various fonts and headers 
\item line and paragraph breaks 
\item horizontal (ruler) lines 
\item centered text 
\item images (GIFs and JPEGs) 
\end{itemize}
There is also a decent assortment of HTML Form tags such as:

\begin{itemize}
\item input fields
\item checkboxes
\item radio buttons
\item single- and multi-selection lists
\item text boxes 
\end{itemize}
All of the available tags are described in detail below.

There are some HTML tags that are NOT allowed in a configuration file.
In particular, you may \textbf{not} use:

\begin{itemize}
\item $<$A HREF$>$ - A hypertext link to other places on the web. We don't want
the user going off to another web page.
\item $<$TABLE$>$, $<$TR$>$, $<$TD$>$ - While tables are parsed in without difficulty,
they are not rendered as true talbes. Better to use $<$PRE$>$ (preformatted
text) for this purpose.
\item $<$ISINDEX$>$ - The document cannot be searchable.
\item Form $<$SUBMIT$>$, $<$BUTTON$>$, and $<$IMAGE$>$ - The Configurator has its own
button to submit the values of the form to the program, so these elements
are unnecessary.
\item $<$FILE$>$ - The user is not allowed to upload a file. 
\end{itemize}
If any of these tags are present in your HTML document, they are removed
prior to rendering so that your document will appear without the offending
tags.


\subsubsection*{A Basic HTML Form Document}

Since all of the configuration input from a user appears in an HTML
Form, the minimum useful configuration file contains $<$form$>$ and
$<$/form$>$
tags. Between these two tags, the package maintainer adds $<$input$>$
tags to get input from the user. For example, if all you want from
the user is his name, your configuration file might be as follows:

\begin{footnotesize}
\begin{verbatim}
     <form>
     Enter your name: <input name="username">
     </form>
\end{verbatim}
\end{footnotesize}

The resulting output would look like this:

~

\includegraphics[%
  scale=0.5]{EnterYourName.png}

~

If you are HTML savvy, you may notice a few things missing from this
example. Specifically, we omitted the main $<$html$>$...$<$/html$>$ tags,
and the $<$head$>$$<$/head$>$ and $<$body$>$$<$/body$>$ tags. For basic configuration
files, these tags are optional. You may use them if you like (and
some browsers would bonk if they were absent), but they are not required.
Also, there are no attributes for the $<$form$>$ tag. This is because
the Configurator knows the action to take when the user saves the
values, so no {}``action'' label is needed. Also, there can be only
one pair of $<$form$>$$<$/form$>$ tags in the configuration file, so there
is no need for the {}``name'' label.


\subsubsection*{A More Complete HTML Form}

A typical HTML document consists of at least two separate sections,
a {}``head'' and a {}``body''. The most important element of the
{}``head'' is the $<$title$>$...$<$/title$>$ tag. This sets the title of
the window and also acts as the text for the header of the configuration
window. If you omit this tag or leave the value blank, it defaults
to {}``Configuration''.

The body is where the main part of the HTML document is stored. It
includes both the Form and any other {}``standard'' HTML elements
you want to display. Many of these elements can appear inside or outside
of the Form, so it is sometimes easiest to have a configuration form
that looks like this:

\begin{footnotesize}
\begin{verbatim}
     <html>
       <head>
         <title>The Title Of Your Configuration Form<title>
       </head>

       <body> 
         <form> 
           All of your main HTML configuration goes here.
         </form> 
       </body> 
     </html>
\end{verbatim}
\end{footnotesize}

In HTML files, whitespace (including carriage returns) are usually
compacted to a single space. So in the above example, the indentation
and line spacing are shown simply to make the example easier to read.
We could just have easily put everything on a single line and the
output would be the same. This is important to know since if you want
a true line break (say between paragraphs), you have to explicitly
tell HTML by using the $<$p$>$ (paragraph) tag. Also, the case of the
tags is unimportant, so you could also use all uppercase letters for
your tags if you find that to be more readable.


\subsubsection*{Basic (non-form) HTML Tags}

There are many HTML tags which can be displayed by the Configurator
that don't need to be in the form, but will be useful anyway. The
function of each of these tags are not listed here. There are plenty
of HTML reference books and online tutorials available. Use your favorite
search engine and do a search on {}``HTML tutorial'' to get a big
listing.


\subsubsection*{HTML Form Tags}

The main tags that you will need for your configuration file are $<$form$>$
tags. These tags allow you to prompt the user for information to be
entered via text boxes, check boxes, radio buttons, selection lists,
etc. This section describes each tag in detail and provides examples.

Note that all of these tags must appear between a $<$form$>$...$<$/form$>$
tag pair. Otherwise your values will not get submitted correctly.

\begin{itemize}
\item $<$input type=\char`\"{}text\char`\"{} name=\char`\"{}VARIABLE\char`\"{}
value=\char`\"{}INITIAL\char`\"{} size=\char`\"{}NUMCHARS\char`\"{}
maxlength=\char`\"{}MAXCHARS\char`\"{}$>$ - 


A \textit{text} element is a single line text input field in which
the user can enter text. If you do not specify \textbf{type=''text''},
then the $<$input$>$ defaults to this type of text input field. Of the
various attributes, only \textbf{name} is required. The \textbf{name}
attribute designates the variable name for the data entered by the
user. If you also specify the \textbf{value} attribute, that text
appears in the text input field when it first appears. The \textbf{size}
and \textbf{maxlength} attributes designate the number of characters
that appear in the text box and the maximum length of the input text
respectively.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     Enter your name: 
     <input type="text" name="username" value="johndoe" size="20" maxlength="30"> 
     </form>
\end{verbatim}
\end{footnotesize}

Output:

\begin{quote}
\includegraphics[%
  scale=0.5]{EnterYourName2.png}
\end{quote}
\item $<$input type=\char`\"{}password\char`\"{} name=\char`\"{}VARIABLE\char`\"{}
value=\char`\"{}INITIAL\char`\"{} size=\char`\"{}NUMCHARS\char`\"{}
maxlength=\char`\"{}MAXCHARS\char`\"{}$>$ -


A \textit{password} element is a text input field in which each character
typed is displayed as a {*} to conceal the actual value entered. In
all other aspects, this element is the same as the \textit{text} element.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     Enter your password: 
     <input type="password" name="password" value="passwd" size="10" maxlength="20"> 
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{EnterYourPassword.png}
\end{quote}
\item $<$input type=\char`\"{}checkbox\char`\"{} name=\char`\"{}VARIABLE\char`\"{}
value=\char`\"{}RETURNVALUE\char`\"{} checked$>$ - 


A \textit{checkbox} is a toggle that the user can select (switch on)
or deselect (switch off). As with all $<$input$>$ elements, the \textbf{name}
attribute is required and designates the variable name for the value
returned by the check box. Usually, {}``ON'' is returned when a
check box has been checked by the user. If you specify the \textbf{value}
attribute, that value is returned instead when the check box has been
checked by the user. You can optionally specify the \textbf{checked}
attribute to make the check box initially selected when first displayed.
Otherwise, the check box is unselected when first displayed. Any check
boxes which are not checked when the form is submitted do not get
passed to the Configurator, ie. their values will be {}``'' (the
empty string).

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     <input type="checkbox" name="rootaccess" value="YES" checked> 
     Enable "root" access 
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{EnableRootAccess.png}
\end{quote}
\item $<$input type=\char`\"{}radio\char`\"{} name=\char`\"{}VARIABLE\char`\"{}
value=\char`\"{}RETURNVALUE\char`\"{} checked$>$ - 


A \textit{radio} element is a radio button. A set of radio buttons
consists of multiple radio buttons that all have the same \textbf{name}
attribute. Only one radio button in the set can be selected at one
time. When the user selects a button in the set, all other buttons
in the set are deselected. If one radio button in a set has the \textbf{checked}
attribute, that one is selected when the set is first displayed. Otherwise,
none of the radio buttons are selected when first displayed (which
may not be the desired functionality). As with all $<$input$>$ elements,
the \textbf{name} attribute is required and designates the variable
name for the value returned by the radio button set. All radio buttons
with the same \textbf{name} are in the same set, regardless of where
they appear in the form. The \textbf{value} attribute is the value
that is returned for the radio button set when the form is submitted.
This default to {}``ON'' which isn't very useful for a set of radio
buttons, so be sure to give each radio button its own \textbf{value}.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     User type:<br> 
     <input type="radio" name="usertype" value="guest"> Guest<br> 
     <input type="radio" name="usertype" value="user" checked> User<br> 
     <input type="radio" name="usertype" value="admin"> Admin<br> 
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{UserType.png}
\end{quote}
\item $<$input type=\char`\"{}hidden\char`\"{} name=\char`\"{}VARIABLE\char`\"{}
value=\char`\"{}RETURNVALUE\char`\"{}$>$ - 


A \textit{hidden} element is an invisible element whose main purpose
is to contain data that the user does not enter. This data gets sent
when the form is submitted. This allows you to always pass a certain
name/value pair to the Configurator without input from the user. Both
the \textbf{name} and \textbf{value} attributes are required.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     There's a hidden element here!
     <input type="hidden" name="version" value="5.23"> 
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{HiddenElement.png}
\end{quote}
\item $<$input type=\char`\"{}reset\char`\"{}
value=\char`\"{}LABEL\char`\"{}$>$
- 


When the user presses a \textit{reset} button, all elements in the
form are reset to the values that were present when the form was first
displayed. Usually, the text of this button is {}``Reset'', but
you can change this by specifying the \textbf{value} attribute.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     Reset form: <input type="reset" value="Reset to Original Values">
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{ResetForm.png}
\end{quote}
\item $<$textarea name=\char`\"{}VARIABLE\char`\"{} cols=\char`\"{}WIDTH\char`\"{}
rows=\char`\"{}HEIGHT\char`\"{} 


wrap=\char`\"{}OFF\char`\"{}|\char`\"{}HARD\char`\"{}|\char`\"{}SOFT\char`\"{}$>$Text
to display$<$/textarea$>$ - 

The \textit{textarea} tag defines a multiline input field into which
the user can enter text. As with $<$input$>$ elements, the \textbf{name}
attribute is required and designates the variable name for the text
present in the box when the form is submitted. The width and height
(in terms of characters) of the text box is given by the optional
\textbf{cols} and \textbf{rows} attributes. By default, any text entered
by the user is displayed {}``as is'' meaning that if the line input
by the user is longer than the width of the text box, the text will
scroll off the screen. The only time a new row is started is when
the user types a carriage return. This is also the behavior when you
use the \textbf{wrap=\char`\"{}OFF\char`\"{}} attribute. If you want
to have the text word wrap automatically, use the \textbf{wrap=\char`\"{}HARD\char`\"{}}
or \textbf{wrap=\char`\"{}SOFT\char`\"{}} attribute. (In standard
HTML, these two attributes differ by whether or not the extra carriage
returns generated by word wrapping get submitted in the text or not.
For the Configurator, these extra carriage returns are never submitted,
which is equivalent to \textbf{wrap=\char`\"{}SOFT\char`\"{}}, so
using \textbf{wrap=\char`\"{}HARD\char`\"{}} generates the same behavior.)
Between the two $<$textarea$>$...$<$/textarea$>$ tags, you can put optional
{}``Text to display'' when the textarea is first displayed.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     Comments?<br> 
     <textarea name="comments" cols=40 rows=5 wrap="SOFT"> 
     Enter your comments or suggestions here. 
     </textarea> 
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{Comments.png}
\end{quote}
\item $<$select name=\char`\"{}VARIABLE\char`\"{} size=\char`\"{}LISTLENGTH\char`\"{}
multiple$>$ $<$option value=\char`\"{}OPTIONVALUE\char`\"{}$>$ $<$option value=\char`\"{}OPTIONVALUE\char`\"{}
selected$>$ ... $<$/select$>$ - 


The \textit{select} and \textit{option} tags define a selection list.
A selection list displays a list of options from which the user can
select one (or more) items. If the \textbf{multiple} attribute is
present, the user can select multiple items from the list at a time.
Otherwise, only a single item can be selected at a time. As with \textbf{input}
elements, the \textbf{name} attribute is required and designates the
variable name for the value(s) selected in the list when the form
is submitted. The optional \textbf{size} attribute indicates how many
items are presented in the box before scrolling is necessary. This
defaults to {}``10''. If you set \textbf{size} to {}``1'' and
do not set the \textbf{multiple} attribute, you get a single element
drop-down list.

To actually put items in the selection list, you use the \textit{option}
tag followed by the text you wish to appear in the list. You can make
that option selected when the list is initially displayed by using
the \textbf{selected} attribute. By default, the value that gets returned
to the Configurator when an item is selected is the actual text of
the item in the list. You can override this behavior by using the
optional \textbf{value} attribute. When you set this value, it gets
returned when that item in the list is selected.

Example:

\begin{footnotesize}
\begin{verbatim}
     <form> 
     Select the machines to use:<br> 
     <select name="machinelist" size=5 multiple> 
     <option selected>oscar1 
     <option>oscar2 
     <option>oscar3 
     <option>oscar4 
     <option>oscar5 
     <option>oscar6 
     <option value="unlisted">unlisted machine 
     </select> 
     </form>
\end{verbatim}
\end{footnotesize}

Output: 

\begin{quote}
\includegraphics[%
  scale=0.5]{SelectMachine.png}
\end{quote}
Note: when viewing the above example in a standard HTML browser, you
might have to use the $<$SHIFT$>$ or $<$CTRL$>$ key in conjunction with clicking
the mouse to select multiple items from the list. In the Configurator,
this extra keypress is not required.\end{itemize}



\subsubsection{Fixups without RPM modification}

The \file{post\_server\_rpm\_install} and \file{post\_client\_rpm\_install}
are useful when you would like to leave an RPM untouched and perform
``fixups'' outside the RPM itself.  The actual cluster nodes have not yet
been defined so no information about number of nodes or names is available
at this phase.  As the name suggests these are performed on the server
(after all server packages have been installed) and on the client (once the
client has been ``installed''\footnote{In the case of OSCAR this means that
the SIS image (i.e., SystemImager image) has been built and client software
is installed in this \cmd{chroot}'ed environment on the server node, but is
not yet on the physical compute node hardware.  This precludes the use of
things like client specific environment variables or process managment
tools e.g., \cmd{service}.}).  This pair of scripts is pretty limited in
use but helps some instances where RPMs would otherwise have to be
modified.



\subsubsection{Setup after Clients Defined}

Once the cluster nodes have been defined the \file{post\_clients} scripts
are processed.  The number of nodes, hostname/IPs and associated image are
obtained in this ``definition'' phase.  However, the nodes themselves have
not yet been physically installed.  This \file{post\_clients} phase is when
any package that needs knowledge about cluster nodes can query for the
count, names, etc.  

\begin{verse}
   {\bfseries Notice: } The method for obtaining this information is
   currently in flux but the following will provide a Perl hash containing
   hostname,  domain name and IP for all nodes defined in the cluster, in
   numeric order.
  \begin{footnotesize}
  \begin{verbatim}
       use lib '/usr/lib/systeminstaller';
       use SystemInstaller::Machine;

       my %hash = get_machine_listing($image);   #Image can be null for default

       foreach my $key (sort numerically keys %hash) {   #Key is nodenameN
           print $hash{$key}->{HOST}, ", ";
           print $hash{$key}->{DOMAIN}, ", ";
           print $hash{$key}->{IPADDR}, "\n--------\n";
       }

       # Special sort() sub-rtn (uses $a, $b instead of @_)
       sub numerically 
       {
           $a =~ /(\d+)$/;  $A = $1;  #pickoff node num & save in local var
           $b =~ /(\d+)$/;  $B = $1;  #pickoff node num & save in local var
           ($A <=> $B);
       }
  \end{verbatim}
  \end{footnotesize}
\end{verse}



\subsubsection{Completing cluster configurations}

The final configuration script that fires is \file{post\_install}.  At this
stage the nodes are completely installed and booted.  It is typically
assumed that they are accessible via C3 commands, e.g., \cmd{cexec} --
parallel cluster execution.  Any closing modifications are performed, such as
restarting service or pushing out files, e.g., \cmd{cpush} account files.

\subsubsection{Package Uninstall}

The two ``uninstall'' scripts are run after the actual OSCAR package RPMS
have been removed.  The \file{post\_server\_} and
\file{post\_client\_rpm\_uninstall} scripts are used to clean up any
modifications or files added outside the RPM, i.e., via OSCAR API scripts.


% TJN: finish this section
\subsection{testing}
\label{sect:pkg-testing}

Tests are run for each package.  The two scripts that are available for
this testing are: \file{test\_root} and \file{test\_user}.  These testing
scripts may be written in any language so long as they are executable. When
tests are run for the cluster, all \file{test\_root} scripts are executed
which perform any root level package tests.    

\begin{verse}
   {\bfseries Notice: } There are obvious security issues with this but
   currently all operations in the cluster installation are being performed
   by {\tt root} so care is expected at all phases.  The user tests are run
   as an actual user ({\tt oscartst}) so those tests are slightly ``less''
   dangerous and therefore most packages are using \file{test\_user}.
\end{verse}


The tests typically have PBS available and most of the \file{test\_user}
scripts simply setup and run a basic PBS job for the installed software,
e.g., PVM, MPI's.  Tests making use of PBS must be submitted via the
\file{test\_user} script.  The \file{pbs\_test} helper script is used to
display results for the package's test as ``PASSED'' or ``FAILED'' based
upon return codes.  This script can be run in interactive or
non-interactive mode.  The arguments are detailed at the top of the 
\file{pbs\_test} file and by using the `\verb=--help=' option interactively.

As each \file{test\_user} script is processed, the list of nodes are passed
as command line arguments.  The following is an excerpt taken from an
example \file{test\_user} script that submites a PVM job to PBS via
\file{pbs\_script.pvm}.
% test_user oscartst 0 node1 node2 node3 node4 node5 ...
\begin{footnotesize}
\begin{verbatim}
      #!/bin/sh
      cd $HOME
      clients=`echo $@ | wc -w`    # Get number of args (nodes)

      $HOME/pbs_test $clients 1 $HOME/pvm/pbs_script.pvm "SUCCESSFUL" \
        $HOME/pvm/pvmtest 3 "PVM (via PBS)"

      exit 0
\end{verbatim}
\end{footnotesize}
(For further details see files in \file{\$OSCAR\_HOME/testing} and
\file{\$OSCAR\_HOME/lib/OSCAR/Package.pm}.)


 
\subsection{doc}
\label{sect:pkg-doc}

This directory contains supplemental documentation for the package.  There
are a few pre-defined \LaTeX\ files that may be incorporated into the
overall OSCAR documentation if the package's classification is either
\emph{core} or \emph{selected}~\footnote{That is to say the package is
included in the main distribution tarball -- not obtained via OPD.}.  These
files are: \file{install.tex}, \file{user.tex} and \file{license.tex}.  The
first is added to the overall \file{install.pdf} and contains information
related to the installation of the particular software package.  The latter
two files are incorporated into the \file{user.pdf}.   The user information
can be complete or simply pointers to obtaining more thorough documentation
for the particular package.  The license for all packages are listed in
this document based on the contents of this \file{license.tex} file.


