% -*- latex -*-
%
% $Id: design.tex,v 1.7 2001/08/21 18:22:42 geiselha Exp $
%
% $COPYRIGHT$
%

\section{Design of OSCAR 2.0}

In the first generation of OSCAR, the procedure was developed first
and the Wizard was then created to add an easy way to step through the
process. However, by doing so, there was no easy way to modify the
process without redesigning the Wizard. In order to avoid such
problems and to make OSCAR more user friendly, the architecture for
the second generation will be focused around the OSCAR Wizard. As
such, all operations and functionality available to the user will be
initiated from within the Wizard. Similarly, all interaction with the
OS installers, OSCAR Package Management, and OSCAR Data Repository
will be performed by the Wizard.

\subsection{Directory Structure}

OSCAR 2.0 and later will be installed into the \file{/opt} directory,
in accordance with the Linux Standards Base Filesystem Hierarchy (LSB
FSH).

The directory structure for OSCAR 2.0 will look like the following:

\begin{itemize}
\item \file{oscar[-<version>]/}: OSCAR base directory.  As described
  in the OSCAR Developer's Guide, this directory will have no version
  number in a developer's copy, and will have a version number in an
  OSCAR distribution package.
  
  All other directories and files listed below are in this top-level
  directory.

\item \file{core-packages/}: OSCAR core functionality packages.

\item \file{doc/}: HowTos and other documentation.

\item \file{oscar}: Executable to start the OSCAR Wizard.

\item \file{packages/}: Third party OSCAR packages.

\item \file{COPYING}: GNU General Public License v2.0.
  
\item \file{README}: Quick overview and pointers to documentation.
\end{itemize}

As shown above, there will be a \file{packages} subdirectory within
the base OSCAR directory that will contain all of the third party
software packages integrated into OSCAR. Each package will be located
in its own directory under 'packages', with the directory name being
of the form \file{pkgname}. All of the scripts and supporting files
for a package will reside in this directory.  Similarly, there will be
a \file{core-packages} subdirectory which will hold the software
packages which are responsible for core functionality within OSCAR.

\subsection{OSCAR Data Repository}

The OSCAR Data Repository (ODR) is used by OSCAR to keep the
information necessary for cluster installation and ongoing
maintenance. The ODR is actually just one instantiation of the Command
Line Accessible Modular Data Repository (CLAMDR). CLAMDR was
originally developed for use as the ODR, but has since added features
allowing it to be generic enough to be used by other projects, such as
the System Installation Suite.

The intent behind developing CLAMDR was to come up with a simple data
repository that could hold generic information and was easily
accessible from the command line. As development progressed, the
developers were able to abstract the specification of the data to be
stored in a separate "syntax module", and as such the project gained
its 'modular' aspect. The actual format for the data files used by
CLAMDR is that of flat files containing colon separated values, with
one file for each of the categories defined in the syntax module,
which itself is also a flat file.  This format was chosen to allow
easy processing of data by standard scripting.

Along with the actual data files themselves, CLAMDR provides two
routines (\cmd{readDR.pl} and \cmd{writeDR.pl}) that may be called
like normal command-line programs in order to read information from or
write information to the repository. The \cmd{readDR.pl} routine may
be called by any user. The \cmd{writeDR.pl} routine is reserved for
use by the OSCAR Wizard and installers, which will operate as root.
Both routines have multiple ways that they may be invoked, with each
method behaving differently.

\subsubsection{\cmd{readDR.pl} Usage}

\subsection*{NAME}
readDR.pl --- a script to read ODR data

\subsection*{SYNOPSIS}\begin{verbatim}
  readDR.pl --list                 # list all data files
  readDR.pl client                 # read all client rows
  readDR.pl --columns client       # list column names for table client
  readDR.pl client NAME=test       # read all columns of client row 'test'
  readDR.pl client NAME=test STATE # read STATE column of client row 'test'
\end{verbatim}

\subsection*{DESCRIPTION}
{\bf readDR.pl} is a command line interface to read cluster persistent data.
Parameters are read from the command line, output is written to STDOUT.
Each output line consists of {\em NAME=VALUE\/} pairs where {\em NAME\/} is the
column name and {\em VALUE\/} is the corresponding column value for a row
matching the input search critera.

\subsubsection*{Syntax}%
\index{Syntax}

readDR.pl {\tt [}{\em options\/}{\tt ]} filename {\tt [}{\em column spec\/}{\tt ]} {\tt [}{\em filter spec\/}{\tt ]}

\subsubsection*{Options}%
\index{Options}

The following options are recognized:

\begin{description}

\item[-D, --Directory]%
\index{-D, --Directory@-D, --Directory}%
\hfil\\
Directory where data files are located.

\item[-d, --distinct]%
\index{-d, --distinct@-d, --distinct}%
\hfil\\
List only distinct occurences.

\item[-c, --columns]%
\index{-c, --columns@-c, --columns}%
\hfil\\
List columns names only.

\item[-l, --list]%
\index{-l, --list@-l, --list}%
\hfil\\
List all data filenames.

\item[-s, --syntax]%
\index{-s, --syntax@-s, --syntax}%
\hfil\\
Syntax to apply when reading data files.

\end{description}

\subsubsection*{Filename}%
\index{Filename}

The name of the data file to read. A complete list of all defined data files may
be obtained by issuing the command:

readDR.pl --list

\subsubsection*{Column spec}%
\index{Column spec}

Column specification is a whitespace delimited list of column names to display.
A complete list of all columns for a given data file may be obtained by issuing
the command:

readDR.pl --columns {\em filename\/}

If no column specification is provided, all columns will be displayed.

\subsubsection*{Filter spec}%
\index{Filter spec}

Filter specification consists of whitespace delimited {\em NAME=VALUE\/} pairs. If provided,
only the rows in the given data file matching the filter specification will be displayed.
The complete filter specification is the logical {\bf AND} of all filter clauses. Note
that the filter specification is an exact match only test.

\subsubsection{\cmd{writeDR.pl} Usage}

\subsection*{NAME}
writeDR.pl --- script to add, update, delete ODR data

\subsection*{SYNOPSIS}\begin{verbatim}
  writeDR.pl --add client NAME=node1 DEFAULT_ROUTE=10.0.0.1 # add a client
  writeDR.pl -f NAME=node1 client STATE=enabled # update client 'node1'
  writeDR.pl -d client STATE=disabled # delete all clients with STATE=disabled
\end{verbatim}

\subsection*{DESCRIPTION}
{\bf writeDR.pl} is a command line interface to write cluster persistent data.
Parameters are read from the command line and are changes applied to the
persistent data.

\subsubsection*{Syntax}%
\index{Syntax}

writeDR.pl {\tt [}{\em options\/}{\tt ]} filename {\tt [}{\em column spec\/}{\tt ]}

\subsubsection*{Options}%
\index{Options}

The following options are recognized:

\begin{description}

\item[-D, --Directory]%
\index{-D, --Directory@-D, --Directory}%
\hfil\\
Directory where data files are located.

\item[-F, --Force]%
\index{-F, --Force@-F, --Force}%
\hfil\\
Force delete/update

\item[-a, --add]%
\index{-a, --add@-a, --add}%
\hfil\\
Add row to data file.

\item[-d, --delete]%
\index{-d, --delete@-d, --delete}%
\hfil\\
Delete row from data file.

\item[-f, --filter={\em filer spec\/}]%
\index{-f, --filter=filer spec@-f, --filter={\em filer spec\/}}%
\hfil\\
Filter specification

\item[-s, --syntax]%
\index{-s, --syntax@-s, --syntax}%
\hfil\\
Syntax to apply when reading data files.

\end{description}

\subsubsection*{Filename}%
\index{Filename}

The name of the data file to write. A complete list of all defined data files may
be obtained by issuing the command:

readDR.pl --list

\subsubsection*{Column spec}%
\index{Column spec}

Column specification consists of whitespace delimited {\em NAME=VALUE\/} pairs
used to assign values during {\bf add} or {\bf update} operation. Column names
not provided for an {\bf add} operation will be assigned an undefined value.
Column names not provided for an {\bf update} operation will be not be changed.
Column spec is ignored for {\bf delete} operation.

\subsubsection*{Filter spec}%
\index{Filter spec}

Filter specification consists of {\em NAME=VALUE\/} pairs specified on the {\bf {\tt --}filter} option.
Multiple <--filter> options may be provided as in:

-f A=2 --filter='B=3'

or filters may be grouped using a ',' delimiter, as in:

--filter='A=2,B=3'

The complete filter specification is the logically {\bf and} of all filter clauses. Note
that the filter specification is an exact match only test.

Be aware that in the event no filter spec is provided for an {\bf update} or a {\bf delete}
operation, all rows will be affected. In this situation, the {\bf {\tt --}Force} option must
be supplied to coerce operation (this is strictly a safety measure to prevent
inadvertent data modification).

\subsubsection{ODR Categories}

The ODR syntax module has been arranged to keep information about five
categories of data: \odrcat{adapter}, \odrcat{client},
\odrcat{cluster}, \odrcat{hostlist}, and 
\odrcat{personality}. Within each category, there are a number of keys 
that hold the information about each category item. Unless otherwise
noted, each value within a category item is assumed to be a non-null
character string.


\paragraph{\odrcat{adapter} Category}

Each item in the \odrcat{adapter} category represents a network
adapter. A single record is maintained for each network adapter.  The
keys and their descriptions are listed in
Table~\ref{tbl:design-odr-cats-adapter}.

Notes:

\begin{itemize}
\item Each item in \odrcat{adapter} is uniquely identified by 
both its \odrkey{HOST} and \odrkey{INTERFACE} value pair.

\item \odrkey{HOST} is a cross reference field to the \odrkey{HOST}
  key in the \odrcat{client} category.
  
\item This category is currently only sufficient for IP-based networks
  (e.g, the \odrkey{IP\_ADDR}, \odrkey{IP\_NETMASK}, and
  \odrkey{IP\_CONFIG} keys).  As support is added for other types of
  networks, new fields will be added as appropriate.

\item If \odrkey{IP\_CONFIG} is specified as {\tt manual}, both 
  \odrkey{IP\_ADDR} and \odrkey{IP\_NETMASK} are expected to be
   provided.

\item If \odrkey{IP\_CONFIG} is specified as {\tt dhcp}, both 
  \odrkey{IP\_ADDR} and \odrkey{IP\_NETMASK} are expected to be
   null.
\end{itemize}

\begin{table}[t]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{1}{|c|}{Key} &
      \multicolumn{1}{c|}{Value} \\
      \hline
      \odrkey{HOST} & Hostname of the machine containing the adapter \\
      \odrkey{INTERFACE} & Interface of the adapter (e.g., {\tt eth0}) \\
      \odrkey{ETHER\_MAC} & Media Access Card (MAC) address \\
      \odrkey{IP\_ADDR} & IP address \\
      \odrkey{IP\_NETMASK} & IP subnet mask to be used with 
        \odrkey{IP\_ADDR} \\
      \odrkey{IP\_CONFIG} & Method used to configure adapter ({\tt
        manual}, {\tt dhcp}) \\
      \hline
    \end{tabular}
    \caption{Keys maintained for the \odrcat{adapter} ODR category.}
    \label{tbl:design-odr-cats-adapter}
  \end{center}
\end{table}

\paragraph{\odrcat{client} Category}

Each item in the \odrcat{client} category represents a cluster client
node.  A single record is maintained for each node.  The keys and
their descriptions are listed in
Table~\ref{tbl:design-odr-cats-client}.

Notes:

\begin{itemize}
\item Each item in the \odrcat{client} category is uniquely identified
by its \odrkey{HOST} value.

\item The \odrkey{HOST} key refers to the FQDN of the host to prevent
  any ambiguities.
  
\item The \odrkey{STATE} key refers to an administrative selection of
  whether or not to include the node in OSCAR functions; it
  does not refer to whether the machine is physically enabled or
  disabled.

\item \odrkey{NUM\_PROCS} is expected to be a numeric value greater
  than 0.
\end{itemize}

\begin{table}[t]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline \multicolumn{1}{|c|}{Key} & \multicolumn{1}{c|}{Value} \\
      \hline \odrkey{HOST} & Fully qualified domain name of the machine \\
      \odrkey{IP\_DEFAULT\_ROUTE} & IP address of this machine's gateway 
        machine \\ 
      \odrkey{STATE} & Current state of the machine ({\tt enabled}, {\tt
        disabled}) \\ \odrkey{NUM\_PROCS} & Number of processors in the
      machine \\ \hline
    \end{tabular}
    \caption{Keys maintained for the \odrcat{client} ODR category.}
    \label{tbl:design-odr-cats-client}
  \end{center}
\end{table}

\paragraph{\odrcat{cluster} Category}

Each item in the \odrcat{cluster} category represents an entire
cluster.  A single record is maintained for each cluster.  The keys
and their descriptions are listed in
Table~\ref{tbl:design-odr-cats-cluster}.

Notes:

\begin{itemize}
\item Each item in the \odrcat{cluster} category is uniquely identified
  by its \odrkey{NAME} value.

\item The ``head node'' is the node where OSCAR is installed.

\item \odrkey{CLUSTER\_HEAD} and \odrkey{INSTALL\_NODE} are cross
  references to the \odrkey{HOST} key in the \odrcat{client} category.

\item \odrkey{OSCAR\_VERSION} is expected to be {\tt 2.0}, the current
  OSCAR version.

\item When initially defined, both the \odrkey{CLUSTER\_HEAD} and
  \odrkey{INSTALL\_NODE} values may be null. As \odrcat{client} entries
  are added to the cluster, these values are expected to be defined and
  to refer to existing \odrcat{client} items.
\end{itemize}

\begin{table}[t]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{1}{|c|}{Key} &
      \multicolumn{1}{c|}{Value} \\
      \hline
      \odrkey{NAME} & Cluster name \\
      \odrkey{OSCAR\_VERSION} & Version of OSCAR used to install the cluster \\
      \odrkey{CLUSTER\_HEAD} & Hostname of the head node of the cluster \\
      \odrkey{INSTALL\_NODE} & Hostname of the node used to install clients \\
      \odrkey{NETWORK\_TYPE} & Type of network cluster nodes reside on
      ({\tt private}, {\tt public}) \\
      \hline
    \end{tabular}
    \caption{Keys maintained for the \odrcat{cluster} ODR category.}
    \label{tbl:design-odr-cats-cluster}
  \end{center}
\end{table}

\paragraph{\odrcat{personality} Category}

Items in the \odrcat{personality} category represent groupings of
software packages. Items sharing a common \odrcat{NAME} value
constitute a unique \odrcat{personality} - a group of software
packages to be installed on a \odrcat{client}.
The keys and their descriptions are listed in
Table~\ref{tbl:design-odr-cats-personality}.

Notes:

\begin{itemize}
\item Each item in the \odrcat{personality} category is uniquely
  identified by its \odrkey{NAME}, \odrkey{SOFTWARE}, and 
  \odrkey{VERSION} triplet.

\item A software package (as defined by its \odrkey{SOFTWARE} and
  \odrkey{VERSION} value pair) may exist in more than one personality.
  During package installation, resolution of unique packages will
  occur in the event a \odrcat{client} is assigned more than one 
  \odrcat{personality}.

\item \odrkey{VERSION} is a version string, preferably in a
  GNU-like format ({\tt major.minor.release}).

\item \odrkey{SERVER} is currently defined, and carried along
  for historical reasons.
\end{itemize}

\begin{table}[t!]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{1}{|c|}{Key} &
      \multicolumn{1}{c|}{Value} \\
      \hline
      \odrkey{NAME} & Personality name \\
      \odrkey{SOFTWARE} & Name of software package \\
      \odrkey{VERSION} & Version of software package \\
      \odrkey{SERVER} & Hostname of the server for the package service
      (if not the cluster head node) \\
      \hline
    \end{tabular}
    \caption{Keys maintained for the \odrcat{personality} ODR category.}
    \label{tbl:design-odr-cats-personality}
  \end{center}
\end{table}

\paragraph{\odrcat{hostlist} Category}

Each item in the \odrcat{hostlist} category represents a list of
cluster clients.  The keys and their descriptions are listed in
Table~\ref{tbl:design-odr-cats-hostlist}.

Notes:

\begin{itemize}
\item Each item in the \odrcat{hostlist} category is uniquely
  identified by its \odrkey{HOST} and \odrkey{PERSONALITY} value pair.

\item \odrkey{HOST} is a cross reference to the \odrkey{HOST} key in
  the \odrcat{client} category.

\item \odrkey{PERSONALITY} is a cross reference to the \odrkey{NAME} key in
  the \odrcat{personality} category.
\end{itemize}

\begin{table}[t!]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{1}{|c|}{Key} &
      \multicolumn{1}{c|}{Value} \\
      \hline
      \odrkey{HOST} & Reference to the client name \\
      \odrkey{PERSONALITY} & Reference to the personality to install \\
      \hline
    \end{tabular}
    \caption{Keys maintained for the \odrcat{hostlist} ODR category.}
    \label{tbl:design-odr-cats-hostlist}
  \end{center}
\end{table}

\subsection{OSCAR Wizard}

The OSCAR Wizard will be the focus for all operations performed in
version 2.0. The Wizard will be responsible for interfacing with users
to gather information needed by OSCAR and the OS installation tools to
install the cluster and store it into the OSCAR Data Repository. It
will then use the information gathered to be the control mechanism for
running the backend installation tasks.

The Wizard will provide three modes of operation for users: simple,
standard, and expert. The installation of the operating system on
clients will be an option to users of all three modes, but the level
of control over this operation will be set according to the mode
level.

In the simple mode of operation, users will only be required to answer
a minimal set of questions needed to install an OSCAR cluster using
the default set of packages. If a user selects to install the OS on
clients, a default configuration will be assumed.

In the standard mode of operation, users will need to answer the same
minimal set of questions, but will be allowed to select which cluster
software packages to install. Similarly, users will also be given the
choice of blocking or allowing certain network services, for those
users familiar with network security issues.  If a user selects to
install the OS on clients, he or she will be allowed to modify the
configuration for some basic parameters such as the kernel to install
and the disk partitioning.

In the expert mode of operation, users will be given as much control
as possible over the cluster installation process, including
installation of the OS on clients, network configuration, software
package selection, and network security levels.

The Wizard will be implemented as a Webmin module. Webmin is a
web-based interface for system administration under Unix that can be
used with any browser that provides support for tables and
forms. Webmin consists of a simple web server, and a number of CGI
programs that perform the system tasks. In order to run Webmin, one
needs only a Perl version 5 binary, since the server, all CGI
programs, and any Webmin modules are written entirely in Perl.

\subsection{Node Installation}

The default OS installer in OSCAR 2.0 will be the System Installation
Suite (SIS), the collaboration between the LUI and SystemImager
projects. As such, the Wizard will be designed to work with SIS in
order to install the OS on client machines when users wish to do
so. Any other future OS installation solutions will also need to be
integrated with the Wizard.

\subsection{Software Package Management}
\label{sec:design-software-package-mgmt}

Just as OSCAR 2.0 will support multiple installation methods, the
software package management will also be generic enough to support
multiple backends. As such, the package management API only requires
that integrators provide scripts that install, uninstall, and
configure the software on a single machine. Each backend
implementation to the package management will use these scripts in
whatever means is appropriate. For the initial release of OSCAR 2.0,
there will probably be at least two backends, one that incorporates
using the Cluster Command and Control (C3) tools to do distributed
updates on all clients and another that uses SystemImager to update
client images that will be pushed to all clients.

\subsection{Cluster Software Installation/Uninstallation}

One of the greatest advantages of OSCAR for users wishing to quickly
build clusters is that OSCAR automates the installation of all
packages included. In addition, the second generation OSCAR will
support user selection of which packages to install, as opposed to the
first generation where all included software packages were
automatically installed. Another feature that will make its way into
the second generation OSCAR is the ability for users to uninstall
packages installed by OSCAR.

The new management scheme for installing/uninstalling software
packages is based on the premise that most current cluster software is
easily installed on a single machine. As such, the management scheme
only requires package integrators to automate that single machine
installation process through use of a script that will be initiated on
each cluster node by OSCAR. Since the process for installation of a
package on a server node may differ from that for client nodes, the
script supplied must support a command-line switch that specifies the
type of node and proceed accordingly.

In order to support uninstallation, package integrators must also
supply a single machine uninstallation script that will be used in the
same manner as the installation script. The script should similarly
support the distinction between server and client nodes.

In addition to providing scripts for installation and uninstallation,
package integrators will also be required to provide a list of files
that are needed by the scripts.  Typically, these files would be that
actual software package (e.g., RPM or tarball) and any supplementary
scripts that are called from the installation/uninstallation scripts.

\subsubsection{Cluster Configuration Updates}

Another added functionality that will be supported in the second
generation OSCAR is the ability to add/remove nodes to/from the
cluster after the cluster has been initially installed. Such
operations are common when clusters are being built in stages or when
performing routine maintenance on cluster nodes. As a result, each
package will be required to provide a script that updates any of its
configuration files that keep cluster information whenever such an
operation is performed. These scripts will have access to the OSCAR
Data Repository (ODR) and its access routines, which will provide the
updated configuration information. The configuration script should
adhere to the same node type requirements specified for the
(un)installation scripts.

The package management scheme for configuration updates has also been
designed to allow nodes which are not online at the time of the
cluster configuration update to be notified of the update. In normal
operation, the configuration scripts will be initiated on every
cluster node after the configuration update has been
performed. However, this means that any nodes not online at that point
will not be notified of the update. As such, OSCAR will also employ
the use of a boot time initialization script that will run the
configuration scripts for each software package installed on a
client. The OSCAR initialization script will be run as part of the
init process for whichever Linux distribution is installed on the
client. In order to support the two different times the configuration
script will be run, the script will need to support a command-line
option distinguishing whether the script was initiated by OSCAR or the
OSCAR initialization script.

\subsubsection{Package API Requirements}

The package management API is an attempt to simplify the interaction
between individual software package scripts and OSCAR.  Since the
installation, uninstallation, and configuration scripts for each
package must support similar options, the API was condensed into a
single interface. That interface is as follows:

\cmd{opkgconfig \{-c|-s\} <function> [--atboot]}

\begin{itemize}
\item \cmd{<function>} is one of: {\tt install}, {\tt uninstall}, {\tt
    configure}

\item \cmd{-c}: specifies the script will be run on a package client
  
\item \cmd{-s}: specifies the script will be run on the package server
  
\item \cmd{--atboot}: indicates the script is being run from the boot
  time initialization script, and is valid only with the configure
  function
\end{itemize}

The basic idea is that each integrator will create a
\file{opkgconfig} script that will be invoked by either the OSCAR
wizard or the boot time initialization script. How that script is
implemented is left up to the integrator, but it must be executable. 
Typically, the integrator would create three underlying scripts, one 
for each of the available functions, and call each script from 
\file{opkgconfig} based upon the command-line options.

For each of the three functions, integrators must also provide a list
of files that are needed to complete the function. The list for each
function will be named \file{<function>-files.txt} and should be
placed in the package's base directory. The files specified in the
list can be either absolute or relative pathnames. In addition, the
\file{opkgconfig} script itself should be listed in each of the file lists.

To recap, here is a list of the files that each package must provide
in its directory:

\begin{itemize}
\item \cmd{<pkgname>/opkgconfig}
\item \cmd{<pkgname>/install-files.txt}
\item \cmd{<pkgname>/uninstall-files.txt}
\item \cmd{<pkgname>/configure-files.txt}
\end{itemize}

% LocalWords:  Exp Filesystem LSB FSH oscar doc HowTos Docs pkgname ODR CLAMDR
% LocalWords:  readDR pl writeDR IP DDR ETMASK ONFIG CONFIG dhcp Hostname eth
% LocalWords:  FQDN OUTE NUM ROCS EAD ERSION YPE PACKAGELIST packagelist Webmin
% LocalWords:  HOSTLIST hostlist headnode hostname backend CGI Perl LUI API un
% LocalWords:  SystemImager backends uninstall Uninstallation init
% LocalWords:  uninstallation tarball pkgconfig atboot Solaris pkg
