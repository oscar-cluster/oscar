#!/usr/bin/perl

# cconfig (replacement for c3_conf_manager)
#
# Written by Olivier Lahaye 14/03/2014
#
# Copyright (C) 2014        CEA - Commissariat a l'Energie Atomique
#                           Olivier LAHAYE <olivier dot lahaye at cea dot fr>
#                           All rights reserved.
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#

use strict;
use Carp;
use feature "switch";
use Data::Dumper;

use File::Copy;
use Getopt::Long;
use IO::Socket::INET;

Getopt::Long::Configure ("pass_through");

my $SCRIPT      = "cconfig";
my $VERSION     = "v1.0";
my $refreshstatuses   = undef; # If set, nodes are pinged and status (dead/online) is updated accordingly.
my $sortnodes      = undef; # If set, nodes are sorted.
my $target_cluster = undef;
my @target_nodes   = ();
my $target_service = undef; # Name of service to check for remote node being alive. (set using --service)
my $zero           = undef; # 1 if use 0-indexing. (default is not to use zero indexing). undef means don't change.
my $one            = undef; # 1 if force to no using 0-indexing. (option -1)
my $default        = undef; # if set, the current cluster is moved at 1st position so it becomes default.
my $file           = undef; # Alternate config file.
my $dryrun         = undef; # If set: write result to stdout instead of the c3.conf file.
my $noresolv       = undef; # If defined: doesn't try to resolv hostnames.
my $default_cluster= undef; # 1st cluster seen.

our @clusters;  # Table of clusters hashes (and comments)
my $hostname    = `hostname`;

my $c3conf = '/etc/c3.conf';
if (defined($ENV{C3_CONF})) {
    # Override default "c3.conf" based on NEW_C3_CONF EnvVar
    $c3conf = $ENV{C3_CONF};
}

sub show_version {
  print "$SCRIPT $VERSION\n";
  exit 0;
}

sub usage {
  print <<EOF;
$SCRIPT $VERSION
$0

Written by Olivier Lahaye <olivier.lahaye\@cea.fr>
Full revrwrite of c3_conf_manager written by Jason Brechin
and Geoffroy Vallee.

Usage: $0 [command] [options]


COMMANDS:

--version|-v               Print version information
--help|-h|-?               Usage Information (this)
addcluster                 Adds cluster with given name
                           (MUST BE USED WITH the --cluster and --nodes options if not a virtual cluster.)
delcluster                 Removes cluster with given name
addnodes                   Add nodes to a cluster
                           If a node was marked dead, the node is
                           marked back to alive.
                           (MUST BE USED WITH the --cluster and --nodes options)
                           ranges are accepted.
delnodes                   Remove a node from a cluster
                           (MUST BE USED WITH the --cluster and --nodes option)
disablenodes               Mark nodes as dead (or excluded if part of a range)
                           ( --cluster is optional --nodes <nodenames> is optional (requires --cluster if used).)
enablenodes                Mark nodes back to life.
                           ( --cluster is optional --nodes <nodenames> is optional (requires --cluster if used).)
update                     Update config file (usefull to sort nodes or updating status)
                           ( --cluster is optional --nodes <nodenames> is optional (requires --cluster if used).)
listnodes                  Lists active nodes in cluster
                           (MUST BE USED WITH the --cluster option)
listclusters               Lists defined clusters
check                      Check validity of the c3 configuration file.


OPTIONS:

--refreshstatuses|r        Update nodes statuses (dead or alive) using ping -c1.
--sortnodes|s              Sort the nodes in cluster definitions.
                           (can be used with --cluster option
                           to restrict the sort to that cluster)
--default|d                Set this cluster as default (update or addcluster)
--cluster|c <clustername>  Specify the cluster name to work with
--nodes|n <node ...>       List of nodes or nodes ranges to works with (space separated)
--noresolv|l               Don't try to check if hostnames resolv.
--service|e <service name> Name of service to use to test that a remote node is alive or not.
                           The service name can be any tcp service in /etc/services or a port number.
                           Special values are: ping, resolv, none (see cconfig(1) manpage).
--zero|z|0                 Force 0-indexing (do not insert or remove dummy dead entry)
                           Only valid for addcluster and update commands. Must be used with
                           --cluster option.
--nozero|noz|no0|1         Use dummy dead entry so indexing starts at 1.
--dry-run|u                Output restult to stdout instead of updating config file.
--file|f <file>            Use alternative config file.
EOF
exit 0;
}

# Read the options.
Getopt::Long::GetOptions(
    'default|d'          => \$default,
    'dry-run|u'          => \$dryrun,
    'refreshstatuses|r'  => \$refreshstatuses,
    'sortnodes|s'        => \$sortnodes,
    'cluster|c=s'        => \$target_cluster,
    'nodes|n=s{,}'       => \@target_nodes,
    'noresolv|l'         => \$noresolv,
    'zero|0|z!'          => \$zero,
    '1'                  => \$one,
    'file|f=s'           => \$file,
    'service|e=s'        => \$target_service,
    'help|h|?'           => \&usage,
    'version|v'          => \&show_version,
);

# Read the command.
my $command = shift(@ARGV); # read the command.

# Check that we've registered everything on the command line.
die "ERROR: Unknown remaining arguments: ".join(" ", @ARGV)."\n" if(scalar(@ARGV > 0));  # Nothing should remain in @ARGV.

# Handle -1 shortcut.
if (defined($one)) {
    die "ERROR: -0 and -1 options cannot be used at the same time." if(defined($zero) && $zero==0);
    $zero = 0;
}
if ($file) {
    if (-f $file) {
        $c3conf = $file;
    } else {
        die "ERROR: Cannot open $file\n";
    }
}

die "ERROR: --zero/--nozero needs --cluster option.\n" if(defined($zero) && !defined($target_cluster));

################################################################################
#
# Load a c3.conf file in memory.
#
################################################################################
sub parse_c3_conf() {

    my @c3_conf = ();
    my $cluster_def;

    if (!open (C3CONF, $c3conf)) {
        print "ERROR: Can't open $c3conf";
        return -1;
    }

    my $head_found;
    my $in_cluster_def;
    my $line;
    my $line_num=0;
    my $cluster_index=0;
    my $node_index;
    my $current_node;
    my $previous_range_start_index; # Position in cluster ref of previous range is previous block is a range.
    my $previous_range_start;       # start number for previous range
    my $previous_range_end;         # end number for previous range.
    my $last_node_index = -1;
    while(<C3CONF>) {
        $line = $_;
        chomp ($line);
        $line =~ s/^\s*//;     # Remove spaces at the start of the line
        $line =~ s/\s*$//;     # Remove spaces at the end of the line
        $line_num++;
        given ( $line ) {
            when (/^exclude\s(([0-9]+)|(\[(\d+)-(\d+)\])?)\s*(#.*)?$/) { # match exclude
                die "ERROR: exclude found outside cluster definition at line: $line_num [$line]\n" if($in_cluster_def==0);
                die "ERROR: vlcuster definition do not include nodes at line: $line_num [$line]\n" if (exists $cluster_def->{'vcluster'});
                die "ERROR: exclude does not follow a node range definition at line: $line_num [$line]\n" if ($previous_range_start_index == -1);
                # exclude: $1, value:$2, range:$3, start:$4, end:$5 comment:$6
                my $exclude_comment = $6;
                my $range_min=$4;
                my $range_max=$5;
                ($range_min=$2, $range_max=$2) if ($2 ne ""); # Single value => fake a range of one value.
                die "ERROR: exclude points outside previous range definition at line: $line_num [$line]\n" if (($range_min < $previous_range_start) || ($range_max > $previous_range_end));
                my $delta_range = $range_max-$range_min+1;
                my $node_start_index = $previous_range_start_index-$previous_range_start+$range_min;
                for (my $index=0; $index < $delta_range; $index++) {
                    $cluster_def->{'nodes'}[$node_start_index+$index]->{'status'} = "dead";
                    $cluster_def->{'nodes'}[$node_start_index+$index]->{'comment'} .= $exclude_comment if ($exclude_comment ne "");
                    $exclude_comment = ""; # Clear $6 so comment is only assigned to 1st node of the range.
                }
            }
            when (/^(dead\s+)?([a-z0-9_.-]+)\s*(#.*)?$/i) { # match single node (dead or alive)
                                                              # match also "_" eventhough it's forbidden in hostnames as we must match
                                                              # the remove_for_0-indexing string that exists in many c3.conf files.
                die "ERROR: dead found outside cluster definition at line: $line_num [$line]\n" if($in_cluster_def==0);
                die "ERROR: vlcuster definition do not include nodes at line: $line_num [$line]\n" if (exists $cluster_def->{'vcluster'});
                # dead: $1, comment: $2
                $previous_range_start_index=-1; # keep track that we forget about previous ranges for future "exclude" cmds.
                $previous_range_start=-1;
                $previous_range_end=-1;
                my $node;
                $node->{'name'} = lc($2);
                $node->{'comment'} = $3 if ($3 ne "");
                if( $head_found == 0 ) {
                    $head_found=1;
                    die "ERROR: dead head in cluster definition at line: $line_num [$line]\n" if($1 ne "");
                    $cluster_def->{'head'} = $node;    
                } else {
                    $node->{'status'} = "online";
                    $node->{'status'} = "dead" if ($1 ne ""); # if dead, $1="dead\s"
                    $cluster_def->{'nodes'}[$node_index] = $node;
                    $last_node_index = $node_index; # keep track of the last node entry in the cluster hash so we know were to append comments only lines
                    $node_index++;
                }
            }
            when (/^}\s*(#.*)?$/) { # match end cluster definition
                die "ERROR: Unexpected '}' found: $line_num [$line]\n" if($in_cluster_def==0);
                die "ERROR: Incomplete cluster definition. Missing head $line_num [$line]\n" if(! exists($cluster_def->{'name'}));
                # comment: $1
                $in_cluster_def=0;
                $cluster_def->{'end_comment'} = $1 if ( $1 ne "" );

                # Update nodes statuses if needed:
                # Note, this can't be done when reading nodes as the status is then overridden by
                # following exclude ranges. Thus we do that at the end.
                if(exists $cluster_def->{'nodes'} && defined($refreshstatuses)) {
                    for my $node (@{$cluster_def->{'nodes'}}) {
                        refresh_node_status_if_needed(\$node, $cluster_def->{'name'});
                    }
                }

                # Handle option --nozero: $zero==0 / --zero: $zero=1 / option not used: $zero is undefined.
                if(defined($zero) && $zero==0 && $target_cluster eq $cluster_def->{'name'}) { # Force non-zero indexing on selected cluster.
                    my $dummy_node;
                    $dummy_node->{'status'} = "dead";
                    $dummy_node->{'name'} = "remove_for_0-indexing";
                    $dummy_node->{'comment'} = "# remove this line for 0-indexing";
                    unshift(@{$cluster_def->{'nodes'}}, $dummy_node); # Add a prepending dummy node.
                }

                # Handle option --zero
                if(defined($zero) && $zero==1 && $target_cluster eq $cluster_def->{'name'} && !using_zero_indexing(@{$cluster_def->{'nodes'}})) {
                    shift(@{$cluster_def->{'nodes'}}); # Remove 1st dead dummy node.
                }

                # Handle --default option.
                if ($default && ($cluster_def->{'name'} =~ /$target_cluster/i)) {
                    $default_cluster = $target_cluster; # new default cluster.
                    unshift(@c3_conf, $cluster_def);
                } else {
                    push (@c3_conf, $cluster_def);
                }

                undef $cluster_def;
                $last_node_index = -1; 
            }
            when (/^cluster\s+([a-zA-Z0-9_-]+)\s*{\s*(#.*)?$/) { # match begin cluster definition
                # cluster:$1, comment:$2
                $in_cluster_def=1;
                $head_found=0;
                $node_index=0; # node index
                $cluster_def->{'name'} = $1;
                $default_cluster = $1 if(! defined($default_cluster)); # Keep track of default cluster.
                $cluster_def->{'start_comment'} = $2 if ( $2 ne "" );
                $cluster_def->{'nodes'} = ();
                $current_node=""; # last node name seen (needed to handle excludes)
                $previous_range_start_index = -1; # No previous range.
                $previous_range_start = -1;
                $previous_range_end = -1;
            }
            when (/^([a-z0-9.-]+)?:([a-z0-9.-]+)\s*(#.*)?/i) { # match complex head or vcluster (entry with ':')
                if( $head_found == 0 ) {
                    $head_found=1;
                    my $node;
                    die "ERROR: head already defined for cluster $cluster_def->{'name'} line: $line_num [$line]\n" if (exists $cluster_def->{'head'});
                    $node->{'comment'} = $3 if ($3 ne "");
                    if ($1 eq "") { # virtual cluster
                        $node->{'name'} = lc($2);
                        $cluster_def->{'vcluster'} = $node;
                    } else {
                        $node->{'name'} = lc($1);
                        $node->{'private'} = lc($2);
                        $cluster_def->{'head'} = $node;
                    }
                 } else {
                    die "ERROR: head already defined: $line_num [$line]\n";
                }
            }
            when (/^([a-z0-9.-]+)(\[(\d+)-(\d+)\])\s*(#.*)?$/i) { # match node range
                # node name: $1, complete range:$2, range start:$3, range end:$4, comment: $5
                die "ERROR: node found outside cluster definition at line: $line_num [$line]\n" if($in_cluster_def==0);
                die "ERROR: vlcuster definition do not include nodes at line: $line_num [$line]\n" if (exists $cluster_def->{'vcluster'});
                $previous_range_start_index=$node_index; # keep in mind the lower limit of the range for future "exclude"
                $previous_range_start = $3;
                $previous_range_end = $4;

                my $range_comment = $5;

                # exclude[0-9] is a node range. exclude [0-9] is an exclude range. (space before the range).
                warn "WARNING: node basename is 'exclude' in cluster at line $line_num. Is it what you want?" if( $1 eq "exclude" );

                for (my $nodenum = $3; $nodenum <= $4; $nodenum++) {
                    my $node;
                    $node->{'comment'} = $range_comment if ($range_comment ne "");
                    $range_comment = ""; # Clear comment after 1st node so comment is set on 1st node only.
                    $node->{'name'} = lc($1.$nodenum);
                    $node->{'status'} = "online";
                    #refresh_node_status_if_needed(\$node, $cluster_def->{'name'}); # BUG: Overridden by following exclude ranges.
                    $cluster_def->{'nodes'}[$node_index] = $node;
                    $last_node_index = $node_index; # keep track of the last node entry in the cluster hash so we know were to append comments only lines
                    $node_index++;
                }
            }
            when (/^$/) {
                die "ERROR: Empty line found within cluster definition at line ".$line_num if($in_cluster_def==1);
                push (@c3_conf, $line);
            }
            when (/(^#.*)/) { # Match comment lines
                #print "COMMENT: $line\n";
                if($in_cluster_def==1) {
                    if($last_node_index > -1) { # we have a node definition in our hash, we can append this line to its comment
                        $cluster_def->{'nodes'}[$last_node_index]->{'comment'} .= "\n\t".$line;
                        # We do no increase the $node_index (it already points to the end of the nodes table)
                    } else { # no nodes yet in the table; this line must be just above or below the head node definition.
                        if ($head_found == 1) { # this comment is after head definition but before any node defs. Attach to head comment.
                            if(exists $cluster_def->{'vcluster'}) {
                                $cluster_def->{'vcluster'}->{'comment'} .= "\n\t".$line;
                            } else {
                                $cluster_def->{'head'}->{'comment'} .= "\n\t".$line;
                            }
                        } else { # This comment is before head definition. Attach to cluster begin comment.
                            $cluster_def->{'start_comment'} .= "\n\t".$line;
                        }
                    }
                } else {
                    push (@c3_conf, $line);
                }
            }
            default {
                die "ERROR: Unexpected content at line: $line_num [$line]\n";
            }
        }
    }
    close(C3CONF);
    return(@c3_conf);
}

################################################################################
#
# refresh_node_status_if_needed. Refresh the node status if all conditions are met:
#  1/ --refreshstate is used
#  2/ cluster name matches $target_cluster if $target_cluster is defined
#  3/ node name is part of @target_nodes if @target_nodes is defined.
#
#  input:
#    $node: a hash node ref
#    $cluster_name: the name of the cluster that needs to be matched against $target_cluster
#
################################################################################

sub refresh_node_status_if_needed($$) {
    my $node = shift;
    my $cluster_name = shift;
    return if (! defined($refreshstatuses)); # Don't do anything, the option is not set.
    return if (defined($target_cluster) && ($cluster_name !~ /$target_cluster/i)); # doesn't match --cluster
    return if ((scalar(@target_nodes) > 0) && !(lc($$node->{'name'}) ~~ @target_nodes)); # doesn't match --nodes
    die "ERROR: --nodes used without --cluster" if (!defined($target_cluster) && (scalar(@target_nodes) > 0));
    set_node_ping($node);
}

################################################################################
#
# Write an exclude rule if $exclude_start > -1
#
################################################################################

sub print_exclude_range($$) {
    my($exclude_start,$exclude_end) = @_;
    if($exclude_start>-1) {
        if ($exclude_start == $exclude_end) { # Single entry
             print NEW_C3_CONF "\texclude $exclude_start\n";
        } else {
             print NEW_C3_CONF "\texclude [$exclude_start-$exclude_end]\n";
        }
    }
}

################################################################################
# 
# Print previous node or node range including optional associated dead or
# eacludes lines.
# $cluster:     cluster hash reference describing the cluster we work on.
# $element_idx_start: element in %cluster we start looking at.
# $range_name:  common part of the node name (or node name if single node)
# $range_start: node range start index
# $range_end: node range last index
# $range_comment: concatenation of all comments for that node(s).
#
################################################################################

sub print_previous_node_range($$$$$$$) {
    my ($cluster, $element_idx_start, $range_name, $range_start, $range_end, $range_comment, $last_node_comment) = @_;

    # We want to print all nodes comments aside the range.
    # If a comment was just after the last node in the range it'll be attached to that node.
    # At this point, the only thing we can do is:
    # If range_comment doesn't exists and last node comment starts with a \n (chencked before this call)
    # Then it was below the last node, so we keep the \n
    if(($range_comment ne $last_node_comment) && ($range_start >= 0)) {
        # Remove the leading \s*\n\s* so comments start aside range
        $range_comment =~ s/^\s*#/ #/; # Clean leading trash.
    } else {
        $range_comment =~ s/^[ \t]*#/ #/; # Keep just one space before comment.(keep \n)
    }

    if($range_end-$range_start > 0) {
        $range_comment = $range_comment if ($range_comment ne "");
        # We print the node range.
        print NEW_C3_CONF "\t$range_name"."[".$range_start."-".$range_end."]".$range_comment."\n";

        # scan this range to see if we have to write some ecxlude rules.
        my $exclude_start=-1;
        my $exclude_end=-1;
        my $range_idx = $range_start;
        my $idx = $element_idx_start-1; # Start the scan at the physical beginning of the range.
        while () {
            $idx++;
            next if( ref($cluster->{'nodes'}[$idx]) ne 'HASH' ); # We skip comment or empty line.(already printed)
            if($cluster->{'nodes'}[$idx]->{'status'} eq "dead" ) { # dead node in a range
                if($exclude_start==-1) {
                     $exclude_start=$range_idx;
                     $exclude_end=$exclude_start;
                } else {
                     $exclude_end++;
                }
            } else { # online node in a range
                     # check if an exclude rule was in progress.(this entry is not dead, but previous ones may be).
                print_exclude_range($exclude_start,$exclude_end);
                # reset the exclude rule (online node).
                $exclude_start=-1;
                $exclude_end=-1;
            }
            $range_idx++;
            last if ($cluster->{'nodes'}[$idx]->{name} eq "$range_name"."$range_end");
            last if ($idx >= scalar(@{$cluster->{'nodes'}})); # Should never occure, but who knows.
        }
        # eventualy print last exclude rule.
        print_exclude_range($exclude_start,$exclude_end);
        $exclude_start=-1;
        $exclude_end=-1;
    } else { # previous element was not in a range. print single element.
             # still need to check if dead or online. (need to look for previous node status)
        if ($range_name ne "") { # skip if name = "": either a comment (should not occure or empty node definition (splice when deleting node).
            $range_name = "dead $range_name" if ($cluster->{'nodes'}[$element_idx_start]->{'status'} eq "dead");
            my $number="";
            $number = $range_start if ($range_start >= 0);
            print NEW_C3_CONF "\t$range_name".$number." ".$range_comment."\n";
        }
    }

}

################################################################################
# 
# Write the c3.conf file from memory
#
################################################################################
sub write_c3_conf (@) {
    my @c3_conf = @_;
    my $comment;

    # 1st Open the File for overwriting.
    if($dryrun) { # Dry Run => print to stdout.
        *NEW_C3_CONF = *STDOUT;
    } else {
        die "ERROR: Can't create $c3conf~ backup: ".$!."\n" if ( ! copy($c3conf,$c3conf."~"));
        open(NEW_C3_CONF, ">", $c3conf) or die "Can't open config file $c3conf for writing: $!";
    }

    for my $element (@c3_conf) {
        if (ref($element) eq 'HASH') { # A cluster definition
            my %cluster = %{$element};
            my $element_idx_start=-1;
            my $range_start=-1;
            my $range_end=-1;
            my $range_name="";
            my $range_comment="";
            my $last_comment="";

            # Print the "cluster" line.
            $comment = "";
            $comment = " ".$cluster{'start_comment'} if (exists($cluster{'start_comment'}));
            print NEW_C3_CONF "cluster $cluster{'name'} {$comment\n";

            # Print the cluster head (or vlcuster definition).
            if(exists $cluster{'vcluster'}) {
                $comment = "";
                $comment = " ".$cluster{'vcluster'}->{'comment'} if (exists($cluster{'vcluster'}->{'comment'}));
                print NEW_C3_CONF "\t:".$cluster{'vcluster'}->{'name'}.$comment."\n";
            } else { # normal cluster.
                $comment = "";
                $comment = " ".$cluster{'head'}->{'comment'} if (exists($cluster{'head'}->{'comment'}));
                my $name = $cluster{'head'}->{'name'};
                $name .= ":".$cluster{'head'}->{'private'} if(exists($cluster{'head'}->{'private'}));
                print NEW_C3_CONF "\t".$name.$comment."\n";
            }

            # Print the nodes entries (or only comments in case of vcluster).
            if(defined $cluster{'nodes'}) { # there are some nodes that are defined.
                if ((defined $sortnodes) && (! defined($target_cluster) || $cluster{'name'} =~ /$target_cluster/i)) { # need to sort nodes before working
                    # We only sort of $target_cluster is not defined or if $cluster{'name'} is the defined $target_cluster.
                    # 1st, check 1st element. If dead, it may be a dummy entry for avoiding 0 indexing.
                    # Trick is to prepend a "!" to the name so it stays at the 1st place during the sort.

                    if( ! using_zero_indexing(@{$cluster{'nodes'}}) ) {
                        # prepend a "!" to the name so it stay 1st after sorting.
                        $cluster{'nodes'}[0]->{'name'} = "!".$cluster{'nodes'}[0]->{'name'}; # "!" is not allowed in hostname: we're sure it'll be uniq.
                    }

                    # Sorting steps:
                    # 1st: map {[$_,$_->{'name'}=~/^([a-z0-9.-]*[a-z.-]+)([0-9]+)$/] } : create [$_, node basename, node number if any]
                    # 2nd: sort {$a->[1] cmp $b->[1] || $a->[2] <=> $b->[2] }  : compare nodes basenames. If equals, compare nodes numbers.
                    # 3rd: map  { $_->[0] } : get original element back.(drop basename and number we used to make the sort).
                    @{$cluster{'nodes'}} = map  { $_->[0] }
                                           sort {$a->[1] cmp $b->[1] || $a->[2] <=> $b->[2] }
                                           map  {[$_,$_->{'name'}=~/^([a-z0-9.-]*[a-z.-]+)([0-9]*)$/i] }
                                           @{$cluster{'nodes'}};
                    # If 1st node name starts with a "!", we need to remove this prepending "!" used to trick the sort keeping in place the dummy entry.
                    if( $cluster{'nodes'}[0]->{'name'} =~ /^!(.*)$/ ) {
                        $cluster{'nodes'}[0]->{'name'} = $1;
                    }
                }
                for (my $element_idx=0; $element_idx < scalar(@{$cluster{'nodes'}}); $element_idx++) { # need to work with indexes
                    my %node = %{$cluster{'nodes'}[$element_idx]};
                    my $comment = "";
                    $comment = $node{'comment'} if(exists( $node{'comment'}));

                    # check if node ends with a number (can we use a range?)
                    if ( $node{'name'} =~ /^([a-z0-9.-]*[a-z.-]+)((0*)([0-9]+[0-9]*))$/i ) { # in a node range. 
                        # $1: node basename - $2:$3.$4 - $3: number of zeros to append to basename - $4: node number.
                        if (($range_name eq $1.$3) && ($4-$range_end == 1)) { # still in same range name and indexes contiguous.
                            $range_end++;
                            if (exists ( $node{'comment'})) {
                                $range_comment .= "\n" if (($range_comment ne "") && ($node{'comment'} !~ /^\n.*/));
                                $range_comment .= "\t".$node{'comment'};
                                $last_comment = $node{'comment'};
                            }
                        } else { # not the same range name or indexes not contiguous. Time to print range and reset indexes.
                            # 1st print previous range if any.
                            print_previous_node_range(\%cluster, $element_idx_start, $range_name, $range_start, $range_end, $range_comment, $last_comment);
                            # Reset the range to the new value.
                            $element_idx_start = $element_idx; # Keep track of the starting element.
                            $range_name = $1.$3;             # common name including index leading zeros.
                            $range_start = $4;               # range start.
                            $range_end = $range_start;       # range end (at this pont, start and end are the same.
                            $range_comment = $comment;       # Keep track of comment if any.
                        }
                    } else { # current element is a simple node:
                        # 1st print previous range or node if any.
                        print_previous_node_range(\%cluster, $element_idx_start, $range_name, $range_start, $range_end, $range_comment, $last_comment);
                        # Clear printed range.
                        $element_idx_start=$element_idx;
                        $range_start=-1;
                        $range_end=-1;
                        $range_name="";
                        $range_comment="";
                        # print the simple node:
                        $range_comment=$cluster{'nodes'}[$element_idx]->{'comment'} if(defined($cluster{'nodes'}[$element_idx]->{'name'}));
                        $range_name=$cluster{'nodes'}[$element_idx]->{'name'};
                    }
                } # End cluster nodes or element print
            } # end  print cluster content.

            # Print last elements.
            print_previous_node_range(\%cluster, $element_idx_start, $range_name, $range_start, $range_end, $range_comment, $last_comment);

            # Print closing bracket.
            if(exists $cluster{'end_comment'}) {
                print NEW_C3_CONF "} ".$cluster{'end_comment'}."\n";
            } else {
                print NEW_C3_CONF "}\n";
            }
        } else { # comment
            print NEW_C3_CONF $element."\n";
        }
    }
}

################################################################################
#
# using_zero_indexing: Check if index 0 of a given node hash array is a dummy entry
# => return 1 if we use 0-indexing (no fake entry).
#
################################################################################

sub using_zero_indexing(@) {
    my @nodes = @_;
    return 1 if ($nodes[0]->{'name'} ~~ @target_nodes); # 1st node is part to target_nodes, we assume that it's a normal node
    if($nodes[0]->{'status'} eq 'dead') {
        # get the basename of all other nodes.
        return 0 if ( $nodes[0]->{'name'} !~ /^([a-z0-9.-]*[a-z.-]+)[0-9]*$/); # Node 0 doesn't match a hostname
        my @basenames = map { $_->{'name'}=~/^([a-z0-9.-]*[a-z.-]+)[0-9]*$/ } @nodes;
        if (! ($basenames[0] ~~ @basenames[1..scalar(@basenames)-1])) { # basename of 1st node not found in other nodes. this is probably a dummy entry.
             if( ! defined(gethostbyname($basenames[0])) ) { # if it resolvs, then we assume it's a normal node anyway.
                 return 0; # 1st entry is 1:dead, 2:uniq basename, 3:doesn't resolv
                           # => fake entry to avoid 0-indexing.
             } # else, it resolves, this is a normal node.
        } # else, other nodes have the same basename, this is a normal node.
    } # else, status is not dead, this is a normal node.
    return 1; # At least, one of 1:dead, 2:uniq basename, 3:doesn't resolv
              # condition is not met => Assume node index 0 is a normal node.
              # We are in a 0-indexing situation.
}

################################################################################
#
# check_options_or_die: Check for unwanted options. If some are found: abort.
#
################################################################################

sub check_options_or_die($@) {
    my $command = shift;
    my @options = @_;
    my @bad_options = ();
    my $error_message = "ERROR, command [$command] doesn't understand options [ ";
    for my $option (@options) {
        given($option) {
            when('default') {
                push (@bad_options,$option) if (defined($default));
            }
            when('dry-run') {
                push (@bad_options,$option) if (defined($dryrun));
            }
            when('refreshstate') {
                push (@bad_options,$option) if (defined($refreshstatuses));
            }
            when('sortnodes') {
                push (@bad_options,$option) if (defined($sortnodes));
            }
            when('cluster') {
                push (@bad_options,$option) if (defined($target_cluster));
            }
            when('nodes') {
                push (@bad_options,$option) if (scalar(@target_nodes) > 0);
            }
            when('noresolv') {
                push (@bad_options,$option) if (defined($noresolv));
            }
            when('service') {
                push (@bad_options,$option) if (defined($target_service));
            }
            when('zero') {
                push (@bad_options,$option) if (defined($zero));
            }
            default {
                die "API Error: [--$option] not handeled by check_options_or_die()\n";
            }
        }
    }
    die $error_message.join(", ",map { "--".$_ } @bad_options)." ]. Aborting.\n" if(scalar(@bad_options)>0);
}

################################################################################
#
# returns an array of known clusters. takes the table of hash returned by parse_c3_conf.
#
################################################################################

sub get_cluster_names() {
    my @cluster_names = ();
    for my $element (@clusters) {
        if (ref($element) eq 'HASH') {
            push(@cluster_names, $element->{'name'});
        }
    }
    return(@cluster_names);
}

################################################################################
#
# expand ("node","range[00-02") to
# ("node", "range0","range1","range2")
# Supports padding with "0".
#
################################################################################

sub expand_nodes(@) {
    my @unexpanded_nodes = @_;
    my @expanded_nodes = ();
    for my $node (@unexpanded_nodes) {
        chomp($node);
        if ( $node =~ /^([a-zA-Z0-9.-]+)(\[(\d+)-(\d+)\])$/) { # match node range
            # node name: $1, complete range:$2, range start:$3, range end:$4
            my ($name, $start, $stop) = ($1, $3, $4);
            my $pad_size = length $start;
            die "ERROR: Inconsistent padding in node range [$start-$stop]!\n" if ( ($start =~ /^0[0-9]*$/) && ( $pad_size != length $stop));
            for (my $i=$start; $i <= $stop; $i++) {
                push (@expanded_nodes, lc($name.sprintf("%0*d",$pad_size,$i))); # lowercase the node at the same time
            }
        } else { # simple node
            push (@expanded_nodes, lc($node));
        }
    }
    return(@expanded_nodes);
}

################################################################################
#
# Add a node to a given cluster.
#
#
################################################################################

sub add_node($$;$$) {
    my ($cluster, $name, $status, $comment) = @_;
    $name = lc $name;
    die "ERROR: Invalid node name: [$name]\n" if ($name !~ /^[a-z]+[a-z0-9_.-]*$/); # Check for valid hostname (includes '_' for dummy entry compat)
    for my $element (@clusters) {
        if ((ref($element) eq 'HASH') && ($element->{'name'} =~ /$cluster/i)) {
            if ( ! defined ($element->{'nodes'}) ) { # No nodes yet, need to initialise entry.
                my @nodes = ();
                $element->{'nodes'} = \@nodes;
            }
            my @nodenames = map { $_->{'name'} } @{$element->{'nodes'}};
            if($name ~~ @nodenames) { # Node already exists in this cluster.
                for my $node (@{$element->{'nodes'}}) { # Find the node
                    if($node->{'name'} =~ /$name/i) {
                        set_node_alive(\$node) if (! defined($refreshstatuses)); # enable it (except if --refreshstate
                                                                              # is used as the status has already been
                                                                              #  updated when parsing c3.conf)
                        last;
                    }
                }
            } else { # This s a new node. Adding it.
                my $new_node;
                $new_node->{'name'} = $name;
                $new_node->{'status'} = "online";
                $new_node->{'status'} = $status if (defined($status));
                $new_node->{'comment'} = $comment if (defined($comment));
                refresh_node_status_if_needed(\$new_node, $element->{'name'}); # if --refreshstate is used, update status.
                push(@{$element->{'nodes'}}, $new_node);
            }
            return 0; # Node added, no need to continue with remaining clusters.
        }
    }
    return 1; # We didn't found the cluster... strange.
}

################################################################################
#
# set_node_alive, set_node_dead, set_node_ping => Set the node ref status
# respectively to: online, dead, ping result.
#
################################################################################

sub set_node_alive($) {
    my $node_ref = shift;
    $$node_ref->{'status'} = "online";
}

sub set_node_dead($) {
    my $node_ref = shift;
    $$node_ref->{'status'} = "dead";
}

sub set_node_ping($) {
    my $node_ref = shift;
    my $node_name = $$node_ref->{'name'};

    $$node_ref->{'status'} = check_remote_service($node_name,get_c3_remote_service())?"online":"dead";

#    $$node_ref->{'status'} = "dead"; # By default node is dead.
#    $$node_ref->{'status'} = "online" if(check_remote_service($node_name,get_c3_remote_service()));
}

################################################################################
#
# get_c3_remote_service():
#      return the service name (as in /etc/services) to use to check remote nodes.
#
#      - if --service is used, use that value (overrides any other prefs)
#      - if $ENV{C3_RSH} is set, use that to determine the service name.
#        only support ssh (ssh) and rsh (shell).
#      - defaults to ssh.
#
################################################################################

sub get_c3_remote_service() {
    # Services hash: 'command' => service name from /etc/services
    my %services = (
        'ssh' => 'ssh',
        'rsh' => 'shell'
    );
    return $target_service if (defined($target_service));
    my $service = $services{$ENV{C3_RSH}} if (defined($ENV{C3_RSH}));
    if(! defined($service)) {
        warn "WARNING: C3_RSH=".$ENV{C3_RSH}." is not supported. using ssh as default.\n" if (defined($ENV{C3_RSH}));
        $service = 'ssh';
    }
    return $service;
}
################################################################################
#
# check_remote_service: check if remote service is listening for connections.
#    $hostname: the remote host
#    $service: the name of the service as in /etc/services (e.g.: ssh, shell)
#
#    return: 1 upon succes, 0 otherwise.
#
################################################################################

sub check_remote_service($$) {
    my $hostname = shift;
    my $service_name = shift;
    my $port;

    # Special case: if service is "none", always true.
    return 1 if($service_name =~ /^none$/i);

    # Special case: if service is "resolv", just check that hostname resolvs
    return (defined(gethostbyname($hostname))?1:0) if ($service_name =~ /^resolv$/i);

    # Special case: if service is ping (not a real service) do specific test
    return (system("ping -c1 -q -W1 $hostname >/dev/null 2>&1")?0:1) if($service_name eq 'ping');

    # Get the service port: (service name, service aliases, service port, protocol)
    if($service_name =~ /^[0-9]+$/) {
        $port = $service_name;
    } else {
        my @service = getservbyname($service_name, 'tcp');
        return 0 if(!@service);
        $port = $service[2];
    }

    my $socket = IO::Socket::INET->new(PeerHost => "$hostname",
                                       PeerPort => "$port",
                                       Proto => 'tcp',
                                       Timeout => '1');
    if(defined $socket) { # port is open
        shutdown($socket,2);
        close $socket;
        return 1;
    } else {
        return 0;
    }
}

################################################################################
#
# set_nodes_status. given a function pointer to set the status.
#
################################################################################

sub set_nodes_status($) {
    my $sub_set_node_status = shift;
    die "ERROR: Cannot restict to a node subset if cluster is not specified" if ((scalar(@target_nodes) > 0) && (! defined($target_cluster)));
    for my $element (@clusters) { # Loop on @clusters
        next if(ref($element) ne 'HASH'); # Ignore comments and empty lines.
        next if(defined($target_cluster) && ($element->{'name'} !~ /$target_cluster/i)); # Ignore wrong clusters if --cluster was specified.
        if ((defined ($element->{'nodes'})) && (scalar($element->{'nodes'}) > 0) ) { # If this cluster has some nodes (at least one).
            my $start = 0;

            if(! using_zero_indexing(@{$element->{'nodes'}})) {
                $start = 1; # Start at index 1.
            }

            my @rejected_nodes = (); # nodes from @target_nodes that are not found in cluster.

            if (scalar(@target_nodes) > 0) { # If some target nodes have been specified
                my @nodenames = map { $_->{'name'} } @{$element->{'nodes'}}; # Get all the nodenames. (FIXME: need to sort it)
                TARGET_NODE: for my $target_node (@target_nodes) {
                    for (my $i=$start; $i < scalar(@{$element->{'nodes'}}); $i++) { # Scan the cluster nodes
                        if (@{$element->{'nodes'}}[$i]->{'name'} eq $target_node) { # Node found
                            $sub_set_node_status->(\@{$element->{'nodes'}}[$i]); # Update status
                            next TARGET_NODE; # go to next target_node, avoiding to push this target_node in rejected.
                        }
                    }
                    push(@rejected_nodes, $target_node); # Node not found after scanning cluster.
                }
            } else { # No node filter. Update all nodes.
                for (my $i=$start; $i < scalar(@{$element->{'nodes'}}); $i++) { # Scan the cluster nodes
                    $sub_set_node_status->(\@{$element->{'nodes'}}[$i]);
                }
            }
            die "ERROR: The following nodes are not part of cluster [$element->{'name'}]:\n".join(" ", @rejected_nodes)."\n" if(scalar(@rejected_nodes) > 0);
        }
    }
}

################################################################################
#
# get_cluster: Return a reference to cluster given its name (or undef)
#
################################################################################

sub get_cluster($) {
    my $cluster_name = shift;
    for my $element (@clusters) {
        if ((ref($element) eq 'HASH') && ($element->{'name'} =~ /$cluster_name/i)) { # Found (cluster names are case insensitive)
            return \$element;
        }
    }
    return undef; # Cluster not found.
}

################################################################################
#
# check_host_resolvs_or_die: Checks that a given hostnames resolvs (we can get its ip address)
#
################################################################################

sub check_host_resolvs_or_die($) {
    my $name = shift;
    if(! ($noresolv || defined(gethostbyname($name)))) {
        die "ERROR: unknown host: [$name]\n";
    }
}

################################################################################
# 
# nodes_in_cluster_or_die: Check that @target_nodes are part of $target_cluster.
#
################################################################################
sub nodes_in_cluster_or_die() {
    my $cluster_ref = get_cluster($target_cluster);
    my @cluster_node_names = map { $_->{'name'} } @{$$cluster_ref->{'nodes'}};
    my @unknown_nodes = ();
    for my $node (@target_nodes) {
        if (!($node ~~ @cluster_node_names)) { # Node unknown.
            push(@unknown_nodes, $node);
        }
    }
    die "ERROR: Nodes [ ".join(" ",@unknown_nodes)." ] do not belong to cluster [$target_cluster]\n" if(scalar(@unknown_nodes) > 0);
}

################################################################################
#
# MAIN
#
################################################################################

# Prepare target_nodes table.
@target_nodes = expand_nodes(@target_nodes);

# Read the config file.
@clusters = parse_c3_conf();

# Check what must be done.
given ($command) {
    when ('addcluster') {
        # print "addcluster";
        # check_options_or_die => We acept all options
        die "ERROR: Invalid cluster name [$target_cluster]" if ($target_cluster !~ /\w+/);
        die "ERROR: Cluster [$target_cluster] already exists!" if(get_cluster($target_cluster));
        push (@clusters, ""); # Add an empty line before the new cluster.
        my $new_cluster;
        die "ERROR: cluster not specified" if (! defined($target_cluster));
        $new_cluster->{'name'} = $target_cluster;
        $new_cluster->{'start_comment'} = "# Created on: ".localtime();
        die "ERROR: You need at least a head node" if ( scalar(@target_nodes) < 1 );
        if(@target_nodes[0] =~ /^:/) { # vcluster !!!
            warn "WARNING: Ignoring zero/nozero option. This has no meaning for a virtual cluster" if (defined($zero));
            die "ERROR: vclusters don't have nodes. Did you prepend 1st node with a colon inadvertently?" if (scalar(@target_nodes) > 1);
            my $new_vcluster;
            $new_vcluster->{'name'} = shift(@target_nodes);
            $new_vcluster->{'name'} =~ s/^://;
            die "ERROR: invalide remote cluster name: [$new_vcluster->{'name'}]" if ($new_vcluster->{'name'} !~ /^[a-z0-9.-]+$/i);
            check_host_resolvs_or_die($new_vcluster->{'name'});
            $new_cluster->{'vcluster'} = $new_vcluster;
            if ($default) {
                $default_cluster = $target_cluster; # new default cluster.
                unshift(@clusters, $new_cluster);
            } else {
                push (@clusters, $new_cluster); # Add the new cluster entry.
            }
        } else {
            my $new_head;
            my $raw_head = shift(@target_nodes);
            if($raw_head =~ /^([a-z0-9.-]+):([a-z0-9.-]+)$/i) { # public:private head
                $new_head->{'name'} = $1;
                check_host_resolvs_or_die($new_head->{'name'});
                $new_head->{'private'} = $2;
                check_host_resolvs_or_die($new_head->{'private'});
            } elsif($raw_head =~ /^([a-z0-9.-]+)$/i) {
                $new_head->{'name'} = $1;
                check_host_resolvs_or_die($new_head->{'name'});
            } else {
                die "ERROR: invalide head name: [$new_head->{'name'}]\n";
            }
            $new_cluster->{'head'} = $new_head;

            if ($default) {
                $default_cluster = $target_cluster; # new default cluster.
                unshift(@clusters, "") if(scalar(@clusters)>0); # Add blank line after default cluster.
                unshift(@clusters, $new_cluster);
            } else {
                push (@clusters, $new_cluster); # Add the new cluster entry.(add_node needs that)
            }

            # If we do not use zero indexing. need to insert a dummy entry.
            if (! $zero) {
                add_node($target_cluster, "remove_for_0-indexing", "dead", "# remove this line for 0-indexing");
            }
            # Add the nodes.
            for my $node (@target_nodes) {
                check_host_resolvs_or_die($node);
                add_node($target_cluster,$node);
            }
        }
        write_c3_conf(@clusters);
    }
    when ('delcluster') {
        # print "delcluster";
        check_options_or_die('delcluster','default', 'refreshstate', 'sortnodes', 'nodes', 'noresolv', 'service', 'zero');
        die "ERROR: cluster not specified" if (! defined($target_cluster));
        die "ERROR: unknown cluster" if ( $target_cluster ~~ get_cluster_names() );
        for (my $i; $i < scalar(@clusters); $i++) {
            if ((ref($clusters[$i]) eq 'HASH') && ($clusters[$i]->{'name'} =~ /$target_cluster/i)) { # Found
                splice(@clusters,$i,1); # Kill it.
            }
        }
        write_c3_conf(@clusters);
    }
    when ('addnodes') {
        # print "addnodes";
        check_options_or_die('addnodes', 'zero');
        # 1st, check that we know the target cluster and that it exists.
        die "ERROR: cluster not specified" if (! defined($target_cluster));
        die "ERROR: Unknown cluster: $target_cluster" if (! defined(get_cluster($target_cluster)));
        die "ERROR: You need at least a node" if ( scalar(@target_nodes) < 1 );
        for my $node (@target_nodes) {
            check_host_resolvs_or_die($node);
            add_node($target_cluster,$node);
        }
        write_c3_conf(@clusters);
    }
    when ('delnodes') {
        # print "delnodes";
        check_options_or_die('delnodes', 'zero', 'noresolv', 'service');
        # 1st, check that we know the target cluster and that it exists.
        die "ERROR: cluster not specified" if (! defined($target_cluster));
        die "ERROR: You need at least a node" if ( scalar(@target_nodes) < 1 );
        my $cluster_ref = get_cluster($target_cluster);
        die "ERROR: Unknown cluster: $target_cluster" if (! defined($cluster_ref));
        die "ERROR: This cluster has no nodes to delete" if (! defined ($$cluster_ref->{'nodes'})); # A vcluster.
        my $cluster_nodes = $$cluster_ref->{'nodes'};
        NODE: for my $node (@target_nodes) { # For each nodes specified on the cmd line
            for (my $i=0; $i < scalar(@{$cluster_nodes}); $i++) { # Scan the cluster nodes
                if($node =~ /@{$cluster_nodes}[$i]->{'name'}/i) { # Found a node to remove
                    splice(@{$cluster_nodes},$i,1); # Remove the node.
                    next NODE; # stop scanning cluster here, job done, move to next node
                }
            }
            die "ERROR: node '$node' not found in '$target_cluster', aborting.";
        }
        write_c3_conf(@clusters);
    }
    when ('disablenodes') {
        # print "disablenodes";
        check_options_or_die('disablenodes', 'zero', 'noresolv', 'service');
        die "ERROR: --nodes used without --cluster" if (scalar(@target_nodes)> 0 && !defined($target_cluster));
        die "ERROR: unknown cluster [$target_cluster]" if (defined($target_cluster) && !defined(get_cluster($target_cluster)));
        set_nodes_status(\&set_node_dead);
        write_c3_conf(@clusters);
    }
    when ('enablenodes') {
        # print "enablenodes";
        check_options_or_die('enablenodes', 'zero');
        die "ERROR: --nodes used without --cluster" if (scalar(@target_nodes)> 0 && !defined($target_cluster));
        die "ERROR: unknown cluster [$target_cluster]" if (defined($target_cluster) && !defined(get_cluster($target_cluster)));
        set_nodes_status(\&set_node_alive);
        write_c3_conf(@clusters);
    }
    when ('update') {
        # print "update";
        # check_options_or_die('update', ); # => Accept all options.
        #set_nodes_status(\&set_node_ping);
        # => Do nothing! all relevant options are used by c3.conf parser and writer.
        die "ERROR: --nodes used without --cluster" if (scalar(@target_nodes)> 0 && !defined($target_cluster));
        die "ERROR: unknown cluster [$target_cluster]" if (defined($target_cluster) && !defined(get_cluster($target_cluster)));
        nodes_in_cluster_or_die() if (scalar(@target_nodes)> 0);
        write_c3_conf(@clusters);
    }
    when ('check') {
       # print "check"
       # At this point, the config file was parsed succesfully, just need a little more checking.
       my $rc = 0;
       # Forbid the following unwanted/unhandled options
       check_options_or_die('check', 'default', 'dry-run', 'refreshstate', 'sortnodes', 'cluster', 'nodes', 'zero');
       for my $cluster (get_cluster_names()) {
           # Check nodes.
           my @seen_nodes = ();
           my $cluster_ref = get_cluster($cluster);
           my $cluster_nodes = $$cluster_ref->{'nodes'};
           if (! using_zero_indexing(@{$cluster_nodes})) {
               shift(@{$cluster_nodes}); # remove 1st dummy entry
           }
           for my $node (@{$cluster_nodes}) {
               lc($node->{'name'});
               # Check for duplicate node.
               if ($node->{'name'} ~~ @seen_nodes) { # Duplicate node?
                   print "ERROR: Duplicate node: [$node->{'name'}] in cluster [$cluster]\n";
                   $rc++;
               } else {
                   push (@seen_nodes, $node->{'name'});
               }
               # Check for hosname resolution failure.
               if(! ($noresolv || defined(gethostbyname($node->{'name'})))) {
                   print "ERROR: Unknown hostname: [$node->{'name'}] in cluster [$cluster]\n";
                   $rc++;
                   next; # If error, no need to test ping (unknown host won't ping).
               }
               # Check if alive node has remote service up (default ssh) or ping.
               if(($node->{'status'} eq "online") && (!check_remote_service($node->{'name'},get_c3_remote_service()))) {
                   my $service = defined($target_service)?$target_service:"ssh";
                   $service = "port $service" if ($service =~ /^[0-9]+$/);
                   print "ERROR: [$service] test on node [$node->{'name'}] in cluster [$cluster] failed, but node is 'alive' in c3 config\n";
                   $rc++;
               }
           }
           # Check head or vcluster (we are sure that at leas one exists otherwize the parser would have failed)
           my @heads = ();
           push (@heads, {'head' => $$cluster_ref->{'head'}->{'name'}}) if(exists($$cluster_ref->{'head'}->{'name'}));
           push (@heads, {'private head' => $$cluster_ref->{'head'}->{'private'}}) if(exists($$cluster_ref->{'head'}->{'private'}));
           push (@heads, {'virtual cluster head' => $$cluster_ref->{'vcluster'}->{'name'}}) if(exists($$cluster_ref->{'vcluster'}->{'name'}));
           for my $h (@heads) {
                my @head_type = keys(%{$h});
                my @head_hostname = values(%{$h});
                if($head_hostname[0] ~~ @seen_nodes) { # Head exists in nodes???
                    print "ERROR: $head_type[0]: [$head_hostname[0]] found in nodes for cluster [$cluster]\n";
                    $rc++;
                }
                if(! ($noresolv || defined(gethostbyname($head_hostname[0])))) {
                    print "ERROR: $head_type[0]: unknown hostname: [$head_hostname[0]] in cluster [$cluster]\n";
                    $rc++;
                    next; # If error, no need to test ping.
                }
                if(system("ping -c1 $head_hostname[0] >/dev/null 2>&1")) {
                    print "ERROR: $head_type[0]: [$head_hostname[0]] in cluster [$cluster] is down\n";
                    $rc++;
                }
           }
       }
       die "$rc errors found in $c3conf\n" if($rc);
       print "$c3conf checks successfull.\n";
    }
    when ('listnodes') {
        # print "listnodes";
        check_options_or_die('listnodes', 'default', 'dry-run', 'refreshstate', 'nodes', 'noresolv', 'service', 'zero');
        $target_cluster = $default_cluster if (! defined($target_cluster) && defined($default_cluster));
        die "ERROR: cluster not specified (and no default cluster)" if (! defined($target_cluster));
        die "ERROR: unknown cluster" if ( $target_cluster ~~ get_cluster_names() );
        my $cluster_ref = get_cluster($target_cluster);
        die "ERROR: Unknown cluster: $target_cluster" if (! defined($cluster_ref));
        my $cluster_nodes = $$cluster_ref->{'nodes'};
        my @node_list = ();
        for (my $i=0; $i < scalar(@{$cluster_nodes}); $i++) { # Scan the cluster nodes
            push(@node_list, @{$cluster_nodes}[$i]->{'name'}) if (@{$cluster_nodes}[$i]->{'status'} eq "online");
        }
        if (defined($sortnodes)) {
            # Sorting steps:
            # 1st: map {[$_,$_=~/^([a-zA-Z_.]+)([0-9]+)$/] } : create [$_, node basename, node number if any]
            # 2nd: sort {$a->[1] cmp $b->[1] || $a->[2] <=> $b->[2] }  : compare nodes basenames. If equals, compare nodes numbers.
            # 3rd: map  { $_->[0] } : get original element back.(drop basename and number we used to make the sort).
            @node_list = map  { $_->[0] }
                           sort {$a->[1] cmp $b->[1] || $a->[2] <=> $b->[2] }
                           map  {[$_,$_ =~ /^([a-z0-9.-]*[a-z.-]+)([0-9]*)$/] }
                           @node_list;
        }
        print join(" ", @node_list)."\n";
    }
    when ('listclusters') {
        check_options_or_die('listclusters', 'cluster', 'default', 'dry-run', 'refreshstate', 'nodes', 'sortnodes', 'noresolv', 'service', 'zero');
        my @clusters_list = ();
        for my $element (@clusters) {
            if (ref($element) eq 'HASH') { # Found
                push(@clusters_list, $element->{'name'});
            }
        }
        print join(" ", @clusters_list)."\n";
    }
    default {
        die "ERROR: unknown command '$command'.";
    }
}

#write_c3_conf(@clusters);
exit 0;

__END__

=head1 NAME

cconfig, a command line tool for managing c3 configuration file.

=head1 SYNOPSIS

cconfig COMMAND OPTIONS

=head1 DESCRIPTION

cconfig is a command line tool for managing c3 configuration file from
adding nodes or cluster to node status update or syntax optimisation. 

=head1 SYNTAX

cconfig command [options]

=head1 COMMANDS

Available commands are:

=over 8

=item addcluster

Adds a cluster to the c3 configuration file in last position by default.
Must be used with the --cluster and --nodes options.

Ranges in the form basename[#min-#max] are accepted.
padding is supported. For a padding of 3 digit for a 500 nodes
cluster, you need to use: node[000-499]

example: cconfig addcluster --cluster my_cluster --nodes nodes0[0-9] nodes[10-49]

=item delcluster

Removes a cluster from the c3 configuration file.
Must be used with the --cluster option.

example: cconfig delcluster --cluster my_cluster

=item addnodes

Add node(s) to a cluster.
If a node was marked dead, the node is marked back to alive.
Requires the --cluster and --nodes options.

example: cconfig addnodes --cluster my_cluster --nodes foo bar rack1-[1-22] rack2-[1-22]

=item delnodes

Remove node(s) from a cluster
Requires the --cluster and --nodes option.

example: cconfig delnodes --cluster my_cluster --nodes foo bar

=item disablenodes

Mark nodes as dead (or excluded if part of a range)
--cluster is optional
--nodes <nodenames> is optional (requires --cluster if used).

example:
    cconfig disablenodes --cluster my_cluster --nodes rack1-[1-22]

=item enablenodes

Mark nodes back to life.
--cluster is optional (usefull to re-enable all nodes for all clusters)
--nodes <nodenames> is optional (requires --cluster if used).

example:
    cconfig enablenodes --cluster my_cluster --nodes rack1-[1-22]

=item update

Update config file (usefull to sort nodes or update status)
--cluster is optional
--nodes <nodenames> is optional (requires --cluster if used).)

example: Sorting all nodes in clusters definitions:
    cconfig update --sortnodes

=item listnodes

Lists active nodes in cluster
If no --cluster option is used, then it lists the default cluster nodes (1st one).

example:
    cconfig listnodes --cluster my_cluster

=item listclusters

Lists defined clusters

example:
    cconfig listclusters

=item check

Check validity of the c3 configuration file.
The following checks are done:
- c3.conf syntax
- Duplicate nodes within a cluster
- names that do not resolv (unknown hosts)
  (can be ignored using the --noresolv)
- alive nodes that do not respond to ssh or specific service.

=item --version

Print version information

=item --help|h|?

Print usage Information (this)

=back

=head1 OPTIONS

Recognized options are:

=over 8

=item --cluster|-c <clustername>

Specify the cluster name to work with.

=item --default|-d

Set this cluster as default cluster. (Move it to the top of c3.conf).
Only available for update or addcluster.

=item --dry-run|-u

Output restult to stdout instead of updating config file.

=item --file|-f <file>

Use alternative config file.


=item --refreshstate|-r

Update each nodes status (dead or alive) using ping -c1.

=item --sortnodes|-s

Sort the nodes in cluster definitions.
(Can be used with --cluster option to restrict the sort to that cluster)

=item --nodes|-n

List of nodes to works with (space separated)

Ranges in the form basename[#min-#max] are accepted.
padding is supported. For a padding of 3 digit for a 500 nodes
cluster, you need to use: node[000-499]

=item --noresolv|-l

Doesn't try to resolve hostnames.

This permits to add nodes/heads/vclusters that are not yet defined
in any host database or DNS.

=item --service

Name of service to use to test that a remote node is alive or not.
The service name can be any tcp service in /etc/services or a port number.
Special values:

=over 4

=item * ping: Check if remote host responf to ping

=item * resolv:	Check if remote host resolvs using gethostbyname

=item * none: Check on remote host is always true. used to check only syntax of config file.

=back

=item --zero|z|0

Force 0-indexing (do not insert dummy dead entry)
Can be used with update and addcluster commands.
(can be used with --cluster option to restrict the change to that cluster.
without specifying any cluster, the change affects all clusters.

=item --nozero|noz|no0

Use dummy dead entry for node index 0 so indexing starts at 1.

=back

=head1 TODO

=over 8

=item Nothing so far.

=back

=head1 AUTHOR

Olivier LAHAYE <olivier.lahaye@cea.fr>

=head1 SEE ALSO

L<c3.conf(5)> L<c3(1)> L<perl(1)>

=cut

