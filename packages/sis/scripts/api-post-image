#!/usr/bin/env /usr/bin/perl
#########################################################################
#  Script Name : post_rpm_nochroot
#  Written by  : Erich Focht
#  Date        : July 2006
#  Purpose     : This post_install script configures sis for the
#                a particular image. It prepares configurator html
#                files offering the selection of the default boot kernel
#                and global append options for the 
#  Copyright (c) Erich Focht 2006
#                All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#########################################################################
# $Id: post_rpm_nochroot 5531 2006-11-10 16:44:31Z efocht $
#########################################################################

use strict;
use lib "$ENV{OSCAR_HOME}/lib";
use Carp;
use POSIX;
use Tk;
use OSCAR::Configbox;
use OSCAR::Database;
use lib '/usr/lib/systeminstaller';
use SIS::DB;
use SIS::Image;
use SystemInstaller::Image;
use File::Basename;
use Getopt::Long;

my $base;
if (defined $ENV{OSCAR_HOME}) {
    $base = "$ENV{OSCAR_HOME}/packages/sis";
} else {
    $base = "/var/lib/oscar/packages/sis";
}

my $configdir = $base."/.configs";

my ($force, $update, $verbose);
GetOptions(
           "force|f"   => \$force,
	   "update|u"  => \$update,
	   "verbose|v" => \$verbose,
           );

my $imagedir = shift @ARGV;
if (!$imagedir) {
    print "\nUsage: $0 [--force|-f] [--update|-u] [-v] path_to_image\n\n";
    print "\t--update : change IMGDIR/etc/systemconfig/systemconfig.conf,\n";
    print "\t           push changed config to corresponding nodes\n";
    print "\t           and run systemconfigurator to activate config.\n";
    print "\t--force  : force opening the per image selector menu.\n";
    exit 1;
}
$imagedir =~ s/\/$//;
my $image = $imagedir;
$image =~ s:^.*/::g;

$force = 1 if ($update);

my $window;

#####################
# BEGIN MAIN SCRIPT #
#####################
my $i = list_image(name=>$image);
if (!$i) {
    carp "ERROR: Could not find image $image!";
    exit 1;
}

my $imageconf = $configdir."/".$image;
my $scconf = "$imagedir/etc/systemconfig/systemconfig.conf";
my $masterconf = $base."/configurator.html";

my $master_conf;
if (-e $masterconf) {
    $master_conf = readInConfigValues($masterconf, "sis", "", noarray=>1);
    if (!defined $master_conf || ref($master_conf) ne "HASH") {
        die "ERROR: Impossible to get the configuration of the headnode";
    }
    # exit if no per-image config
    if ($master_conf->{sis_per_image} ne "YES") {
	# if in forced mode: re-generate scconf file
	if ($force) {
	    &mk_new_scconf($imagedir);
	}
	# set global APPEND config value, if any
	if ($master_conf->{kernel_append}) {
	    &set_scconf($scconf, "APPEND", $master_conf->{kernel_append}); 
	}
	goto DO_UPDATE;
    }
} else {
    # no per-image config!
    print "File $masterconf not found! ???\n";
    exit 0;
}

if (! -d $configdir) {
    !system("mkdir ".$configdir) || do {
	print "Could not create directory $configdir\n";
	exit 1;
    };
}

print "configuring sis for image=$image\n";

if (! -d $imageconf) {
    !system("mkdir $imageconf") || do {
	print "Could not create directory $imageconf\n";
	exit 1;
    };
} else {
    print "Found $imageconf\n";
}
if ($force && -e "$imageconf/configurator.html") {
    &mk_new_scconf($imagedir);
    unlink "$imageconf/configurator.html";
}

if (! -e "$imageconf/configurator.html") {
    &write_img_cfg($imagedir, "$imageconf/configurator.html");
}

# configure this only if no config values found in database
my @res = get_pkgconfig_vars(opkg => "sis", context => "image:$image");
if (!@res || $force) {
    OSCAR::Configbox::configurePackage(0, $imageconf,"sis","image:$image");
    MainLoop();
}

#
# do the SIS configuration according to the values in database
#

my $iconf = readInConfigValues("$imageconf/configurator.html","sis"
			       ,"image:$image",noarray=>1);

if ($iconf->{kernel_append}) {
    &set_scconf($scconf, "APPEND", $iconf->{kernel_append});
}
if ($iconf->{default_boot}) {
    &set_scconf($scconf, "DEFAULTBOOT", $iconf->{default_boot});
}

 DO_UPDATE:
    if ($update) {
	&update_cluster($image);
    }

exit 0;

###################################################################

sub set_scconf {
    my ($scconf, $var, $value) = @_;
    my $cmd = "scconf_tool --block BOOT --set --var $var".
	" --val \"$value\" $scconf";
    open CMD, "$cmd | " or croak "Could not run: $cmd";
    my @out = <CMD>;
    close CMD;
    open OUT, "> $scconf" or croak "Could not open: $scconf";
    print OUT @out;
    close OUT;
}

sub get_scconf {
    my ($scconf, $var) = @_;
    my $res;
    my $cmd = "scconf_tool --block BOOT --var $var $scconf";
    open CMD, "$cmd | " or croak "Could not run: $cmd";
    while (<CMD>) {
	chomp;
	if (/\s*($var)\s*=\s*(.*)\s*$/) {
	    $res = $2;
	}
    }
    close CMD;
    return $res;
}

sub write_img_cfg {
    my ($imagedir, $cfgfile) = @_;
    my ($defaultboot, %kernels) = &get_img_kernels($imagedir);
    my $image = basename($imagedir);
    
    local *OUT;
    open OUT, "> $cfgfile" or croak "Could not open $cfgfile : $!";
    print OUT "<html>\n";
    print OUT "<head><title>SIS Configuration</title>\n";
    print OUT "</head>\n";
    print OUT "<body>\n";
    print OUT "<h1>Configuring SIS for image $image</h1>\n";
    print OUT "<br>\n";
    print OUT "<form>\n";
    print OUT "<p>Additional kernel boot options\n";
    print OUT " <input name=\"kernel_append\" value=\"\">\n";
    print OUT "</p>\n";
    print OUT "<br>\n";
    print OUT "<b>Choose the default boot kernel for this image</b><br>\n";
    for my $k (keys(%kernels)) {
	my $kfile = $kernels{$k};
	my $checked = ($k eq $defaultboot);
	print OUT "<input type=radio ";
	print OUT "checked " if $checked;
	print OUT "name=default_boot value=\"$k\">$kfile ($k)<br>\n";
    }
    print OUT "<br><br><p>Systemconfigurator will create an initrd ";
    print OUT "if necessary.<br><br>\n";
    print OUT "<input type=reset value=\"Reset Form\">\n";
    print HTML "</form>\n";
    print HTML "</body></html>\n";
}

sub get_img_kernels {
    my ($imgdir) = @_;
    my ($defaultboot, %kernels);
    my $cmd = "scconf_kernel -i $imgdir";
    local *CMD;
    open CMD, "$cmd |" or croak "Could not run: $cmd : $!";
    while (<CMD>) {
	next if (/^Label/);
	chomp;
	if (/DEFAULTBOOT : (\S+)$/) {
	    $defaultboot = $1;
	} elsif (/^(\S+)\s+(\S+)$/) {
	    $kernels{$1} = $2;
	}
    }
    close CMD;
    return ($defaultboot, %kernels);
}

# Generate a new /etc/systemconfig/systemconfig.conf file for a given image.
#
# Return: 0 if success, -1 else.
sub mk_new_scconf {
    my ($imgdir) = @_;
    my ($root, $boot);
    my $scconf = $imgdir."/etc/systemconfig/systemconfig.conf";

    $root = &get_scconf($scconf, "ROOTDEV");
    if (!defined $root) {
        carp "ERROR: Impossible to get the root for the generation of the new".
             "systemconfig.conf file";
        return -1;
    }

    $boot = &get_scconf($scconf, "BOOTDEV");
    if (!defined $boot) {
        carp "ERROR: Impossible to get the boot for the generation of the new".
             "systemconfig.conf file";
        return -1;
    }

    if (SystemInstaller::Image::write_scconf($imgdir, $root, $boot) == 0) {
        carp "ERROR: Impossible to generate the systemconfig.conf file";
        return -1;
    }

    return 0;
}

#
# run scpush and scexec to update all nodes with new boot configuration
#
sub update_cluster {
    my ($image) = @_;
    my $v;
    $v = "--verbose" if ($verbose);
    my $scconf = $imagedir . "/etc/systemconfig/systemconfig.conf";
    print "Pushing $scconf to corresponding hosts.\n";
    system("scpush --image $image $v $scconf /etc/systemconfig/");
    print "Running systemconfigurator to enable new config.\n";
    system("scexec --image $image -- systemconfigurator $v --runboot");
}
