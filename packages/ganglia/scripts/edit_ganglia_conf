#!/usr/bin/perl
#

# $Id$
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This script reads the Configurator result and sets up the configuration
# files /etc/gmond.conf and /etc/gmetad.conf for the server. Similar
# configuration steps are done for each image.
#
# Copyright 2005 Erich Focht <efocht@hpce.nec.com>
# Copyright 2008-2009   Oak Ridge National Laboratory
#                       Geoffroy Vallee <valleegr@ornl.gov>
#                       All rights reserved.
#

BEGIN {
    if (defined $ENV{OSCAR_HOME}) {
        unshift @INC, "$ENV{OSCAR_HOME}/lib";
    }
}

use Carp;
use strict;
use Getopt::Long;
use lib "/usr/lib/systeminstaller";
use SIS::NewDB;
use SIS::Image;
use SIS::Client;
use OSCAR::Configurator_backend;
use OSCAR::Database;
use OSCAR::Opkg;
use OSCAR::OCA::OS_Detect;
use OSCAR::Package;
use OSCAR::Utils;
use Data::Dumper;

my ($do_gmond, $do_gmetad, $image, @options, $test, $verbose);
Getopt::Long::Configure("pass_through");
GetOptions( 
            'gmond'     => \$do_gmond,
            'gmetad'    => \$do_gmetad,
            'help'      => \&help_and_exit,
            'image=s'   => \$image,
            'option=s'  => \@options,
#            'test'      => \$test,
            'verbose'   => \$verbose, 
          ) || help_and_die();

my $gmetad_conf = "/etc/gmetad.conf";
my $gmond_conf = "/etc/gmond.conf";
# GV: this cannot work currently so we deactivate.
#if ($test) {
#    $gmetad_conf = "gmetad.conf";
#    $gmond_conf = "gmond.conf";
#    $ENV{OSCAR_PACKAGE_HOME} = ".";
#}
my $pkgdir = OSCAR::Package::get_scripts_dir("ganglia", "");
if (!-d $pkgdir) {
    die "ERROR: the package directory for Ganglia does not exist ($pkgdir)";
}
my $masterconf = "$pkgdir/configurator.html";
my $imgconfd = "$pkgdir/.configs";

my $hostname = `hostname`;
chomp($hostname);

if (! -f $masterconf) {
    die "ERROR: Ganglia configuration.html file does not exist ($masterconf)";
}
if (!is_a_valid_string ($hostname)) {
    die "ERROR: Invalid hostname";
}

# find image path
my $imgpath;
if ($image) {
    my @imgs = list_image(name => $image);
    if (!scalar(@imgs)) {
        die ("ERROR: Could not find image $image in the database!\n");
    }
    $imgpath = $imgs[0]->{'location'};
    if (!-d $imgpath) {
        die "ERROR: Image path does not exist ($imgpath)";
    }
}

# get headnode's interface information from OSCAR database
my $iface = OSCAR::Database::get_headnode_iface(undef, undef);
if (!OSCAR::Utils::is_a_valid_string ($iface)) {
    die "ERROR: Invalid network interface";
}


#
# Default settings hash array:
# The keys which have corresponding fields in the gmond.conf file are
# built by concatenating block and variable names. The separator is built out
# of two underscore symbols. For example the block
#   cluster {
#     name = "OSCARcluster"
#     owner = "OSCAR"
#   }
# leads to two potential key values: cluster__name and cluster__owner
# Multiple blocking levels are allowed.
# These keys should be identical to the variable names in the configurator.xml
# file!
#
#
my %default = (
           cluster__name => "OSCAR cluster",
           cluster__owner => "OSCAR",
           udp_send_channel__mcast_if => "$iface",
           udp_send_channel__port => "8649",
           udp_recv_channel__mcast_if => "$iface",
           udp_recv_channel__port => "8649",
           gridname => "OSCAR",
           datasource => "$hostname",
           gmond_per_image => "NO",
);


my $master_conf = OSCAR::Configurator_backend::readInConfigValues($masterconf, 
                                                                  "ganglia",
                                                                  "",
                                                                  noarray=>1);

if (add_missing_keys($master_conf, \%default)) {
    die "ERROR: Impossible to add missing keys ($master_conf)";
}

if ($image) {
    if ($do_gmond) {
        my $gmond_img = $imgpath.$gmond_conf;
        if ($master_conf->{gmond_per_image} eq "YES") {
            #
            # per image configuration
            #
            my $imgconf = "$imgconfd/$image/configurator.html";
            #
            # read in per image configurator data, if it exists
            #
            if (-e $imgconf) {
                vprint("using per image config $imgconf\n");
                my $img_conf = OSCAR::Configurator_backend::readInConfigValues
                    ($imgconf, "ganglia", "image:$image", noarray=>1);
                vprint(Dumper(%{$img_conf}));
                if (add_missing_keys($master_conf, $img_conf)) {
                    die "ERROR: Impossible to add missing keys ($master_conf)";
                }
                if (edit_gmond_conf($gmond_img, $img_conf)) {
                    die "ERROR: Impossible to add missing keys ".
                        "($gmond_img, $img_conf)";
                }
            } else {
                die ("ERROR: Per image configuration expected, ".
                     "but no values file found for $image!\n");
            }
        } else {
            #
            # copy master gmond configuration to image
            #
            if (system("cp -p $gmond_conf $gmond_img")) {
                die ("ERROR: Could not copy $gmond_conf to $gmond_img: $!");
            }
        }
    }
} else {
    #
    # master configuration
    #
    if ($do_gmond) {
        if (edit_gmond_conf($gmond_conf, $master_conf)) {
            die "ERROR: Impossible to edit gmond configuration ($gmond_conf, ".
                "$master_conf)";
        }
        if (restart_gmond()) {
            die "ERROR: Impossible to restart gmond";
        }
    }
    if ($do_gmetad) {
        if (add_multicast_route()) {
            die "ERROR: Impossible to add multicast route";
        }
        if (restart_gmond()) {
            die "ERROR: Impossible to restart gmond";
        }
        if (edit_gmetad_conf($gmetad_conf, $master_conf)) {
            die "ERROR: Impossible to edit gmetad_conf";
        }
        if (restart_gmetad()) {
            die "ERROR: Impossible to restart gmetad";
        }
    }
}

exit 0;

sub help () {
    print "Usage:\n";
    print "  $0 [--gmetad] [--gmond] [--image <image>] [--verbose]\n";
}

sub help_and_exit {
    help();
    exit 0;
}

sub help_and_die {
    help ();
    exit 1;
}

sub vprint {
    if ($verbose) {
        print STDERR (@_);
    }
}

# Return: 0 if success, -1 else.
sub add_missing_keys ($$) {
    my ($src, $tgt) = @_;

    if (!defined $src || (ref($src) ne "HASH")) {
        carp "ERROR: None valid source";
        return -1;
    }
    for my $k (keys(%{$src})) {
        if (!exists($tgt->{$k})) {
            $tgt->{$k} = $src->{$k};
        }
    }
    return 0;
}

##############
### gmetad ###
##############

# Return: 0 if success, -1 else.
sub edit_gmetad_conf ($$) {
    my ($gmetad_conf, $ref) = @_;
    my %config = %{$ref};

    vprint("editing $gmetad_conf\n");
    #
    # Replacement patterns for gmetad.conf transformations
    # Variables in <..> are replaced by their values in the
    # configuration file! Be sure to quote stuff like \"
    # Keys of this hash must be the variable names related to
    # gmetad configuration.
    #
    my %del_patterns = (
       gridname   => "gridname\\s+.*",
       datasource => "data_source\\s+.*",
               );
    my %add_patterns = (
       gridname => "gridname \"<gridname>\"",
       datasource => "data_source \"<cluster__name>\" $hostname",
               );

    my @gmetad;
    open(CONF, $gmetad_conf) 
        or (carp("ERROR: unable to open $gmetad_conf\n"), return -1);
    @gmetad = <CONF>;
    close(CONF);

    #
    # filter out gmetad delete patterns
    #
    for my $pat (keys %del_patterns) {
        my $match = $del_patterns{$pat};
        vprint("match: $match\n");
        my @tmp = grep !/\s*($match)$/, @gmetad;
        @gmetad = @tmp;
    }

    #
    # append gmetad add_patterns with substituted variables
    #
    for my $pat (keys %add_patterns) {
        my $line = $add_patterns{$pat};
        my @vars;
        my $replaces = $line;
        while ($replaces =~ s/<(\w+)>//) {
            my $var = $1;
            push @vars, $var;
            if (exists($ref->{$var})) {
                $line =~ s/<$var>/$config{$var}/;
            }
        }
        push @gmetad, "$line\n";
    }

    #
    # for per-image configs, add data sources for each cluster
    #
    if ($config{gmond_per_image} eq "YES") {
        for my $ds (@{&img_datasources(\%config)}) {
            push @gmetad, $ds;
        }
    }

    if ($test) {
        print STDOUT @gmetad;
        return 0;
    }
    open (OUT, "> $gmetad_conf") or
    croak "Could not open $gmetad_conf";
    print OUT @gmetad;
    close(OUT);

    return 0;
}

sub img_datasources($) {
    my ($ref) = @_;
    my %config = %{$ref};
    my @out;
    my %imgcfg;

    vprint("finding datasources for each image\n");
    my $master_port = $config{udp_recv_channel__port};
    my $master_iface = $config{udp_recv_channel__mcast_if};
    # images configured
    my @imgs = glob("$imgconfd/*");
    vprint("img_datasources: images: ".join(" ",@imgs)."\n");
    foreach (@imgs) {
    s/.*\///g;  # basename
    }
    for my $img (@imgs) {
        vprint("finding gmetad config for image $img\n");
        # get cluster name and port from per image config
        # if same port as master, skip
        my $imgconf = "$imgconfd/$img/configurator.html";
        if (-e $imgconf) {
            %imgcfg = %{readInConfigValues($imgconf,"ganglia","image:$img",noarray=>1)};
        } else {
            opkg_print "configurator values for image $img not found!\n";
            next;
        }
        my $imgport = $imgcfg{udp_send_channel__port};
        if ($master_port eq $imgport) {
            print STDERR "Image $img nodes use same gmond port as master.\n";
            print STDERR "Skipping $img nodes as gmetad data_source\n";
            next;
        }
        my $imgcname = $imgcfg{cluster__name};

        # get list of nodes attributed to image
        my @imgnodes;
        for my $i (list_client(imagename => $img)) {
            my $name = $i->name;
            push @imgnodes, $name if ($name);
        }
        next if (!scalar(@imgnodes));

        # create data_source entry
        my $line = "data_source \"$imgcname\" ".join(" ",@imgnodes)."\n";
        vprint("per image datasource ($img) : $line\n");
        push @out, $line;
    }
    return \@out;
}

#############
### gmond ###
#############

# Return: -1 if error, 0 else.
sub edit_gmond_conf ($$) {
    my ($gmond_conf, $ref) = @_;
    my %config = %{$ref};
    my @keywords = keys(%config);
    my @stack;
    my $level=0;
    my $comment=0;

    vprint("editing $gmond_conf\n");
    if (!-f $gmond_conf) {
        carp "ERROR: $gmond_conf does not exist";
        return -1;
    }
    open IN, $gmond_conf or croak "Could not open file $!";
    my @gmond = <IN>;
    close(IN);

    open OUT, "> $gmond_conf" or (carp "ERROR: Could not open file $!",
                                  return -1);
    foreach (@gmond) {
        chomp;
        # ignore full line comments
        if (/^\s*\/\*.*\*\/\s*$/) {
            goto out;
        }
        if (/^\s*\/\*/) {
            $comment = 1;
            goto out;
        }
        if (/\*\/\s*$/) {
            $comment = 0;
            goto out;
        }
        goto out if ($comment);
        #
        if (/^\s*(\S+)\s*\{/) {
            my $block = $1;
            push @stack, $block;
            $level++;
        }
        if (/^\s*\}\s*$/) {
            $level--;
            pop @stack;
        }
        if (/^(\s*)(\S+)\s*=(.*)$/) {
            my $blank = $1;
            my $name = $2;
            my $value = $3;
            $value =~ s/^\s+//;
            $value =~ s/\s+$//;
            # check if match
            my $match = join("__",(@stack,$name));
            if (grep /$match/, @keywords) {
                my $q;
                $q = "\"" if ($value =~ /^\"/);
                print OUT "$name = $q" . $config{$match} . "$q\n" if (!$test);
                opkg_print "Changed line: $blank$name = $q".
                           $config{$match}."$q\n";
                next;
            }
        }
      out:
        print OUT "$_\n" if (!$test);
    }
    close OUT;

    return 0;
}

# Return: 0 if success, -1 else.
sub add_multicast_route () {
    my $route_string;
    my $static_route_file;
    my $reload_route;

    # use OCA framework to detect the os release.
    my $os = OSCAR::OCA::OS_Detect::open();
    my $release = $os->{'compat_distro'};

    # Mandriva and SuSE have a different approach to set and start
    # static routes:
    if ($release eq 'mdv') {
        $route_string = "ADDRESS0=224.0.0.0 NETMASK0=240.0.0.0"; 
        $static_route_file = "/etc/sysconfig/network-scripts/$iface.route";
    } elsif ($release eq 'suse') {
        $route_string = "224.0.0.0/4 0.0.0.0 - $iface"; 
        $static_route_file = "/etc/sysconfig/network/routes";
    } else {
        $route_string = "224.0.0.0/4 dev $iface";
        $static_route_file = "/etc/sysconfig/network-scripts/route-$iface";
    }

    if ($release eq 'suse') {
        # SuSE script to reload routes
        $reload_route = "/etc/sysconfig/network/scripts/ifup-route $iface";
    } else {
        #reload route command, common for both Mandriva and the others distros
        $reload_route = "/etc/sysconfig/network-scripts/ifup-routes $iface";
    }

    # Check to see if multicast route already exists
    my $mcast_route = `route -n | grep 224.0.0.0 | grep $iface`;

    if (!($mcast_route)) {
        if (-e $static_route_file) {
            $mcast_route = `grep 224.0.0.0 $static_route_file`;
        }
        if (!($mcast_route)) {
            opkg_print("Adding default route for multicast to go through $iface.\n");
            `echo $route_string >> $static_route_file`;
        }
        `$reload_route`;
    }
    return 0;
}

# Return: 0 if success, -1 else.
sub restart_gmond () {
    opkg_print("Ganglia gmond configuration file modified, re-starting daemon...\n");

    my $file = "/etc/init.d/gmond";
    if (!-f $file) {
        carp "ERROR: $file does not exist";
        return -1;
    }

    my $cmd = "$file restart";
    # restart gmond
    if (system($cmd)) {
        carp("ERROR: Impossible to execute $cmd");
        return -1;
    }

    return 0;
}

# Return: 0 if success, -1 else.
sub restart_gmetad () {
    opkg_print("Ganglia gmetad configuration file modified, re-starting daemon...\n");
    my $file = "/etc/init.d/gmetad";
    if (!-f $file) {
        carp "ERROR: $file does not exist";
        return -1;
    }
    # restart gmetad
    my $cmd = "$file restart";
    if (system($cmd)) {
        carp ("ERROR: Impossible to execute $cmd");
        return -1;
    }
    opkg_print("Starting up apache...\n");
    # autoload apache in levels 345 and start it up
    my $HTTPD;
    for my $srv ("httpd", "apache2", "apache") {
        if (-x "/etc/init.d/$srv") {
            $HTTPD=$srv;
            last;
        }
    }
    if (!$HTTPD) {
        carp ("ERROR: Could not find any init script for httpd!");
        return -1;
    }
    if (add_httpd_conf()) {
        carp "ERROR: Impossible to update httpd configuration";
        return -1;
    }
    if (system("/sbin/chkconfig $HTTPD on")) {
        carp("ERROR: Failed to turn on $HTTPD with chkconfig");
        return -1;
    }
    if (system("/etc/init.d/$HTTPD restart")) {
        carp ("ERROR: Failed to restart $HTTPD");
        return -1;
    }
    opkg_print("Ganglia page is located at http://$hostname/ganglia/\n");
    return 0;
}

# Return: 0 if success, -1 else.
sub add_httpd_conf() {
    my $confdir;
    for my $d ("httpd", "apache2", "apache") {
        if (-d "/etc/$d/conf.d") {
            $confdir="/etc/$d/conf.d";
            last;
        }
    }
    if (!$confdir) {
        carp ("ERROR: Could not find apache configuration directory!");
        return -1;
    }
    if (! -f "$confdir/ganglia.conf") {
        open C, "> $confdir/ganglia.conf" 
            or (carp "ERROR: Could not open ganglia.conf: $!",
                return -1);
        print C <<EOI;
Alias /ganglia /var/www/html/ganglia/
<Directory /var/www/html/ganglia/>
   Options None
   order deny,allow
   deny from all
   allow from all
</Directory>
EOI
        close C;
    }
    return 0;
}
