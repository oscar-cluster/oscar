#!/usr/bin/env /usr/bin/perl
# $Id$
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This script reads the Configurator result and sets up the configuration
# files /etc/gmond.conf and /etc/gmetad.conf for the server. Similar
# configuration steps are done for each image.
#
# Copyright 2005 Erich Focht <efocht@hpce.nec.com>
#

use XML::Simple;
use Carp;
use strict;
use Getopt::Long;
use lib "/usr/lib/systeminstaller";
use lib "$ENV{OSCAR_HOME}/lib";
use SIS::DB;
use SIS::Image;
use SIS::Client;
use Data::Dumper;
use OSCAR::Database;
use OSCAR::Opkg;

my ($do_gmond, $do_gmetad, $image, @options, $test, $verbose);
GetOptions( 'gmond'   => \$do_gmond,
	    'gmetad'  => \$do_gmetad,
	    'image=s' => \$image,
	    'option=s'=> \@options,
	    'test'    => \$test,
            'verbose' => \$verbose, )
    || usage();


my $gmetad_conf = "/etc/gmetad.conf";
my $gmond_conf = "/etc/gmond.conf";
if ($test) {
    $gmetad_conf = "gmetad.conf";
    $gmond_conf = "gmond.conf";
    $ENV{OSCAR_PACKAGE_HOME} = ".";
}
my $xml_data = "$ENV{OSCAR_PACKAGE_HOME}/.configurator.values";
my $xml_imgd = "$ENV{OSCAR_PACKAGE_HOME}/.configs";

my $hostname = `hostname`;
chomp($hostname);

# find image path
my $imgpath;
if ($image) {
    my @imgs = list_image(name => $image);
    if (!scalar(@imgs)) {
	croak("Could not find image $image in the SIS database!\n");
    }
    $imgpath = $imgs[0]->location;
}

# get headnode's interface information from OSCAR database
my $iface = get_headnode_iface();


#
# Default settings hash array:
# The keys which have corresponding fields in the gmond.conf file are
# built by concatenating block and variable names. The separator is built out
# of two underscore symbols. For example the block
#   cluster {
#     name = "OSCARcluster"
#     owner = "OSCAR"
#   }
# leads to two potential key values: cluster__name and cluster__owner
# Multiple blocking levels are allowed.
# These keys should be identical to the variable names in the configurator.xml
# file!
#
#
my %default = (
	       cluster__name => "OSCAR cluster",
	       cluster__owner => "OSCAR",
	       udp_send_channel__mcast_if => "$iface",
	       udp_send_channel__port => "8649",
	       udp_recv_channel__mcast_if => "$iface",
	       udp_recv_channel__port => "8649",
	       gridname => "OSCAR",
	       datasource => "$hostname",
	       gmond_per_image => "NO",
);


my $master_conf;
if (-e $xml_data) {
    $master_conf = XMLin($xml_data);
} else {
    $master_conf = \%default;
}

if ($image) {
    if ($do_gmond) {
	my $gmond_img = $imgpath.$gmond_conf;
	if ($master_conf->{gmond_per_image} eq "YES") {
	    #
	    # per image configuration
	    #
	    my $xml_img = "$xml_imgd/$image/.configurator.values";
	    #
	    # read in per image configurator data, if it exists
	    #
	    if (-e $xml_img) {
		vprint("using per image values file $xml_img\n");
 		my $img_conf = XMLin($xml_img);
		vprint(Dumper(%{$img_conf}));
		add_missing_keys($master_conf, $img_conf);
		&edit_gmond_conf($gmond_img, $img_conf);
	    } else {
		croak("Per image configuration expected, but no values file found for $image!\n");
	    }
	} else {
	    #
	    # copy master gmond configuration to image
	    #
	    !system("cp -p $gmond_conf $gmond_img") or
		croak("Could not copy $gmond_conf to $gmond_img: $!");
	}
    }
} else {
    #
    # master configuration
    #
    if ($do_gmond) {
	&edit_gmond_conf($gmond_conf, $master_conf);
	&restart_gmond();
    }
    if ($do_gmetad) {
	&add_multicast_route();
	&edit_gmetad_conf($gmetad_conf, $master_conf);
	&restart_gmetad();
    }
}
exit 0;


sub usage {
    print "Usage:\n";
    print "  $0 [--gmetad] [--gmond] [--image <image>] [--verbose]\n";
    exit 1;
}

sub vprint {
    if ($verbose) {
	print STDERR (@_);
    }
}

sub add_missing_keys {
    my ($src, $tgt) = @_;
    for my $k (keys(%{$src})) {
	if (!exists($tgt->{$k})) {
	    $tgt->{$k} = $src->{$k};
	}
    }
}

##############    
### gmetad ###
##############    

sub edit_gmetad_conf {
    my ($gmetad_conf, $ref) = @_;
    my %config = %{$ref};

    vprint("editing $gmetad_conf\n");
    #
    # Replacement patterns for gmetad.conf transformations
    # Variables in <..> are replaced by their values in the
    # configuration file! Be sure to quote stuff like \"
    # Keys of this hash must be the variable names related to
    # gmetad configuration.
    #
    my %del_patterns = (
	   gridname   => "gridname\\s+.*",
	   datasource => "data_source\\s+.*",
			   );
    my %add_patterns = (
	   gridname => "gridname \"<gridname>\"",
	   datasource => "data_source \"<cluster__name>\" $hostname",
			   );
    
    my @gmetad;
    open(CONF, $gmetad_conf) or
	croak("Error: unable to open ($gmetad_conf)\n");
    @gmetad = <CONF>;
    close(CONF);

    #
    # filter out gmetad delete patterns
    #
    for my $pat (keys %del_patterns) {
	my $match = $del_patterns{$pat};
	vprint("match: $match\n");
	my @tmp = grep !/\s*($match)$/, @gmetad;
	@gmetad = @tmp;
    }

    #
    # append gmetad add_patterns with substituted variables
    #
    for my $pat (keys %add_patterns) {
	my $line = $add_patterns{$pat};
	my @vars;
	my $replaces = $line;
	while ($replaces =~ s/<(\w+)>//) {
	    my $var = $1;
	    push @vars, $var;
	    if (exists($ref->{$var})) {
		$line =~ s/<$var>/$config{$var}/;
	    }
	}
	push @gmetad, "$line\n";
    }

    #
    # for per-image configs, add data sources for each cluster
    #
    if ($config{gmond_per_image} eq "YES") {
	for my $ds (@{&img_datasources(\%config)}) {
	    push @gmetad, $ds;
	}
    }

    if ($test) {
	print STDOUT @gmetad;
	return;
    }
    open (OUT, "> $gmetad_conf") or
	croak "Could not open $gmetad_conf";
    print OUT @gmetad;
    close(OUT);
}

sub img_datasources {
    my ($ref) = @_;
    my %config = %{$ref};
    my @out;
    my %imgcfg;

    vprint("finding datasources for each image\n");
    my $master_port = $config{udp_recv_channel__port};
    my $master_iface = $config{udp_recv_channel__mcast_if};
    # images configured
    my @imgs = glob("$xml_imgd/*");
    vprint("img_datasources: images: ".join(" ",@imgs)."\n");
    foreach (@imgs) {
	s/.*\///g;  # basename
    }
    for my $img (@imgs) {
	vprint("finding gmetad config for image $img\n");
	# get cluster name and port from per image config
	# if same port as master, skip
	my $xml_img = "$xml_imgd/$img/.configurator.values";
	if (-e $xml_img) {
	    %imgcfg = %{XMLin($xml_img)};
	} else {
	    opkg_print "configurator values for image $img not found!\n";
	    next;
	}
	my $imgport = $imgcfg{udp_send_channel__port};
	if ($master_port eq $imgport) {
	    print STDERR "Image $img nodes use same gmond port as master.\n";
	    print STDERR "Skipping $img nodes as gmetad data_source\n";
	    next;
	}
	my $imgcname = $imgcfg{cluster__name};
	
	# get list of nodes attributed to image
	my @imgnodes;
	for my $i (list_client(imagename => $img)) {
	    my $name = $i->name;
	    push @imgnodes, $name if ($name);
	}
	next if (!scalar(@imgnodes));
	
	# create data_source entry
	my $line = "data_source \"$imgcname\" ".join(" ",@imgnodes)."\n";
	vprint("per image datasource ($img) : $line\n");
	push @out, $line;
    }
    return \@out;
}

#############    
### gmond ###
#############    
sub edit_gmond_conf {
    my ($gmond_conf, $ref) = @_;
    my %config = %{$ref};
    my @keywords = keys(%config);
    my @stack;
    my $level=0;
    my $comment=0;

    vprint("editing $gmond_conf\n");
    open IN, $gmond_conf or croak "Could not open file $!";
    my @gmond = <IN>;
    close(IN);

    open OUT, "> $gmond_conf" or croak "Could not open file $!";
    foreach (@gmond) {
	chomp;
	# ignore full line comments
	if (/^\s*\/\*.*\*\/\s*$/) {
	    goto out;
	}
	if (/^\s*\/\*/) {
	    $comment = 1;
	    goto out;
	}
	if (/\*\/\s*$/) {
	    $comment = 0;
	    goto out;
	}
	goto out if ($comment);
	#
	if (/^\s*(\S+)\s*\{/) {
	    my $block = $1;
	    push @stack, $block;
	    $level++;
	}
	if (/^\s*\}\s*$/) {
	    $level--;
	    pop @stack;
	}
	if (/^(\s*)(\S+)\s*=(.*)$/) {
	    my $blank = $1;
	    my $name = $2;
	    my $value = $3;
	    $value =~ s/^\s+//;
	    $value =~ s/\s+$//;
	    # check if match
	    my $match = join("__",(@stack,$name));
	    if (grep /$match/, @keywords) {
		my $q;
		$q = "\"" if ($value =~ /^\"/);
		print OUT "$name = $q" . $config{$match} . "$q\n" if (!$test);
		opkg_print "Changed line: $blank$name = $q" . $config{$match} . "$q\n";
		next;
	    }
	}
      out:
	print OUT "$_\n" if (!$test);
    }
    close OUT;
}

sub add_multicast_route {
    my $route_string;
    my $static_route_file;
    my $reload_route;

    # FIXME: OCA Framework
    # There are two different ways to setup static routes, Mandriva uses the "old" style right now...
    if ( (-e "/etc/mandrake-release") || (-e "/etc/mandrakelinux-release") ) {
	$route_string = "any net 224.0.0.0 netmask 240.0.0.0 dev $iface"; 
	$static_route_file = "/etc/sysconfig/static-routes";
	$reload_route = "service network restart"; 
    } else {
	$route_string = "224.0.0.0/4 dev $iface";
    	$static_route_file = "/etc/sysconfig/network-scripts/route-$iface";
	$reload_route = "/etc/sysconfig/network-scripts/ifup-routes $iface";
    }

    # Check to see if multicast route already exists
    my $mcast_route = `route | grep 224.0.0.0 | grep $iface`;

    if (!($mcast_route)) {
        if (-e $static_route_file) {
		$mcast_route = `grep 224.0.0.0 $static_route_file`;
	}
	if (!($mcast_route)) {
		opkg_print("Adding default route for multicast to go through $iface.\n");
		`echo $route_string >> $static_route_file`;
	}
	`$reload_route`;
    }
}

sub restart_gmond {
    opkg_print("Ganglia gmond configuration file modified, re-starting daemon...\n");
    # restart gmond and gmetad
    !system("/etc/init.d/gmond restart") or croak("Failed to restart gmond");
}

sub restart_gmetad {
    opkg_print("Ganglia gmetad configuration file modified, re-starting daemon...\n");
    # restart gmond and gmetad
    !system("/etc/init.d/gmetad restart") or croak("Failed to restart gmetad");
    opkg_print("Starting up apache...\n");
    # autoload apache in levels 345 and start it up
    !system("/sbin/chkconfig --levels 345 httpd on") or croak("Failed to turn on httpd for levels 345 using chkconfig");
    !system("/etc/init.d/httpd start") or croak("Failed to start httpd");
    opkg_print("Ganglia page is located at http://$hostname/ganglia/\n");
}
